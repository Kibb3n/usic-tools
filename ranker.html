<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ranker - Î¼sic tools</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        html, body { background: #000; }
        @keyframes blob1 {

            0%,
            100% {
                transform: translate(0, 0) scale(1);
            }

            33% {
                transform: translate(150px, 100px) scale(1.2);
            }

            66% {
                transform: translate(-100px, 150px) scale(0.9);
            }
        }

        @keyframes blob2 {

            0%,
            100% {
                transform: translate(0, 0) scale(1);
            }

            33% {
                transform: translate(-150px, -100px) scale(0.9);
            }

            66% {
                transform: translate(100px, -150px) scale(1.2);
            }
        }

        @keyframes slideIn {
            from {
                transform: translateY(100%);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateY(0);
                opacity: 1;
            }

            to {
                transform: translateY(100%);
                opacity: 0;
            }
        }

        .line-clamp-2 {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .notification-enter {
            animation: slideIn 0.3s ease-out;
        }

        .notification-exit {
            animation: slideOut 0.3s ease-out;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // Local storage utilities
        const AUTOSAVE_KEY = 'ranker_autosaves';
        const MAX_AUTOSAVES = 5;

        const loadAutoSaves = () => {
            try {
                const saved = localStorage.getItem(AUTOSAVE_KEY);
                return saved ? JSON.parse(saved) : [];
            } catch (e) {
                return [];
            }
        };

        const isBandcampUrl = (url) => {
            return url.includes('bandcamp.com');
        };

        const isSpotifyUrl = (url) => {
            return url.includes('spotify.com') || url.includes('open.spotify');
        };

        const isAppleMusicUrl = (url) => {
            return url.includes('music.apple.com');
        };

        const isDeezerUrl = (url) => {
            return url.includes('deezer.com');
        };

        const saveAutoSave = (data) => {
            try {
                const autosaves = loadAutoSaves();
                const sessionId = data.sessionId || data.state?.selectedArtist?.artistId || data.state?.selectedArtist?.collectionId || Date.now();
                const newSave = {
                    ...data,
                    sessionId,
                    timestamp: Date.now(),
                    id: sessionId
                };

                // Upsert: replace existing entry with same sessionId, otherwise prepend
                const existingIdx = autosaves.findIndex(s => s.sessionId === sessionId || s.id === sessionId);
                if (existingIdx !== -1) {
                    autosaves[existingIdx] = newSave;
                } else {
                    autosaves.unshift(newSave);
                }
                const trimmed = autosaves.slice(0, MAX_AUTOSAVES);

                localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(trimmed));
            } catch (e) {
                console.error('Failed to autosave:', e);
            }
        };

        const deleteAutoSave = (id) => {
            try {
                const autosaves = loadAutoSaves();
                const filtered = autosaves.filter(save => save.id !== id);
                localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(filtered));
            } catch (e) {
                console.error('Failed to delete autosave:', e);
            }
        };

        // Icons
        const Music = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 12c2.7 0 4.8-2.1 4.8-4.8S14.7 2.4 12 2.4 7.2 4.5 7.2 7.2 9.3 12 12 12z" />
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3.6 21.6c0-4.64 3.76-8.4 8.4-8.4s8.4 3.76 8.4 8.4" />
            </svg>
        );

        const Search = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
        );

        const ArrowLeft = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 19l-7-7m0 0l7-7m-7 7h18" />
            </svg>
        );

        const ChevronRight = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
            </svg>
        );

        const Loader2 = ({ className }) => (
            <svg className={className + " animate-spin"} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
            </svg>
        );

        const Album = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <circle cx="12" cy="12" r="10" strokeWidth={2} />
                <circle cx="12" cy="12" r="3" strokeWidth={2} />
            </svg>
        );

        const Download = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
            </svg>
        );

        const Save = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" />
            </svg>
        );

        const HelpCircle = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
        );

        const Undo = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
            </svg>
        );

        const Play = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
        );

        const Pause = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
        );

        const X = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
        );

        const AlertCircle = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
        );

        const TrendingUp = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" />
            </svg>
        );

        const TrendingDown = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 17h8m0 0V9m0 8l-8-8-4 4-6-6" />
            </svg>
        );

        const Trash = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
            </svg>
        );

        const ArrowUp = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 10l7-7m0 0l7 7m-7-7v18" />
            </svg>
        );

        const ArrowDown = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 14l-7 7m0 0l-7-7m7 7V3" />
            </svg>
        );

        const Clock = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
        );

        const Check = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
            </svg>
        );

        const ChevronDown = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
            </svg>
        );

        const Grid = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
            </svg>
        );

        const List = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
            </svg>
        );

        const Link = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
            </svg>
        );

        // Utility functions
        const jsonpRequest = (url) => {
            return new Promise((resolve, reject) => {
                const callbackName = 'jsonp_callback_' + Math.round(100000 * Math.random());
                window[callbackName] = (data) => {
                    delete window[callbackName];
                    document.body.removeChild(script);
                    resolve(data);
                };
                const script = document.createElement('script');
                script.src = url + (url.indexOf('?') >= 0 ? '&' : '?') + 'callback=' + callbackName;
                script.onerror = () => {
                    delete window[callbackName];
                    document.body.removeChild(script);
                    reject(new Error('JSONP request failed'));
                };
                document.body.appendChild(script);
            });
        };

        const extractDominantColor = async (imageUrl) => {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'Anonymous';
                img.onload = () => {
                    try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = 100;
                        canvas.height = 100;
                        ctx.drawImage(img, 0, 0, 100, 100);
                        const data = ctx.getImageData(25, 25, 50, 50).data;

                        let r = 0, g = 0, b = 0;
                        for (let i = 0; i < data.length; i += 4) {
                            r += data[i];
                            g += data[i + 1];
                            b += data[i + 2];
                        }
                        const pixels = data.length / 4;
                        r = Math.floor(r / pixels);
                        g = Math.floor(g / pixels);
                        b = Math.floor(b / pixels);

                        resolve(`rgb(${r}, ${g}, ${b})`);
                    } catch (e) {
                        resolve('#ff0080');
                    }
                };
                img.onerror = () => resolve('#ff0080');
                img.src = imageUrl;
            });
        };

        const processTracksToUniqueSongs = async (tracks) => {
            const seenSongs = new Map();

            for (const track of tracks) {
                const songKey = track.trackName.toLowerCase().trim();
                if (!seenSongs.has(songKey)) {
                    const color = await extractDominantColor(track.artworkUrl100);
                    seenSongs.set(songKey, {
                        name: track.trackName,
                        artwork: track.artworkUrl100,
                        albumName: track.collectionName,
                        color: color,
                        previewUrl: track.previewUrl
                    });
                }
            }
            return Array.from(seenSongs.values());
        };

        const shuffleArray = (array) => {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        };

        // Background component
        function AnimatedBackground({ colors }) {
            return (
                <div className="absolute inset-0 overflow-hidden">
                    <div
                        className="absolute w-[900px] h-[900px] rounded-full opacity-70 blur-3xl"
                        style={{
                            background: `radial-gradient(circle, ${colors[0]} 0%, transparent 70%)`,
                            animation: `blob1 12s ease-in-out infinite`,
                            top: '50%',
                            left: '33.333%',
                            transform: 'translate(-50%, -50%)',
                            transition: 'background 2s ease-in-out'
                        }}
                    />
                    <div
                        className="absolute w-[900px] h-[900px] rounded-full opacity-70 blur-3xl"
                        style={{
                            background: `radial-gradient(circle, ${colors[1]} 0%, transparent 70%)`,
                            animation: `blob2 12s ease-in-out infinite`,
                            top: '50%',
                            right: '33.333%',
                            transform: 'translate(50%, -50%)',
                            transition: 'background 2s ease-in-out'
                        }}
                    />
                    <div className="absolute inset-0 grain" />
                </div>
            );
        }

        // Notification Component
        function Notification({ message, type, songIdx, onClose, onMoveTop, onMoveBottom }) {
            useEffect(() => {
                const timer = setTimeout(onClose, 10000);
                return () => clearTimeout(timer);
            }, [onClose]);

            const Icon = type === 'trending-up' ? TrendingUp : TrendingDown;
            const bgColor = type === 'trending-up' ? 'bg-green-500/20 border-green-500/50' : 'bg-red-500/20 border-red-500/50';

            return (
                <div className={`notification-enter fixed bottom-6 right-6 ${bgColor} backdrop-blur-xl rounded-xl p-4 border shadow-2xl max-w-sm z-50`}>
                    <div className="flex items-start gap-3 mb-3">
                        <Icon className="w-6 h-6 text-white flex-shrink-0 mt-0.5" />
                        <div className="flex-1">
                            <p className="text-white text-sm leading-relaxed">{message}</p>
                        </div>
                        <button onClick={onClose} className="text-white/70 hover:text-white">
                            <X className="w-5 h-5" />
                        </button>
                    </div>
                    <div className="flex gap-2 ml-9">
                        {type === 'trending-up' && onMoveTop && (
                            <button
                                onClick={() => {
                                    onMoveTop();
                                    onClose();
                                }}
                                className="flex-1 px-3 py-2 bg-green-500/30 hover:bg-green-500/50 text-white rounded-lg text-sm font-medium flex items-center justify-center gap-1"
                            >
                                <ArrowUp className="w-4 h-4" />
                                Move to Top
                            </button>
                        )}
                        {type === 'trending-down' && onMoveBottom && (
                            <button
                                onClick={() => {
                                    onMoveBottom();
                                    onClose();
                                }}
                                className="flex-1 px-3 py-2 bg-red-500/30 hover:bg-red-500/50 text-white rounded-lg text-sm font-medium flex items-center justify-center gap-1"
                            >
                                <ArrowDown className="w-4 h-4" />
                                Move to Bottom
                            </button>
                        )}
                        <button
                            onClick={onClose}
                            className="px-3 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg text-sm font-medium"
                        >
                            Dismiss
                        </button>
                    </div>
                </div>
            );
        }

        // Modal Component
        function Modal({ isOpen, onClose, onSubmit, title, fields, message }) {
            const [values, setValues] = useState({});

            useEffect(() => {
                if (isOpen) {
                    const initial = {};
                    fields?.forEach(field => initial[field.name] = field.defaultValue || '');
                    setValues(initial);
                }
            }, [isOpen, fields]);

            if (!isOpen) return null;

            const handleSubmit = (e) => {
                e.preventDefault();
                onSubmit(values);
                onClose();
            };

            return (
                <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                    <div className="bg-white/10 backdrop-blur-2xl rounded-3xl p-8 max-w-md w-full border border-white/20 shadow-2xl">
                        <h3 className="text-2xl font-bold text-white mb-4">{title}</h3>
                        {message && <p className="text-gray-300 mb-6">{message}</p>}
                        {fields ? (
                            <form onSubmit={handleSubmit} className="space-y-4">
                                {fields.map(field => (
                                    <div key={field.name}>
                                        <label className="block text-white text-sm font-medium mb-2">
                                            {field.label}
                                        </label>
                                        <input
                                            type="text"
                                            value={values[field.name] || ''}
                                            onChange={(e) => setValues(v => ({ ...v, [field.name]: e.target.value }))}
                                            placeholder={field.placeholder}
                                            className="w-full px-4 py-3 bg-white/10 border border-white/20 rounded-xl text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50"
                                            required={field.required}
                                        />
                                    </div>
                                ))}
                                <div className="flex gap-3 pt-4">
                                    <button
                                        type="button"
                                        onClick={onClose}
                                        className="flex-1 px-6 py-3 bg-white/10 hover:bg-white/20 text-white rounded-xl font-semibold border border-white/20"
                                    >
                                        Cancel
                                    </button>
                                    <button
                                        type="submit"
                                        className="flex-1 px-6 py-3 bg-white text-black hover:bg-gray-100 rounded-xl font-semibold"
                                    >
                                        Confirm
                                    </button>
                                </div>
                            </form>
                        ) : (
                            <div className="flex gap-3 pt-4">
                                <button
                                    onClick={onClose}
                                    className="flex-1 px-6 py-3 bg-white/10 hover:bg-white/20 text-white rounded-xl font-semibold border border-white/20"
                                >
                                    Cancel
                                </button>
                                <button
                                    onClick={() => {
                                        onSubmit();
                                        onClose();
                                    }}
                                    className="flex-1 px-6 py-3 bg-red-500 hover:bg-red-600 text-white rounded-xl font-semibold"
                                >
                                    Confirm
                                </button>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        // Context Menu Component
        function ContextMenu({ x, y, onBest, onWorst, onExclude, onClose, canMoveBest, canMoveWorst }) {
            const menuRef = useRef(null);

            useEffect(() => {
                const handleClick = (e) => {
                    if (menuRef.current && !menuRef.current.contains(e.target)) {
                        onClose();
                    }
                };
                document.addEventListener('mousedown', handleClick);
                return () => document.removeEventListener('mousedown', handleClick);
            }, [onClose]);

            return (
                <div
                    ref={menuRef}
                    className="fixed bg-white/10 backdrop-blur-xl rounded-xl border border-white/20 shadow-2xl py-2 z-50"
                    style={{ left: x, top: y }}
                >
                    {canMoveBest && (
                        <button
                            onClick={onBest}
                            className="w-full px-6 py-3 text-left text-white hover:bg-white/10 flex items-center gap-2"
                        >
                            <TrendingUp className="w-4 h-4" />
                            Mark as Best
                        </button>
                    )}
                    {canMoveWorst && (
                        <button
                            onClick={onWorst}
                            className="w-full px-6 py-3 text-left text-white hover:bg-white/10 flex items-center gap-2"
                        >
                            <TrendingDown className="w-4 h-4" />
                            Mark as Worst
                        </button>
                    )}
                    <button
                        onClick={onExclude}
                        className="w-full px-6 py-3 text-left text-red-300 hover:bg-white/10 flex items-center gap-2"
                    >
                        <Trash className="w-4 h-4" />
                        Exclude Song
                    </button>
                </div>
            );
        }

        // Main Ranker Component
        function RankerMode() {
            const [state, setState] = useState({
                mode: null,
                stage: 'selectMode',
                selectedArtist: null,
                songs: [],
                songData: [],
                albums: [],
                selectedAlbums: new Set(),
                usedAlbums: [],
                excludedSongs: new Set()
            });

            const [search, setSearch] = useState({
                artistName: '',
                albumName: '',
                albumArtist: '',
                albumYear: '',
                suggestions: [],
                page: 0,
                loading: false,
                loadingSongs: false,
                error: ''
            });

            const [sorting, setSorting] = useState({
                sortedIndices: [],
                i: 0,
                j: 0,
                comparisons: 0,
                autoSkipped: 0,
                preferences: {},
                history: [],
                skippedPairs: new Set(),
                winCounts: {},
                lossCounts: {},
                lastEstimateUpdate: 0,
                estimatedRemaining: 0,
                notificationShownFor: new Set(),
                pinnedTop: new Set(),
                pinnedBottom: new Set()
            });

            const [bgColors, setBgColors] = useState(['#ff0080', '#7928ca']);
            const [playingAudio, setPlayingAudio] = useState({ index: null, audio: null });
            const [notification, setNotification] = useState(null);
            const [contextMenu, setContextMenu] = useState(null);
            const [modalOpen, setModalOpen] = useState(false);
            const [modalConfig, setModalConfig] = useState(null);
            const [autoSaves, setAutoSaves] = useState([]);
            const [showProgress, setShowProgress] = useState(false);
        const [showTierlistExport, setShowTierlistExport] = useState(false);
            const [viewMode, setViewMode] = useState('grid');
            const [showUrlImport, setShowUrlImport] = useState(false);
            const [urlInput, setUrlInput] = useState('');
            const [autoSaveStatus, setAutoSaveStatus] = useState('idle');
            const [autoSaveCollapsed, setAutoSaveCollapsed] = useState(false);
            const fileInputRef = useRef(null);
            const autoSaveTimerRef = useRef(null);
            const autoSaveStatusTimerRef = useRef(null);
            const sessionIdRef = useRef(null);

            useEffect(() => {
                setAutoSaves(loadAutoSaves());
            }, []);

            useEffect(() => {
                if (state.stage === 'sorting' && state.songs.length > 0) {
                    if (autoSaveTimerRef.current) {
                        clearInterval(autoSaveTimerRef.current);
                    }

                    // Assign a stable sessionId when ranking begins (once per session)
                    if (!sessionIdRef.current) {
                        sessionIdRef.current = state.selectedArtist?.artistId || state.selectedArtist?.collectionId || Date.now();
                    }

                    const doSave = () => {
                        const dataToSave = {
                            sessionId: sessionIdRef.current,
                            state: {
                                ...state,
                                selectedAlbums: Array.from(state.selectedAlbums),
                                excludedSongs: Array.from(state.excludedSongs)
                            },
                            sorting: {
                                ...sorting,
                                history: [],
                                skippedPairs: Array.from(sorting.skippedPairs),
                                notificationShownFor: Array.from(sorting.notificationShownFor),
                                pinnedTop: Array.from(sorting.pinnedTop),
                                pinnedBottom: Array.from(sorting.pinnedBottom)
                            },
                            search: {
                                artistName: search.artistName,
                                albumName: search.albumName,
                                albumArtist: search.albumArtist,
                                albumYear: search.albumYear
                            }
                        };
                        saveAutoSave(dataToSave);
                        setAutoSaves(loadAutoSaves());
                        setAutoSaveStatus('saved');
                        if (autoSaveStatusTimerRef.current) clearTimeout(autoSaveStatusTimerRef.current);
                        autoSaveStatusTimerRef.current = setTimeout(() => setAutoSaveStatus('idle'), 2500);
                    };

                    // Save every 5 comparisons
                    if (sorting.comparisons > 0 && sorting.comparisons % 5 === 0) {
                        doSave();
                    }

                    // Also save on interval as fallback
                    autoSaveTimerRef.current = setInterval(doSave, 10000);

                    return () => {
                        if (autoSaveTimerRef.current) {
                            clearInterval(autoSaveTimerRef.current);
                        }
                    };
                }
            }, [state, sorting, search]);

            useEffect(() => {
                if (state.stage === 'sorting' && sorting.j < sorting.sortedIndices.length - 1) {
                    const color1 = state.songData[sorting.sortedIndices[sorting.j]]?.color || '#ff0080';
                    const color2 = state.songData[sorting.sortedIndices[sorting.j + 1]]?.color || '#7928ca';
                    setBgColors([color1, color2]);
                }
            }, [sorting.j, state.stage, sorting.sortedIndices, state.songData]);

            useEffect(() => {
                return () => {
                    if (playingAudio.audio) {
                        playingAudio.audio.pause();
                    }
                };
            }, [playingAudio.audio]);

            const toggleAudio = (songIndex) => {
                const song = state.songData[sorting.sortedIndices[songIndex]];

                if (!song?.previewUrl) return;

                if (playingAudio.index === songIndex && playingAudio.audio) {
                    playingAudio.audio.pause();
                    setPlayingAudio({ index: null, audio: null });
                    return;
                }

                if (playingAudio.audio) {
                    playingAudio.audio.pause();
                }

                const audio = new Audio(song.previewUrl);
                audio.play();
                audio.onended = () => setPlayingAudio({ index: null, audio: null });
                setPlayingAudio({ index: songIndex, audio });
            };

            const handleUrlImport = async () => {
                const url = urlInput.trim();
                if (!url) {
                    setSearch(s => ({ ...s, error: 'Please enter a URL' }));
                    return;
                }

                if (isBandcampUrl(url)) {
                    setShowUrlImport(false);
                    setUrlInput('');
                    if (url.includes('/album/')) {
                        setState(s => ({ ...s, mode: 'album', stage: 'search' }));
                        setSearch(s => ({ ...s, albumName: url }));
                        await handleBandcampAlbum(url);
                    } else {
                        setState(s => ({ ...s, mode: 'artist', stage: 'search' }));
                        setSearch(s => ({ ...s, artistName: url }));
                        await handleBandcampArtist(url);
                    }
                } else if (isSpotifyUrl(url)) {
                    setSearch(s => ({ ...s, error: 'Spotify import is not yet supported. Coming soon!' }));
                } else if (isAppleMusicUrl(url)) {
                    setSearch(s => ({ ...s, error: 'Apple Music URL import is not yet supported. Coming soon!' }));
                } else if (isDeezerUrl(url)) {
                    setSearch(s => ({ ...s, error: 'Deezer import is not yet supported. Coming soon!' }));
                } else {
                    setSearch(s => ({ ...s, error: 'Unsupported URL. Please use Bandcamp, Spotify, Apple Music, or Deezer links.' }));
                }
            };

            const handleBandcampArtist = async (url) => {
                setSearch(s => ({ ...s, loading: true, error: '' }));

                try {
                    const proxyUrl = 'https://api.allorigins.win/raw?url=';
                    const response = await fetch(proxyUrl + encodeURIComponent(url));
                    const html = await response.text();

                    const artistMatch = html.match(/<meta property="og:site_name" content="([^"]+)"/);
                    const artistName = artistMatch ? artistMatch[1] : 'Unknown Artist';

                    const albumLinks = html.match(/href="([^"]*\/album\/[^"]+)"/g);
                    if (!albumLinks || albumLinks.length === 0) {
                        setSearch(s => ({ ...s, error: 'No albums found for this artist.', loading: false }));
                        return;
                    }

                    const uniqueAlbums = new Set();
                    albumLinks.forEach(link => {
                        const match = link.match(/href="([^"]+)"/);
                        if (match) {
                            const fullUrl = match[1].startsWith('http') ? match[1] : `${url.split('/').slice(0, 3).join('/')}${match[1]}`;
                            uniqueAlbums.add(fullUrl);
                        }
                    });

                    const albums = [];
                    for (let albumUrl of Array.from(uniqueAlbums).slice(0, 20)) {
                        try {
                            const albumResponse = await fetch(proxyUrl + encodeURIComponent(albumUrl));
                            const albumHtml = await albumResponse.text();
                            const albumTitleMatch = albumHtml.match(/<meta property="og:title" content="([^"]+)"/);
                            const albumImageMatch = albumHtml.match(/<meta property="og:image" content="([^"]+)"/);

                            if (albumTitleMatch) {
                                albums.push({
                                    collectionName: albumTitleMatch[1],
                                    artistName: artistName,
                                    artworkUrl100: albumImageMatch ? albumImageMatch[1] : null,
                                    collectionId: albumUrl,
                                    bandcampUrl: albumUrl,
                                    type: 'album',
                                    source: 'bandcamp'
                                });
                            }
                        } catch (e) {
                            console.error('Failed to fetch album:', e);
                        }
                    }

                    if (albums.length === 0) {
                        setSearch(s => ({ ...s, error: 'No albums found.', loading: false }));
                        return;
                    }

                    setState(s => ({ ...s, selectedArtist: { artistName, bandcampUrl: url }, albums, stage: 'selectAlbums' }));
                    setSearch(s => ({ ...s, loading: false }));
                } catch (err) {
                    setSearch(s => ({ ...s, error: 'Failed to load artist. Please make sure the URL is correct and try again.', loading: false }));
                }
            };

            const handleBandcampAlbum = async (url) => {
                setSearch(s => ({ ...s, loadingSongs: true, error: '' }));

                try {
                    const proxyUrl = 'https://api.allorigins.win/raw?url=';
                    const response = await fetch(proxyUrl + encodeURIComponent(url));

                    if (!response.ok) {
                        throw new Error('Failed to fetch page');
                    }

                    const html = await response.text();

                    const titleMatch = html.match(/<meta property="og:title" content="([^"]+)"/);
                    const artistMatch = html.match(/<meta property="og:site_name" content="([^"]+)"/);
                    const imageMatch = html.match(/<meta property="og:image" content="([^"]+)"/);

                    let tralbumData = null;

                    let tralbumMatch = html.match(/var TralbumData\s*=\s*({[\s\S]*?});/);
                    if (tralbumMatch) {
                        try {
                            tralbumData = JSON.parse(tralbumMatch[1]);
                        } catch (e) {
                            console.error('Failed to parse TralbumData pattern 1:', e);
                        }
                    }

                    if (!tralbumData) {
                        const dataMatch = html.match(/data-tralbum="([^"]+)"/);
                        if (dataMatch) {
                            try {
                                const decoded = dataMatch[1].replace(/&quot;/g, '"').replace(/&amp;/g, '&');
                                tralbumData = JSON.parse(decoded);
                            } catch (e) {
                                console.error('Failed to parse data-tralbum:', e);
                            }
                        }
                    }

                    if (!tralbumData || !tralbumData.trackinfo) {
                        setSearch(s => ({ ...s, error: 'Could not find track data. This might not be a valid Bandcamp album URL.', loadingSongs: false }));
                        return;
                    }

                    const tracks = tralbumData.trackinfo || [];

                    if (tracks.length === 0) {
                        setSearch(s => ({ ...s, error: 'No tracks found on this album.', loadingSongs: false }));
                        return;
                    }

                    const validTracks = tracks.filter(track => track.title);

                    if (validTracks.length === 0) {
                        setSearch(s => ({ ...s, error: 'No valid tracks found.', loadingSongs: false }));
                        return;
                    }

                    const uniqueTracks = validTracks.map((track) => ({
                        name: track.title,
                        artwork: imageMatch ? imageMatch[1] : null,
                        albumName: titleMatch ? titleMatch[1] : 'Unknown Album',
                        color: '#ff0080',
                        previewUrl: track.file?.['mp3-128'] || null
                    }));

                    const shuffledIndices = shuffleArray(uniqueTracks.map((_, idx) => idx));

                    setState(s => ({
                        ...s,
                        selectedArtist: {
                            collectionName: titleMatch ? titleMatch[1] : 'Unknown Album',
                            artistName: artistMatch ? artistMatch[1] : 'Unknown Artist',
                            bandcampUrl: url,
                            source: 'bandcamp'
                        },
                        songData: uniqueTracks,
                        songs: uniqueTracks.map(t => t.name),
                        usedAlbums: [{
                            name: titleMatch ? titleMatch[1] : 'Unknown Album',
                            artist: artistMatch ? artistMatch[1] : 'Unknown Artist'
                        }],
                        stage: 'sorting'
                    }));

                    const totalComparisons = (uniqueTracks.length * (uniqueTracks.length - 1)) / 2;
                    setSorting({
                        sortedIndices: shuffledIndices,
                        i: 0,
                        j: 0,
                        comparisons: 0,
                        autoSkipped: 0,
                        preferences: {},
                        history: [],
                        skippedPairs: new Set(),
                        winCounts: {},
                        lossCounts: {},
                        lastEstimateUpdate: 0,
                        estimatedRemaining: totalComparisons,
                        notificationShownFor: new Set(),
                        pinnedTop: new Set(),
                        pinnedBottom: new Set()
                    });

                    setSearch(s => ({ ...s, loadingSongs: false }));
                } catch (err) {
                    console.error('Bandcamp error:', err);
                    setSearch(s => ({ ...s, error: 'Failed to load album. Please check the URL and try again. Make sure it\'s a direct album URL.', loadingSongs: false }));
                }
            };

            const searchArtistOrAlbum = async () => {
                const searchValue = state.mode === 'artist' ? search.artistName.trim() : search.albumName.trim();

                if (state.mode === 'artist' && !searchValue) {
                    setSearch(s => ({ ...s, error: 'Please enter an artist name' }));
                    return;
                }
                if (state.mode === 'album' && !searchValue) {
                    setSearch(s => ({ ...s, error: 'Please enter an album name' }));
                    return;
                }

                if (isBandcampUrl(searchValue)) {
                    if (state.mode === 'artist') {
                        await handleBandcampArtist(searchValue);
                    } else {
                        await handleBandcampAlbum(searchValue);
                    }
                    return;
                }

                setSearch(s => ({ ...s, loading: true, error: '', suggestions: [], page: 0 }));

                try {
                    if (state.mode === 'artist') {
                        const searchData = await jsonpRequest(
                            `https://itunes.apple.com/search?term=${encodeURIComponent(search.artistName)}&entity=musicArtist&limit=50`
                        );

                        if (!searchData.results || searchData.results.length === 0) {
                            setSearch(s => ({ ...s, error: 'Artist not found. Try a different name.', loading: false }));
                            return;
                        }

                        const artists = searchData.results
                            .filter(item => item.wrapperType === 'artist')
                            .reduce((acc, artist) => {
                                if (!acc.find(a => a.artistName.toLowerCase() === artist.artistName.toLowerCase())) {
                                    acc.push(artist);
                                }
                                return acc;
                            }, []);

                        setSearch(s => ({ ...s, suggestions: artists.map(a => ({ ...a, type: 'artist' })), loading: false }));
                    } else {
                        let allResults = [];

                        try {
                            const searchData1 = await jsonpRequest(
                                `https://itunes.apple.com/search?term=${encodeURIComponent(search.albumName)}&entity=album&limit=200`
                            );
                            if (searchData1.results) {
                                allResults.push(...searchData1.results);
                            }
                        } catch (e) {
                            console.error('Strategy 1 failed:', e);
                        }

                        if (search.albumArtist.trim()) {
                            try {
                                const artistSearch = await jsonpRequest(
                                    `https://itunes.apple.com/search?term=${encodeURIComponent(search.albumArtist)}&entity=musicArtist&limit=10`
                                );

                                if (artistSearch.results && artistSearch.results.length > 0) {
                                    const artist = artistSearch.results.find(a => a.wrapperType === 'artist');
                                    if (artist) {
                                        const albumsData = await jsonpRequest(
                                            `https://itunes.apple.com/lookup?id=${artist.artistId}&entity=album&limit=200`
                                        );
                                        if (albumsData.results) {
                                            allResults.push(...albumsData.results.slice(1));
                                        }
                                    }
                                }
                            } catch (e) {
                                console.error('Strategy 2 failed:', e);
                            }

                            try {
                                const searchData2 = await jsonpRequest(
                                    `https://itunes.apple.com/search?term=${encodeURIComponent(search.albumName + ' ' + search.albumArtist)}&entity=album&limit=200`
                                );
                                if (searchData2.results) {
                                    allResults.push(...searchData2.results);
                                }
                            } catch (e) {
                                console.error('Strategy 3 failed:', e);
                            }
                        }

                        if (allResults.length === 0) {
                            setSearch(s => ({ ...s, error: 'Album not found. Try different search terms or check the artist name.', loading: false }));
                            return;
                        }

                        let filteredAlbums = allResults.filter(item => item.wrapperType === 'collection');

                        const normalizeText = (text) => text.toLowerCase().replace(/[^\w\s]/g, '').replace(/\s+/g, ' ').trim();
                        const albumLower = search.albumName.toLowerCase().trim();
                        const normalizedQuery = normalizeText(search.albumName);
                        const artistQueryNorm = search.albumArtist.trim() ? normalizeText(search.albumArtist) : null;

                        filteredAlbums = filteredAlbums
                            .map(album => {
                                let score = 0;
                                const albumNameLower = album.collectionName.toLowerCase();
                                const normalizedAlbumName = normalizeText(album.collectionName);
                                const normalizedAlbumArtist = normalizeText(album.artistName || '');

                                // Album name matching
                                if (albumNameLower === albumLower || normalizedAlbumName === normalizedQuery) {
                                    score += 100;
                                } else if (albumNameLower.startsWith(albumLower) || normalizedAlbumName.startsWith(normalizedQuery)) {
                                    score += 50;
                                } else if (albumNameLower.includes(albumLower) || normalizedAlbumName.includes(normalizedQuery)) {
                                    score += 25;
                                }

                                const queryWords = normalizedQuery.split(/\s+/).filter(w => w.length > 2);
                                const albumWords = normalizedAlbumName.split(/\s+/);
                                const matchingWords = queryWords.filter(word =>
                                    albumWords.some(albumWord => albumWord.includes(word) || word.includes(albumWord))
                                );
                                score += matchingWords.length * 5;

                                // Artist matching â heavily weighted when artist was provided
                                if (artistQueryNorm) {
                                    if (normalizedAlbumArtist === artistQueryNorm) {
                                        score += 200; // exact artist match is the strongest signal
                                    } else if (normalizedAlbumArtist.includes(artistQueryNorm) || artistQueryNorm.includes(normalizedAlbumArtist)) {
                                        score += 80;
                                    } else {
                                        // Partial word overlap
                                        const artistQueryWords = artistQueryNorm.split(/\s+/).filter(w => w.length > 1);
                                        const artistAlbumWords = normalizedAlbumArtist.split(/\s+/);
                                        const artistWordMatches = artistQueryWords.filter(w => artistAlbumWords.includes(w)).length;
                                        score += artistWordMatches * 30;
                                        // Penalise non-matching artists when artist was specified
                                        if (artistWordMatches === 0) score -= 50;
                                    }
                                }

                                // Prefer albums with higher track counts (more likely to be the real release)
                                if (album.trackCount) score += Math.min(album.trackCount, 20);

                                return { ...album, matchScore: score };
                            })
                            .filter(album => album.matchScore > 0)
                            .sort((a, b) => b.matchScore - a.matchScore);

                        if (search.albumYear.trim()) {
                            const year = parseInt(search.albumYear);
                            if (!isNaN(year)) {
                                filteredAlbums = filteredAlbums.filter(album => {
                                    if (album.releaseDate) {
                                        return new Date(album.releaseDate).getFullYear() === year;
                                    }
                                    return false;
                                });
                            }
                        }

                        const uniqueAlbums = [];
                        const seenAlbums = new Set();
                        for (const album of filteredAlbums) {
                            const key = `${normalizeText(album.collectionName)}-${normalizeText(album.artistName)}`;
                            if (!seenAlbums.has(key)) {
                                seenAlbums.add(key);
                                uniqueAlbums.push(album);
                            }
                        }

                        if (uniqueAlbums.length === 0) {
                            setSearch(s => ({ ...s, error: 'No albums found matching your criteria. Try removing filters or using different search terms.', loading: false }));
                            return;
                        }

                        setSearch(s => ({ ...s, suggestions: uniqueAlbums.map(a => ({ ...a, type: 'album' })), loading: false }));
                    }
                } catch (err) {
                    setSearch(s => ({ ...s, error: 'Failed to fetch data. Please try again.', loading: false }));
                }
            };

            const selectArtistForAlbums = async (artist) => {
                setSearch(s => ({ ...s, loadingSongs: true, error: '' }));

                try {
                    const albumsData = await jsonpRequest(
                        `https://itunes.apple.com/lookup?id=${artist.artistId}&entity=album&limit=200`
                    );

                    if (!albumsData.results || albumsData.results.length <= 1) {
                        setSearch(s => ({ ...s, error: 'No albums found.', loadingSongs: false }));
                        return;
                    }

                    const artistAlbums = albumsData.results
                        .slice(1)
                        .filter(item => item.wrapperType === 'collection');

                    setState(s => ({ ...s, selectedArtist: artist, albums: artistAlbums, stage: 'selectAlbums' }));
                    setSearch(s => ({ ...s, loadingSongs: false }));
                } catch (err) {
                    setSearch(s => ({ ...s, error: 'Failed to fetch albums.', loadingSongs: false }));
                }
            };

            const selectSingleAlbum = async (item) => {
                setSearch(s => ({ ...s, loadingSongs: true, error: '' }));

                try {
                    const songsData = await jsonpRequest(
                        `https://itunes.apple.com/lookup?id=${item.collectionId}&entity=song&limit=200`
                    );

                    if (!songsData.results || songsData.results.length <= 1) {
                        setSearch(s => ({ ...s, error: 'No songs found.', loadingSongs: false }));
                        return;
                    }

                    const tracks = songsData.results
                        .slice(1)
                        .filter(item => item.wrapperType === 'track' && item.kind === 'song');

                    const uniqueTracks = await processTracksToUniqueSongs(tracks);
                    const shuffledIndices = shuffleArray(uniqueTracks.map((_, idx) => idx));

                    setState(s => ({
                        ...s,
                        selectedArtist: item,
                        songData: uniqueTracks,
                        songs: uniqueTracks.map(t => t.name),
                        usedAlbums: [{ name: item.collectionName, artist: item.artistName }],
                        stage: 'sorting'
                    }));

                    const totalComparisons = (uniqueTracks.length * (uniqueTracks.length - 1)) / 2;
                    setSorting({
                        sortedIndices: shuffledIndices,
                        i: 0,
                        j: 0,
                        comparisons: 0,
                        autoSkipped: 0,
                        preferences: {},
                        history: [],
                        skippedPairs: new Set(),
                        winCounts: {},
                        lossCounts: {},
                        lastEstimateUpdate: 0,
                        estimatedRemaining: totalComparisons,
                        notificationShownFor: new Set(),
                        pinnedTop: new Set(),
                        pinnedBottom: new Set()
                    });

                    setSearch(s => ({ ...s, loadingSongs: false }));
                } catch (err) {
                    setSearch(s => ({ ...s, error: 'Failed to fetch songs.', loadingSongs: false }));
                }
            };

            const proceedWithSelectedAlbums = async () => {
                if (state.selectedAlbums.size === 0) {
                    setSearch(s => ({ ...s, error: 'Please select at least one album.' }));
                    return;
                }

                setSearch(s => ({ ...s, loadingSongs: true, error: '' }));

                try {
                    const allTracks = [];
                    const albumsList = [];

                    for (const albumId of state.selectedAlbums) {
                        const album = state.albums.find(a => a.collectionId === albumId);

                        if (album?.source === 'bandcamp') {
                            const proxyUrl = 'https://api.allorigins.win/raw?url=';
                            const response = await fetch(proxyUrl + encodeURIComponent(album.bandcampUrl));
                            const html = await response.text();
                            const tralbumMatch = html.match(/var TralbumData = ({[\s\S]*?});/);

                            if (tralbumMatch) {
                                const tralbumData = JSON.parse(tralbumMatch[1]);
                                const tracks = tralbumData.trackinfo || [];

                                albumsList.push({
                                    name: album.collectionName,
                                    artist: album.artistName
                                });

                                tracks.forEach(track => {
                                    allTracks.push({
                                        trackName: track.title,
                                        artworkUrl100: album.artworkUrl100,
                                        collectionName: album.collectionName,
                                        previewUrl: track.file?.['mp3-128'] || null
                                    });
                                });
                            }
                        } else {
                            const songsData = await jsonpRequest(
                                `https://itunes.apple.com/lookup?id=${albumId}&entity=song&limit=200`
                            );

                            if (songsData.results && songsData.results.length > 1) {
                                const albumInfo = state.albums.find(a => a.collectionId === albumId);
                                if (albumInfo) {
                                    albumsList.push({
                                        name: albumInfo.collectionName,
                                        artist: albumInfo.artistName
                                    });
                                }

                                const tracks = songsData.results
                                    .slice(1)
                                    .filter(item => item.wrapperType === 'track' && item.kind === 'song');

                                allTracks.push(...tracks);
                            }
                        }
                    }

                    const uniqueTracks = await processTracksToUniqueSongs(allTracks);
                    const shuffledIndices = shuffleArray(uniqueTracks.map((_, idx) => idx));

                    setState(s => ({
                        ...s,
                        songData: uniqueTracks,
                        songs: uniqueTracks.map(t => t.name),
                        usedAlbums: albumsList,
                        stage: 'sorting'
                    }));

                    const totalComparisons = (uniqueTracks.length * (uniqueTracks.length - 1)) / 2;
                    setSorting({
                        sortedIndices: shuffledIndices,
                        i: 0,
                        j: 0,
                        comparisons: 0,
                        autoSkipped: 0,
                        preferences: {},
                        history: [],
                        skippedPairs: new Set(),
                        winCounts: {},
                        lossCounts: {},
                        lastEstimateUpdate: 0,
                        estimatedRemaining: totalComparisons,
                        notificationShownFor: new Set(),
                        pinnedTop: new Set(),
                        pinnedBottom: new Set()
                    });

                    setSearch(s => ({ ...s, loadingSongs: false }));
                } catch (err) {
                    setSearch(s => ({ ...s, error: 'Failed to fetch songs.', loadingSongs: false }));
                }
            };

            const getCurrentPosition = (songIdx) => {
                return sorting.sortedIndices.filter(idx => !state.excludedSongs.has(idx)).indexOf(songIdx);
            };

            const canMoveToBest = (songIdx) => {
                const position = getCurrentPosition(songIdx);
                const activeSongs = sorting.sortedIndices.filter(idx => !state.excludedSongs.has(idx));
                const topSection = activeSongs.slice(0, Math.ceil(activeSongs.length * 0.1));
                return !topSection.includes(songIdx);
            };

            const canMoveToWorst = (songIdx) => {
                const position = getCurrentPosition(songIdx);
                const activeSongs = sorting.sortedIndices.filter(idx => !state.excludedSongs.has(idx));
                const bottomSection = activeSongs.slice(-Math.ceil(activeSongs.length * 0.1));
                return !bottomSection.includes(songIdx);
            };

            const checkForNotification = (idx, type) => {
                const count = type === 'win' ? (sorting.winCounts[idx] || 0) : (sorting.lossCounts[idx] || 0);
                const notificationKey = `${idx}-${type}`;

                if (count === 10 && !sorting.notificationShownFor.has(notificationKey) && !notification) {
                    const currentPos = getCurrentPosition(idx);
                    const songName = state.songs[idx];
                    const totalActive = state.songs.length - state.excludedSongs.size;

                    if (type === 'win' && currentPos < totalActive * 0.2) {
                        return;
                    }
                    if (type === 'loss' && currentPos > totalActive * 0.8) {
                        return;
                    }

                    setSorting(s => ({
                        ...s,
                        notificationShownFor: new Set([...s.notificationShownFor, notificationKey])
                    }));

                    if (type === 'win') {
                        setNotification({
                            message: `"${songName}" is performing really well!`,
                            type: 'trending-up',
                            songIdx: idx
                        });
                    } else {
                        setNotification({
                            message: `"${songName}" seems to be struggling.`,
                            type: 'trending-down',
                            songIdx: idx
                        });
                    }
                }
            };

            const makeSmartAssumption = useCallback((idx1, idx2) => {
                const pairKey1 = `${idx1}-${idx2}`;
                const pairKey2 = `${idx2}-${idx1}`;

                if (sorting.skippedPairs.has(pairKey1) || sorting.skippedPairs.has(pairKey2)) {
                    return null;
                }

                if (sorting.pinnedTop.has(idx1) && !sorting.pinnedTop.has(idx2)) return 'song1';
                if (sorting.pinnedTop.has(idx2) && !sorting.pinnedTop.has(idx1)) return 'song2';
                if (sorting.pinnedBottom.has(idx1) && !sorting.pinnedBottom.has(idx2)) return 'song2';
                if (sorting.pinnedBottom.has(idx2) && !sorting.pinnedBottom.has(idx1)) return 'song1';

                for (let middle in sorting.preferences) {
                    const middleIdx = parseInt(middle);
                    if (sorting.preferences[idx1]?.[middleIdx] === 'win' && sorting.preferences[middleIdx]?.[idx2] === 'win') {
                        return 'song1';
                    }
                    if (sorting.preferences[idx2]?.[middleIdx] === 'win' && sorting.preferences[middleIdx]?.[idx1] === 'win') {
                        return 'song2';
                    }
                }
                if (sorting.preferences[idx1]?.[idx2] === 'win') return 'song1';
                if (sorting.preferences[idx2]?.[idx1] === 'win') return 'song2';
                return null;
            }, [sorting.preferences, sorting.skippedPairs, sorting.pinnedTop, sorting.pinnedBottom]);

            const updateEstimate = useCallback(() => {
                const activeSongs = state.songs.length - state.excludedSongs.size;
                const totalPossible = (activeSongs * (activeSongs - 1)) / 2;
                const made = sorting.comparisons;
                const skipped = sorting.autoSkipped;

                const remaining = Math.max(0, totalPossible - made - skipped);
                const estimatedSkipRate = made > 0 ? skipped / made : 0.3;
                const estimatedRemainingManual = Math.ceil(remaining * (1 - estimatedSkipRate));
                // Store estimated TOTAL (done + still to do), never less than comparisons already made
                const estimatedTotal = Math.max(made + 1, made + estimatedRemainingManual);

                setSorting(s => ({ ...s, estimatedRemaining: estimatedTotal, lastEstimateUpdate: made }));
            }, [state.songs.length, state.excludedSongs.size, sorting.comparisons, sorting.autoSkipped]);

            const moveToNextComparison = useCallback((indices, newI, newJ, newPrefs, newWinCounts, newLossCounts) => {
                let nextJ = newJ + 1;
                let nextI = newI;
                let autoSkipCount = 0;

                while (true) {
                    if (nextJ < state.songs.length - 1 - nextI) {
                        const idx1 = indices[nextJ];
                        const idx2 = indices[nextJ + 1];

                        if (state.excludedSongs.has(idx1) || state.excludedSongs.has(idx2)) {
                            nextJ++;
                            continue;
                        }

                        const assumption = makeSmartAssumption(idx1, idx2);
                        if (assumption) {
                            autoSkipCount++;
                            if (assumption === 'song2') {
                                [indices[nextJ], indices[nextJ + 1]] = [indices[nextJ + 1], indices[nextJ]];
                            }
                            nextJ++;
                        } else {
                            setSorting(s => ({
                                ...s,
                                i: nextI,
                                j: nextJ,
                                sortedIndices: indices,
                                preferences: newPrefs,
                                winCounts: newWinCounts,
                                lossCounts: newLossCounts,
                                autoSkipped: s.autoSkipped + autoSkipCount
                            }));
                            return;
                        }
                    } else {
                        nextI++;
                        if (nextI < state.songs.length - 1) {
                            nextJ = 0;
                        } else {
                            setSorting(s => ({
                                ...s,
                                sortedIndices: indices,
                                preferences: newPrefs,
                                winCounts: newWinCounts,
                                lossCounts: newLossCounts,
                                autoSkipped: s.autoSkipped + autoSkipCount
                            }));
                            setState(s => ({ ...s, stage: 'results' }));
                            return;
                        }
                    }
                }
            }, [state.songs.length, state.excludedSongs, makeSmartAssumption]);

            const handlePreference = useCallback((preferred) => {
                if (playingAudio.audio) {
                    playingAudio.audio.pause();
                    setPlayingAudio({ index: null, audio: null });
                }

                const idx1 = sorting.sortedIndices[sorting.j];
                const idx2 = sorting.sortedIndices[sorting.j + 1];

                const historyEntry = {
                    sortedIndices: [...sorting.sortedIndices],
                    i: sorting.i,
                    j: sorting.j,
                    comparisons: sorting.comparisons,
                    preferences: JSON.parse(JSON.stringify(sorting.preferences)),
                    winCounts: { ...sorting.winCounts },
                    lossCounts: { ...sorting.lossCounts }
                };

                const newPreferences = { ...sorting.preferences };
                const newWinCounts = { ...sorting.winCounts };
                const newLossCounts = { ...sorting.lossCounts };

                if (preferred === 'song1') {
                    newPreferences[idx1] = { ...(newPreferences[idx1] || {}), [idx2]: 'win' };
                    newPreferences[idx2] = { ...(newPreferences[idx2] || {}), [idx1]: 'loss' };
                    newWinCounts[idx1] = (newWinCounts[idx1] || 0) + 1;
                    newLossCounts[idx2] = (newLossCounts[idx2] || 0) + 1;
                    checkForNotification(idx1, 'win');
                    checkForNotification(idx2, 'loss');
                } else {
                    newPreferences[idx2] = { ...(newPreferences[idx2] || {}), [idx1]: 'win' };
                    newPreferences[idx1] = { ...(newPreferences[idx1] || {}), [idx2]: 'loss' };
                    newWinCounts[idx2] = (newWinCounts[idx2] || 0) + 1;
                    newLossCounts[idx1] = (newLossCounts[idx1] || 0) + 1;
                    checkForNotification(idx2, 'win');
                    checkForNotification(idx1, 'loss');
                }

                const newIndices = [...sorting.sortedIndices];
                if (preferred === 'song2') {
                    [newIndices[sorting.j], newIndices[sorting.j + 1]] = [newIndices[sorting.j + 1], newIndices[sorting.j]];
                }

                const newComparisons = sorting.comparisons + 1;

                setSorting(s => ({
                    ...s,
                    comparisons: newComparisons,
                    history: [...s.history, historyEntry]
                }));

                if (newComparisons - sorting.lastEstimateUpdate >= 15) {
                    setTimeout(updateEstimate, 0);
                }

                moveToNextComparison(newIndices, sorting.i, sorting.j, newPreferences, newWinCounts, newLossCounts);
            }, [sorting, playingAudio.audio, moveToNextComparison, updateEstimate]);

            const handleUndo = () => {
                if (playingAudio.audio) {
                    playingAudio.audio.pause();
                    setPlayingAudio({ index: null, audio: null });
                }

                if (sorting.history.length === 0) return;

                const lastState = sorting.history[sorting.history.length - 1];
                setSorting({
                    ...sorting,
                    sortedIndices: lastState.sortedIndices,
                    i: lastState.i,
                    j: lastState.j,
                    comparisons: lastState.comparisons,
                    preferences: lastState.preferences,
                    winCounts: lastState.winCounts,
                    lossCounts: lastState.lossCounts,
                    history: sorting.history.slice(0, -1)
                });
            };

            const handleUnsure = () => {
                if (playingAudio.audio) {
                    playingAudio.audio.pause();
                    setPlayingAudio({ index: null, audio: null });
                }

                const idx1 = sorting.sortedIndices[sorting.j];
                const idx2 = sorting.sortedIndices[sorting.j + 1];
                const pairKey = `${idx1}-${idx2}`;
                const reversePairKey = `${idx2}-${idx1}`;

                const newSkippedPairs = new Set(sorting.skippedPairs);
                newSkippedPairs.add(pairKey);
                newSkippedPairs.add(reversePairKey);

                setSorting(s => {
                    let newJ = s.j + 1;
                    let newI = s.i;

                    if (newJ >= state.songs.length - 1 - s.i) {
                        newI = s.i + 1;
                        newJ = 0;
                        if (newI >= state.songs.length - 1) {
                            setState(st => ({ ...st, stage: 'results' }));
                        }
                    }

                    return { ...s, i: newI, j: newJ, skippedPairs: newSkippedPairs };
                });
            };

            const excludeSong = (songIdx) => {
                setModalConfig({
                    title: 'Exclude Song',
                    message: `Are you sure you want to exclude "${state.songs[songIdx]}" from your ranking?`,
                    onSubmit: () => {
                        setState(s => {
                            const newExcluded = new Set(s.excludedSongs);
                            newExcluded.add(songIdx);
                            return { ...s, excludedSongs: newExcluded };
                        });

                        if (sorting.sortedIndices[sorting.j] === songIdx || sorting.sortedIndices[sorting.j + 1] === songIdx) {
                            setSorting(s => {
                                let newJ = s.j + 1;
                                let newI = s.i;

                                if (newJ >= state.songs.length - 1 - s.i) {
                                    newI = s.i + 1;
                                    newJ = 0;
                                    if (newI >= state.songs.length - 1) {
                                        setState(st => ({ ...st, stage: 'results' }));
                                    }
                                }

                                return { ...s, i: newI, j: newJ };
                            });
                        }
                    }
                });
                setModalOpen(true);
            };

            const handleRightClick = (e, songIndex) => {
                e.preventDefault();

                const songIdx = sorting.sortedIndices[songIndex];
                const canBest = canMoveToBest(songIdx);
                const canWorst = canMoveToWorst(songIdx);

                setContextMenu({
                    x: e.clientX,
                    y: e.clientY,
                    songIndex,
                    canMoveBest: canBest,
                    canMoveWorst: canWorst
                });
            };

            const markAsBest = (songIdx) => {
                setSorting(s => ({
                    ...s,
                    pinnedTop: new Set([...s.pinnedTop, songIdx])
                }));

                const pinnedTopSongs = sorting.sortedIndices.filter(idx =>
                    sorting.pinnedTop.has(idx) || idx === songIdx
                );
                const otherSongs = sorting.sortedIndices.filter(idx =>
                    !sorting.pinnedTop.has(idx) && idx !== songIdx
                );

                const newIndices = [...pinnedTopSongs, ...otherSongs];
                setSorting(s => ({ ...s, sortedIndices: newIndices }));
                setContextMenu(null);
            };

            const markAsWorst = (songIdx) => {
                setSorting(s => ({
                    ...s,
                    pinnedBottom: new Set([...s.pinnedBottom, songIdx])
                }));

                const pinnedBottomSongs = sorting.sortedIndices.filter(idx =>
                    sorting.pinnedBottom.has(idx) || idx === songIdx
                );
                const otherSongs = sorting.sortedIndices.filter(idx =>
                    !sorting.pinnedBottom.has(idx) && idx !== songIdx
                );

                const newIndices = [...otherSongs, ...pinnedBottomSongs];
                setSorting(s => ({ ...s, sortedIndices: newIndices }));
                setContextMenu(null);
            };

            const moveToTop = (songIdx) => {
                markAsBest(songIdx);
            };

            const moveToBottom = (songIdx) => {
                markAsWorst(songIdx);
            };

            const loadFromAutoSave = (autosave) => {
                try {
                    const selectedAlbumsSet = new Set(autosave.state.selectedAlbums || []);
                    const excludedSongsSet = new Set(autosave.state.excludedSongs || []);
                    const skippedPairsSet = new Set(autosave.sorting.skippedPairs || []);
                    const notificationShownForSet = new Set(autosave.sorting.notificationShownFor || []);
                    const pinnedTopSet = new Set(autosave.sorting.pinnedTop || []);
                    const pinnedBottomSet = new Set(autosave.sorting.pinnedBottom || []);

                    // Restore the sessionId so future saves overwrite this entry
                    sessionIdRef.current = autosave.sessionId || autosave.id || null;

                    setState({
                        ...autosave.state,
                        selectedAlbums: selectedAlbumsSet,
                        excludedSongs: excludedSongsSet
                    });

                    setSorting({
                        ...autosave.sorting,
                        history: [],
                        skippedPairs: skippedPairsSet,
                        notificationShownFor: notificationShownForSet,
                        pinnedTop: pinnedTopSet,
                        pinnedBottom: pinnedBottomSet
                    });

                    if (autosave.search) {
                        setSearch(s => ({
                            ...s,
                            artistName: autosave.search.artistName || '',
                            albumName: autosave.search.albumName || '',
                            albumArtist: autosave.search.albumArtist || '',
                            albumYear: autosave.search.albumYear || '',
                            suggestions: [],
                            loading: false,
                            loadingSongs: false,
                            error: ''
                        }));
                    }
                } catch (err) {
                    console.error('Failed to load autosave:', err);
                }
            };

            const removeAutoSave = (id) => {
                deleteAutoSave(id);
                setAutoSaves(loadAutoSaves());
            };

            const saveData = () => {
                const dataToSave = {
                    state: {
                        ...state,
                        selectedAlbums: Array.from(state.selectedAlbums),
                        excludedSongs: Array.from(state.excludedSongs)
                    },
                    sorting: {
                        ...sorting,
                        history: [],
                        skippedPairs: Array.from(sorting.skippedPairs),
                        notificationShownFor: Array.from(sorting.notificationShownFor),
                        pinnedTop: Array.from(sorting.pinnedTop),
                        pinnedBottom: Array.from(sorting.pinnedBottom)
                    },
                    search: {
                        artistName: search.artistName,
                        albumName: search.albumName,
                        albumArtist: search.albumArtist,
                        albumYear: search.albumYear
                    }
                };

                const dataStr = JSON.stringify(dataToSave, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                const artistName = state.selectedArtist?.artistName || state.selectedArtist?.collectionName || 'unknown';
                link.download = `ranker-${artistName.replace(/[^a-z0-9]/gi, '-').toLowerCase()}-${Date.now()}.json`;
                link.click();
                URL.revokeObjectURL(url);
            };

            const loadData = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);

                        if (!data.state || !data.sorting) {
                            throw new Error('Invalid save file format');
                        }

                        const selectedAlbumsSet = new Set(data.state.selectedAlbums || []);
                        const excludedSongsSet = new Set(data.state.excludedSongs || []);
                        const skippedPairsSet = new Set(data.sorting.skippedPairs || []);
                        const notificationShownForSet = new Set(data.sorting.notificationShownFor || []);
                        const pinnedTopSet = new Set(data.sorting.pinnedTop || []);
                        const pinnedBottomSet = new Set(data.sorting.pinnedBottom || []);

                        setState({
                            ...data.state,
                            selectedAlbums: selectedAlbumsSet,
                            excludedSongs: excludedSongsSet
                        });

                        setSorting({
                            ...data.sorting,
                            history: [],
                            skippedPairs: skippedPairsSet,
                            notificationShownFor: notificationShownForSet,
                            pinnedTop: pinnedTopSet,
                            pinnedBottom: pinnedBottomSet
                        });

                        if (data.search) {
                            setSearch(s => ({
                                ...s,
                                artistName: data.search.artistName || '',
                                albumName: data.search.albumName || '',
                                albumArtist: data.search.albumArtist || '',
                                albumYear: data.search.albumYear || '',
                                suggestions: [],
                                loading: false,
                                loadingSongs: false,
                                error: ''
                            }));
                        }

                        event.target.value = '';

                    } catch (err) {
                        console.error('Load error:', err);
                        setSearch(s => ({
                            ...s,
                            error: 'Failed to load save file. Please make sure it\'s a valid Ranker save file.'
                        }));
                        event.target.value = '';
                    }
                };
                reader.onerror = () => {
                    setSearch(s => ({ ...s, error: 'Failed to read file.' }));
                    event.target.value = '';
                };
                reader.readAsText(file);
            };

            const exportToPDF = () => {
                setModalConfig({
                    title: 'Export to PDF',
                    fields: [
                        { name: 'fileName', label: 'File name', placeholder: 'my-ranking', required: true },
                        { name: 'userName', label: 'Your name', placeholder: 'Your Name', required: true }
                    ],
                    onSubmit: (values) => {
                        const { jsPDF } = window.jspdf;
                        const doc = new jsPDF();

                        // Derive colors from top-ranked songs' artwork
                        const filteredIndices = sorting.sortedIndices.filter(idx => !state.excludedSongs.has(idx));
                        const parseColor = (colorStr) => {
                            const m = (colorStr || '').match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                            if (m) return [parseInt(m[1]), parseInt(m[2]), parseInt(m[3])];
                            if (colorStr && colorStr.startsWith('#')) {
                                const hex = colorStr.slice(1);
                                return [parseInt(hex.slice(0,2),16), parseInt(hex.slice(2,4),16), parseInt(hex.slice(4,6),16)];
                            }
                            return null;
                        };
                        const col1Raw = state.songData[filteredIndices[0]]?.color || '#ff0080';
                        const col2Raw = state.songData[filteredIndices[1]]?.color || state.songData[filteredIndices[0]]?.color || '#7928ca';
                        const col1 = parseColor(col1Raw) || [255, 0, 128];
                        const col2 = parseColor(col2Raw) || [121, 40, 202];

                        // Header bar with gradient (jsPDF doesn't natively support gradients, simulate with blended fill)
                        const steps = 20;
                        const headerH = 32;
                        for (let i = 0; i < steps; i++) {
                            const t = i / (steps - 1);
                            const r = Math.round(col1[0] + (col2[0] - col1[0]) * t);
                            const g = Math.round(col1[1] + (col2[1] - col1[1]) * t);
                            const b = Math.round(col1[2] + (col2[2] - col1[2]) * t);
                            doc.setFillColor(r, g, b);
                            doc.rect(i * (210 / steps), 0, 210 / steps + 1, headerH, 'F');
                        }

                        doc.setTextColor(255, 255, 255);
                        doc.setFontSize(20);
                        doc.text(`${values.userName}'s Song Rankings`, 105, 13, { align: 'center' });
                        doc.setFontSize(11);
                        doc.text(`${state.selectedArtist?.artistName || state.selectedArtist?.collectionName}`, 105, 21, { align: 'center' });
                        doc.setFontSize(8);
                        doc.setTextColor(255, 255, 255);
                        doc.text('\u03BCsic tools \u00B7 ranker', 105, 28, { align: 'center' });

                        doc.setTextColor(0, 0, 0);
                        let yPos = 42;

                        if (state.usedAlbums.length > 0) {
                            doc.setFontSize(14);
                            doc.setFont(undefined, 'bold');
                            doc.text('Albums:', 20, yPos);
                            yPos += 7;
                            doc.setFontSize(10);
                            doc.setFont(undefined, 'normal');
                            state.usedAlbums.forEach(album => {
                                if (yPos > 270) {
                                    doc.addPage();
                                    yPos = 20;
                                }
                                doc.text(`\u2022 ${album.name}`, 25, yPos);
                                yPos += 5;
                            });
                            yPos += 5;
                        }

                        doc.setFontSize(14);
                        doc.setFont(undefined, 'bold');
                        doc.text('Rankings:', 20, yPos);
                        yPos += 8;

                        doc.setFillColor(200, 200, 200);
                        doc.rect(20, yPos - 5, 170, 8, 'F');
                        doc.setFontSize(10);
                        doc.text('Rank', 25, yPos);
                        doc.text('Song Title', 50, yPos);
                        yPos += 10;

                        doc.setFont(undefined, 'normal');
                        filteredIndices.forEach((songIdx, rank) => {
                            if (yPos > 270) {
                                doc.addPage();
                                yPos = 20;
                            }

                            if (rank % 2 === 0) {
                                doc.setFillColor(245, 245, 245);
                                doc.rect(20, yPos - 5, 170, 8, 'F');
                            }

                            doc.setFontSize(10);
                            doc.text(`${rank + 1}`, 25, yPos);

                            const songName = state.songs[songIdx];
                            const maxWidth = 130;
                            const lines = doc.splitTextToSize(songName, maxWidth);
                            doc.text(lines, 50, yPos);

                            yPos += Math.max(8, lines.length * 5);
                        });

                        // Footer on every page with gradient
                        const pageCount = doc.internal.getNumberOfPages();
                        for (let p = 1; p <= pageCount; p++) {
                            doc.setPage(p);
                            for (let i = 0; i < steps; i++) {
                                const t = i / (steps - 1);
                                const r = Math.round(col1[0] + (col2[0] - col1[0]) * t);
                                const g = Math.round(col1[1] + (col2[1] - col1[1]) * t);
                                const b = Math.round(col1[2] + (col2[2] - col1[2]) * t);
                                doc.setFillColor(r, g, b);
                                doc.rect(i * (210 / steps), 287, 210 / steps + 1, 10, 'F');
                            }
                            doc.setFontSize(7);
                            doc.setTextColor(255, 255, 255);
                            doc.text('\u03BCsic tools \u00B7 ranker', 105, 293, { align: 'center' });
                        }

                        doc.save(`${values.fileName}.pdf`);
                    }
                });
                setModalOpen(true);
            };

            const exportToTXT = () => {
                const artistName = state.selectedArtist?.artistName || state.selectedArtist?.collectionName || 'Unknown';
                const filteredIndices = sorting.sortedIndices.filter(idx => !state.excludedSongs.has(idx));
                let txt = `Î¼sic tools Â· ranker\n`;
                txt += `${'â'.repeat(40)}\n`;
                txt += `${artistName} â Song Rankings\n`;
                txt += `Generated: ${new Date().toLocaleString()}\n`;
                if (state.usedAlbums && state.usedAlbums.length > 0) {
                    txt += `Albums: ${state.usedAlbums.map(a => a.name).join(', ')}\n`;
                }
                txt += `${'â'.repeat(40)}\n\n`;
                filteredIndices.forEach((songIdx, rank) => {
                    txt += `${String(rank + 1).padStart(3, ' ')}. ${state.songs[songIdx]}\n`;
                });
                txt += `\n${'â'.repeat(40)}\n`;
                txt += `Î¼sic tools Â· ranker\n`;
                const blob = new Blob([txt], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${artistName.replace(/[^a-z0-9]/gi, '-').toLowerCase()}-ranking.txt`;
                link.click();
                URL.revokeObjectURL(url);
            };

            const exportToPNG = async () => {
                const artistName = state.selectedArtist?.artistName || state.selectedArtist?.collectionName || 'Rankings';
                const filteredIndices = sorting.sortedIndices.filter(idx => !state.excludedSongs.has(idx));

                // Derive gradient colors from top-ranked songs' artwork
                const parseColor = (colorStr) => {
                    const m = (colorStr || '').match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                    if (m) return [parseInt(m[1]), parseInt(m[2]), parseInt(m[3])];
                    if (colorStr && colorStr.startsWith('#')) {
                        const hex = colorStr.slice(1);
                        return [parseInt(hex.slice(0,2),16), parseInt(hex.slice(2,4),16), parseInt(hex.slice(4,6),16)];
                    }
                    return null;
                };
                const col1Raw = state.songData[filteredIndices[0]]?.color || '#ff0080';
                const col2Raw = state.songData[filteredIndices[1]]?.color || state.songData[filteredIndices[0]]?.color || '#7928ca';
                const col1 = parseColor(col1Raw) || [255, 0, 128];
                const col2 = parseColor(col2Raw) || [121, 40, 202];
                const toHex = ([r,g,b]) => `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
                const darken = ([r,g,b], f) => [Math.round(r*f), Math.round(g*f), Math.round(b*f)];

                // Build an off-screen canvas directly
                const canvas = document.createElement('canvas');
                const padding = 40;
                const rowH = 44;
                const headerH = 100;
                const width = 600;
                const totalH = headerH + filteredIndices.length * rowH + padding * 2;
                canvas.width = width;
                canvas.height = totalH;
                const ctx = canvas.getContext('2d');

                // Background gradient using darkened art colors
                const grad = ctx.createLinearGradient(0, 0, width, totalH);
                grad.addColorStop(0, toHex(darken(col1, 0.15)));
                grad.addColorStop(1, toHex(darken(col2, 0.12)));
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, width, totalH);

                // Header bar gradient from art colors
                const headerGrad = ctx.createLinearGradient(0, 0, width, 0);
                headerGrad.addColorStop(0, toHex(col1));
                headerGrad.addColorStop(1, toHex(col2));
                ctx.fillStyle = headerGrad;
                ctx.fillRect(0, 0, width, headerH);

                // Header text
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 26px system-ui, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`${artistName} Rankings`, width / 2, 38);
                ctx.font = '14px system-ui, sans-serif';
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.fillText(`${filteredIndices.length} songs â¢ ${new Date().toLocaleDateString()}`, width / 2, 62);
                ctx.font = '11px system-ui, sans-serif';
                ctx.fillStyle = 'rgba(255,255,255,0.55)';
                ctx.fillText('Î¼sic tools Â· ranker', width / 2, 84);

                // Song rows
                filteredIndices.forEach((songIdx, rank) => {
                    const y = headerH + padding + rank * rowH;
                    const isEven = rank % 2 === 0;
                    ctx.fillStyle = isEven ? 'rgba(255,255,255,0.06)' : 'rgba(255,255,255,0.03)';
                    ctx.beginPath();
                    ctx.roundRect(padding / 2, y, width - padding, rowH - 4, 8);
                    ctx.fill();

                    // Rank number â accent color for top 3
                    ctx.fillStyle = rank < 3 ? toHex(col1) : 'rgba(255,255,255,0.4)';
                    ctx.font = `bold 16px system-ui, sans-serif`;
                    ctx.textAlign = 'right';
                    ctx.fillText(`#${rank + 1}`, padding + 36, y + rowH / 2 + 6);

                    // Song name
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${rank < 3 ? 'bold' : 'normal'} 15px system-ui, sans-serif`;
                    ctx.textAlign = 'left';
                    const songName = state.songs[songIdx];
                    const maxWidth = width - padding - 80;
                    let displayName = songName;
                    while (ctx.measureText(displayName).width > maxWidth && displayName.length > 0) {
                        displayName = displayName.slice(0, -1);
                    }
                    if (displayName !== songName) displayName += 'â¦';
                    ctx.fillText(displayName, padding + 48, y + rowH / 2 + 6);
                });

                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `${artistName.replace(/[^a-z0-9]/gi, '-').toLowerCase()}-ranking.png`;
                    link.click();
                    URL.revokeObjectURL(url);
                }, 'image/png');
            };

            const handleTryAnother = () => {
                // Save final results before resetting, using existing sessionId to overwrite
                const finalSave = {
                    sessionId: sessionIdRef.current,
                    state: {
                        ...state,
                        selectedAlbums: Array.from(state.selectedAlbums),
                        excludedSongs: Array.from(state.excludedSongs)
                    },
                    sorting: {
                        ...sorting,
                        history: [],
                        skippedPairs: Array.from(sorting.skippedPairs),
                        notificationShownFor: Array.from(sorting.notificationShownFor),
                        pinnedTop: Array.from(sorting.pinnedTop),
                        pinnedBottom: Array.from(sorting.pinnedBottom)
                    },
                    search: { artistName: search.artistName, albumName: search.albumName, albumArtist: search.albumArtist, albumYear: search.albumYear }
                };
                saveAutoSave(finalSave);

                // Clear session ID so next ranking gets a fresh one
                sessionIdRef.current = null;

                // Reset to home
                setState({
                    stage: 'selectMode', mode: null, songs: [], songData: {}, albums: [], selectedAlbums: new Set(),
                    selectedArtist: null, usedAlbums: [], excludedSongs: new Set()
                });
                setSorting({
                    sortedIndices: [], j: 0, comparisons: 0, autoSkipped: 0, estimatedRemaining: 0,
                    history: [], skippedPairs: new Set(), notificationShownFor: new Set(), pinnedTop: new Set(), pinnedBottom: new Set()
                });
                setSearch({ artistName: '', albumName: '', albumArtist: '', albumYear: '', suggestions: [], page: 0, loading: false, loadingSongs: false, error: '' });
                setAutoSaves(loadAutoSaves());
            };

            const exportToTierlist = () => {
                // Build ordered list of songs (excluding excluded)
                const filteredIndices = sorting.sortedIndices.filter(idx => !state.excludedSongs.has(idx));
                const total = filteredIndices.length;
                if (total === 0) return;

                // Tier boundary percentiles: S top ~14%, A next ~14%, B, C, D, E, F bottom
                const tierNames = ['S', 'A', 'B', 'C', 'D', 'E', 'F'];
                const tierColors = { S:'#ff7f7f', A:'#ffbf7f', B:'#ffdf7f', C:'#ffff7f', D:'#bfff7f', E:'#7fff7f', F:'#7fbfff' };

                // Assign each song a tier based on its rank percentage
                const tierBuckets = { S:[], A:[], B:[], C:[], D:[], E:[], F:[], unranked:[] };

                filteredIndices.forEach((songIdx, rank) => {
                    const pct = rank / total; // 0 = best, 1 = worst
                    let tier;
                    if (pct < 1/7)      tier = 'S';
                    else if (pct < 2/7) tier = 'A';
                    else if (pct < 3/7) tier = 'B';
                    else if (pct < 4/7) tier = 'C';
                    else if (pct < 5/7) tier = 'D';
                    else if (pct < 6/7) tier = 'E';
                    else                tier = 'F';

                    const songData = state.songData[songIdx] || {};
                    const songName = state.songs[songIdx];

                    // Build item in tierlist format
                    const item = {
                        id: `ranker-import-${songIdx}-${Date.now()}-${Math.random()}`,
                        title: songName,
                        artist: state.selectedArtist?.artistName || state.selectedArtist?.collectionName || '',
                        image: songData.artwork || '',
                        albumTitle: songData.albumName || '',
                        trackNumber: songData.trackNumber || null,
                        collectionId: songData.collectionId || null
                    };

                    tierBuckets[tier].push(item);
                });

                // Load existing tierlist data from localStorage to preserve it
                let existingData = { charts: {}, currentChartId: null };
                try {
                    const saved = localStorage.getItem('tierListData');
                    if (saved) existingData = JSON.parse(saved);
                    // Migrate old format
                    if (!existingData.charts && existingData.tiers) {
                        const oldId = Date.now().toString() + '_old';
                        existingData = {
                            currentChartId: oldId,
                            charts: { [oldId]: { id: oldId, name: 'Previous List', ...existingData, lastModified: Date.now() } }
                        };
                    }
                } catch(e) {}

                const artistName = state.selectedArtist?.artistName || state.selectedArtist?.collectionName || 'Ranking';
                const newId = Date.now().toString();
                const newChart = {
                    id: newId,
                    name: `${artistName} (from Ranker)`,
                    tiers: tierBuckets,
                    tierNames: tierNames,
                    tierColors: tierColors,
                    title: `${artistName} â Song Tier List`,
                    songsMode: true,
                    albumBackup: null,
                    showReorderButtons: true,
                    lastModified: Date.now()
                };

                const updatedData = {
                    currentChartId: newId,
                    charts: { ...(existingData.charts || {}), [newId]: newChart }
                };

                try {
                    localStorage.setItem('tierListData', JSON.stringify(updatedData));
                } catch(e) {
                    console.error('Failed to save tierlist data:', e);
                }

                // Open tierlist in new tab
                window.open('tierlist.html', '_blank');
                setShowTierlistExport(false);
            };

            const activeSongCount = state.songs.length - state.excludedSongs.size;
            const totalComparisons = activeSongCount > 0 ? (activeSongCount * (activeSongCount - 1)) / 2 : 0;
            const progress = totalComparisons > 0 ? ((sorting.comparisons + sorting.autoSkipped) / totalComparisons) * 100 : 0;
            const itemsPerPage = 10;
            const paginatedSuggestions = search.suggestions.slice(search.page * itemsPerPage, (search.page + 1) * itemsPerPage);

            return (
                <div className="min-h-screen bg-black relative overflow-hidden">
                    <AnimatedBackground colors={bgColors} />

                    <div className="relative z-10">
                        <div className="flex justify-between items-center pt-8 px-8">
                            <a href="Âµsic.html" className="text-center hover:opacity-80 transition-opacity">
                                <h1 className="text-3xl font-bold text-white drop-shadow-lg">Î¼sic tools</h1>
                            </a>

                            <div className="flex gap-3">
                                {state.stage === 'selectMode' && (
                                    <button
                                        onClick={() => setShowUrlImport(true)}
                                        className="px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg border border-white/20 flex items-center gap-2"
                                    >
                                        <Link className="w-5 h-5" />
                                        Import URL
                                    </button>
                                )}
                                {(state.stage === 'selectMode' || state.stage === 'sorting') && (
                                    <label className="px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg border border-white/20 flex items-center gap-2 cursor-pointer">
                                        <Download className="w-5 h-5" />
                                        Load Save
                                        <input
                                            ref={state.stage === 'selectMode' ? fileInputRef : null}
                                            type="file"
                                            accept=".json"
                                            onChange={loadData}
                                            className="hidden"
                                        />
                                    </label>
                                )}
                                {state.stage === 'sorting' && (
                                    <div className="flex items-center gap-2">
                                        <button
                                            onClick={saveData}
                                            className="px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg border border-white/20 flex items-center gap-2"
                                        >
                                            <Save className="w-5 h-5" />
                                            Save Progress
                                        </button>
                                    </div>
                                )}
                            </div>
                        </div>

                        <div className={`p-8 max-w-4xl mx-auto ${state.stage === 'selectMode' && autoSaves.length === 0 ? 'min-h-[calc(100vh-80px)] flex flex-col justify-center' : ''}`}>
                            {state.stage === 'selectMode' && (
                                <>
                                    <div className="grid md:grid-cols-2 gap-6 mb-8">
                                        <button
                                            onClick={() => setState(s => ({ ...s, mode: 'artist', stage: 'search' }))}
                                            className="group bg-white/5 hover:bg-white/10 backdrop-blur-2xl rounded-3xl p-12 shadow-2xl border border-white/10 transition-all transform hover:scale-105"
                                        >
                                            <div className="flex flex-col items-center gap-6">
                                                <Music className="w-24 h-24 text-white group-hover:scale-110 transition-transform" />
                                                <h2 className="text-3xl font-bold text-white">Rank Artist</h2>
                                                <p className="text-gray-300 text-lg text-center">
                                                    Compare all songs from your favorite artist
                                                </p>
                                                <ChevronRight className="w-8 h-8 text-white/70 group-hover:text-white" />
                                            </div>
                                        </button>

                                        <button
                                            onClick={() => setState(s => ({ ...s, mode: 'album', stage: 'search' }))}
                                            className="group bg-white/5 hover:bg-white/10 backdrop-blur-2xl rounded-3xl p-12 shadow-2xl border border-white/10 transition-all transform hover:scale-105"
                                        >
                                            <div className="flex flex-col items-center gap-6">
                                                <Album className="w-24 h-24 text-white group-hover:scale-110 transition-transform" />
                                                <h2 className="text-3xl font-bold text-white">Rank Album</h2>
                                                <p className="text-gray-300 text-lg text-center">
                                                    Compare all tracks from a specific album
                                                </p>
                                                <ChevronRight className="w-8 h-8 text-white/70 group-hover:text-white" />
                                            </div>
                                        </button>
                                    </div>

                                    {autoSaves.length > 0 && (
                                        <div className="bg-white/5 backdrop-blur-2xl rounded-3xl shadow-2xl border border-white/10 overflow-hidden">
                                            <button
                                                onClick={() => setAutoSaveCollapsed(c => !c)}
                                                className="w-full flex items-center justify-between p-6 hover:bg-white/5 transition-colors"
                                            >
                                                <h3 className="text-xl font-bold text-white flex items-center gap-2">
                                                    <Clock className="w-5 h-5" />
                                                    Continue Recent Rankings
                                                    <span className="text-sm font-normal text-gray-400 ml-1">({autoSaves.length})</span>
                                                </h3>
                                                <div className="flex items-center gap-3">
                                                    <span
                                                        className="text-sm font-medium flex items-center gap-1 transition-all duration-500"
                                                        style={{
                                                            opacity: autoSaveStatus === 'saved' ? 1 : 0,
                                                            color: '#86efac'
                                                        }}
                                                    >
                                                        <Check className="w-4 h-4" />
                                                        Saved
                                                    </span>
                                                    <ChevronDown
                                                        className="w-5 h-5 text-gray-400 transition-transform duration-300"
                                                        style={{ transform: autoSaveCollapsed ? 'rotate(-90deg)' : 'rotate(0deg)' }}
                                                    />
                                                </div>
                                            </button>

                                            {!autoSaveCollapsed && (
                                                <div className="px-6 pb-6">
                                                    <div className="bg-blue-500/20 border border-blue-500/50 rounded-lg px-4 py-3 mb-4">
                                                        <p className="text-blue-200 text-sm flex items-start gap-2">
                                                            <AlertCircle className="w-5 h-5 flex-shrink-0 mt-0.5" />
                                                            <span>Sessions are auto-saved every 5 comparisons. For extra safety, use Save Progress to export a JSON file.</span>
                                                        </p>
                                                    </div>
                                                    <div className="space-y-3">
                                                        {autoSaves.map(autosave => {
                                                            const isCompleted = autosave.state.stage === 'results';
                                                            return (
                                                            <div key={autosave.id} className={`rounded-xl p-4 flex items-center gap-4 border ${isCompleted ? 'bg-white/5 border-white/10' : 'bg-white/10 border-white/20'}`}>
                                                                <div className="flex-1">
                                                                    <div className="flex items-center gap-2 flex-wrap">
                                                                        <p className="text-white font-semibold">
                                                                            {autosave.state.selectedArtist?.artistName || autosave.state.selectedArtist?.collectionName || 'Unknown'}
                                                                        </p>
                                                                        {isCompleted && (
                                                                            <span className="text-xs font-semibold px-2 py-0.5 rounded-full" style={{background: 'rgba(134,239,172,0.15)', color: '#86efac', border: '1px solid rgba(134,239,172,0.3)'}}>
                                                                                â Completed
                                                                            </span>
                                                                        )}
                                                                    </div>
                                                                    <p className="text-gray-300 text-sm mt-1">
                                                                        {autosave.sorting.comparisons} comparisons â¢ {autosave.state.songs?.length || 0} songs
                                                                    </p>
                                                                    <p className="text-gray-400 text-xs mt-1">
                                                                        {new Date(autosave.timestamp).toLocaleString()}
                                                                    </p>
                                                                </div>
                                                                <div className="flex gap-2">
                                                                    <button
                                                                        onClick={() => loadFromAutoSave(autosave)}
                                                                        className="px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg font-medium"
                                                                    >
                                                                        {isCompleted ? 'View' : 'Continue'}
                                                                    </button>
                                                                    <button
                                                                        onClick={() => removeAutoSave(autosave.id)}
                                                                        className="px-3 py-2 bg-red-500/20 hover:bg-red-500/30 text-red-300 rounded-lg"
                                                                    >
                                                                        <X className="w-5 h-5" />
                                                                    </button>
                                                                </div>
                                                            </div>
                                                            );
                                                        })}
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </>
                            )}

                            {state.stage === 'search' && (
                                <div className="bg-white/5 backdrop-blur-2xl rounded-3xl p-10 shadow-2xl border border-white/10 mt-8">
                                    <div className="flex items-center gap-3 mb-6">
                                        <button onClick={() => {
                                            setState(s => ({ ...s, stage: 'selectMode' }));
                                            setSearch({ artistName: '', albumName: '', albumArtist: '', albumYear: '', suggestions: [], page: 0, loading: false, loadingSongs: false, error: '' });
                                        }} className="p-2 hover:bg-white/10 rounded-lg transition-colors">
                                            <ArrowLeft className="w-6 h-6 text-white" />
                                        </button>
                                        <h2 className="text-2xl font-bold text-white">
                                            Search for {state.mode === 'artist' ? 'an artist' : 'an album'}
                                        </h2>
                                    </div>

                                    {state.mode === 'artist' ? (
                                        <div>
                                            <label className="block text-white text-lg font-medium mb-3">Artist name</label>
                                            <div className="flex gap-4">
                                                <input
                                                    type="text"
                                                    value={search.artistName}
                                                    onChange={(e) => setSearch(s => ({ ...s, artistName: e.target.value }))}
                                                    onKeyPress={(e) => e.key === 'Enter' && searchArtistOrAlbum()}
                                                    placeholder="The Beatles, Taylor Swift..."
                                                    className="flex-1 px-6 py-4 bg-white/10 border border-white/20 rounded-xl text-white text-lg placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50"
                                                    disabled={search.loading}
                                                />
                                                <button
                                                    onClick={searchArtistOrAlbum}
                                                    disabled={search.loading}
                                                    className="px-8 py-4 bg-white text-black hover:bg-gray-100 disabled:bg-gray-600 rounded-xl font-semibold flex items-center gap-3"
                                                >
                                                    {search.loading ? <Loader2 className="w-6 h-6" /> : <Search className="w-6 h-6" />}
                                                    {search.loading ? 'Searching...' : 'Search'}
                                                </button>
                                            </div>
                                        </div>
                                    ) : (
                                        <div className="space-y-4">
                                            <div>
                                                <label className="block text-white text-lg font-medium mb-3">Album name *</label>
                                                <input
                                                    type="text"
                                                    value={search.albumName}
                                                    onChange={(e) => setSearch(s => ({ ...s, albumName: e.target.value }))}
                                                    onKeyPress={(e) => e.key === 'Enter' && searchArtistOrAlbum()}
                                                    placeholder="Abbey Road..."
                                                    className="w-full px-6 py-4 bg-white/10 border border-white/20 rounded-xl text-white text-lg placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50"
                                                />
                                            </div>
                                            <div>
                                                <label className="block text-white text-lg font-medium mb-3">Artist (optional but recommended)</label>
                                                <input
                                                    type="text"
                                                    value={search.albumArtist}
                                                    onChange={(e) => setSearch(s => ({ ...s, albumArtist: e.target.value }))}
                                                    onKeyPress={(e) => e.key === 'Enter' && searchArtistOrAlbum()}
                                                    placeholder="The Beatles..."
                                                    className="w-full px-6 py-4 bg-white/10 border border-white/20 rounded-xl text-white text-lg placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50"
                                                />
                                            </div>
                                            <div>
                                                <label className="block text-white text-lg font-medium mb-3">Year (optional)</label>
                                                <input
                                                    type="text"
                                                    value={search.albumYear}
                                                    onChange={(e) => setSearch(s => ({ ...s, albumYear: e.target.value }))}
                                                    onKeyPress={(e) => e.key === 'Enter' && searchArtistOrAlbum()}
                                                    placeholder="1969..."
                                                    className="w-full px-6 py-4 bg-white/10 border border-white/20 rounded-xl text-white text-lg placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50"
                                                />
                                            </div>
                                            <button
                                                onClick={searchArtistOrAlbum}
                                                disabled={search.loading}
                                                className="w-full px-8 py-4 bg-white text-black hover:bg-gray-100 disabled:bg-gray-600 rounded-xl font-semibold flex items-center justify-center gap-3"
                                            >
                                                {search.loading ? <Loader2 className="w-6 h-6" /> : <Search className="w-6 h-6" />}
                                                {search.loading ? 'Searching...' : 'Search'}
                                            </button>
                                        </div>
                                    )}

                                    {search.error && (
                                        <div className="bg-red-500/20 border border-red-500/50 rounded-xl p-5 mt-6">
                                            <p className="text-red-200 text-lg">{search.error}</p>
                                        </div>
                                    )}

                                    {search.suggestions.length > 0 && (
                                        <div className="space-y-4 mt-8">
                                            <h3 className="text-white font-semibold text-xl">Select {state.mode === 'artist' ? 'an artist' : 'an album'}:</h3>
                                            <div className="space-y-3">
                                                {paginatedSuggestions.map((item) => (
                                                    <button
                                                        key={item.type === 'artist' ? item.artistId : item.collectionId}
                                                        onClick={() => item.type === 'artist' ? selectArtistForAlbums(item) : selectSingleAlbum(item)}
                                                        className="w-full bg-white/10 hover:bg-white/20 rounded-xl p-5 text-left transition-all border border-white/20"
                                                    >
                                                        <div className="flex items-center justify-between gap-4">
                                                            <div className="flex items-center gap-4 flex-1">
                                                                {item.artworkUrl100 && (
                                                                    <img src={item.artworkUrl100} alt="" className="w-16 h-16 rounded-lg" />
                                                                )}
                                                                <div className="flex-1">
                                                                    <p className="text-white font-semibold text-xl">
                                                                        {item.type === 'artist' ? item.artistName : item.collectionName}
                                                                    </p>
                                                                    {item.type === 'album' && (
                                                                        <>
                                                                            {item.artistName && (
                                                                                <p className="text-gray-300 text-base mt-1">{item.artistName}</p>
                                                                            )}
                                                                            {item.releaseDate && (
                                                                                <p className="text-gray-400 text-sm mt-0.5">
                                                                                    {new Date(item.releaseDate).getFullYear()}
                                                                                </p>
                                                                            )}
                                                                        </>
                                                                    )}
                                                                </div>
                                                            </div>
                                                            <ChevronRight className="w-7 h-7 text-gray-300" />
                                                        </div>
                                                    </button>
                                                ))}
                                            </div>

                                            {search.suggestions.length > itemsPerPage && (
                                                <div className="flex justify-center gap-3 mt-6">
                                                    <button
                                                        onClick={() => setSearch(s => ({ ...s, page: Math.max(0, s.page - 1) }))}
                                                        disabled={search.page === 0}
                                                        className="px-4 py-2 bg-white/10 hover:bg-white/20 disabled:opacity-50 text-white rounded-lg"
                                                    >
                                                        Previous
                                                    </button>
                                                    <span className="px-4 py-2 text-white">
                                                        Page {search.page + 1} of {Math.ceil(search.suggestions.length / itemsPerPage)}
                                                    </span>
                                                    <button
                                                        onClick={() => setSearch(s => ({ ...s, page: Math.min(Math.ceil(s.suggestions.length / itemsPerPage) - 1, s.page + 1) }))}
                                                        disabled={search.page >= Math.ceil(search.suggestions.length / itemsPerPage) - 1}
                                                        className="px-4 py-2 bg-white/10 hover:bg-white/20 disabled:opacity-50 text-white rounded-lg"
                                                    >
                                                        Next
                                                    </button>
                                                </div>
                                            )}
                                        </div>
                                    )}

                                    {search.loadingSongs && (
                                        <div className="flex items-center justify-center gap-4 py-12">
                                            <Loader2 className="w-10 h-10 text-white" />
                                            <p className="text-white text-xl">Loading...</p>
                                        </div>
                                    )}
                                </div>
                            )}

                            {state.stage === 'selectAlbums' && (
                                <div className="bg-white/5 backdrop-blur-2xl rounded-3xl p-10 shadow-2xl border border-white/10 mt-8">
                                    <div className="flex items-center gap-3 mb-6">
                                        <button onClick={() => setState(s => ({ ...s, stage: 'search' }))} className="p-2 hover:bg-white/10 rounded-lg transition-colors">
                                            <ArrowLeft className="w-6 h-6 text-white" />
                                        </button>
                                        <div>
                                            <h2 className="text-2xl font-bold text-white">Select Albums</h2>
                                            <p className="text-gray-300 text-sm mt-1">Choose which albums to include</p>
                                        </div>
                                    </div>

                                    <div className="flex gap-3 mb-4">
                                        <button
                                            onClick={() => setState(s => ({ ...s, selectedAlbums: new Set(s.albums.map(a => a.collectionId)) }))}
                                            className="px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg border border-white/20"
                                        >
                                            Select All
                                        </button>
                                        <button
                                            onClick={() => setState(s => ({ ...s, selectedAlbums: new Set() }))}
                                            className="px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg border border-white/20"
                                        >
                                            Deselect All
                                        </button>
                                        <div className="flex-1" />
                                        <span className="text-gray-300 py-2">{state.selectedAlbums.size} selected</span>
                                    </div>

                                    <div className="grid grid-cols-2 md:grid-cols-3 gap-4 max-h-[500px] overflow-y-auto pr-2">
                                        {state.albums.map((album) => (
                                            <button
                                                key={album.collectionId}
                                                onClick={() => {
                                                    const newSet = new Set(state.selectedAlbums);
                                                    if (newSet.has(album.collectionId)) {
                                                        newSet.delete(album.collectionId);
                                                    } else {
                                                        newSet.add(album.collectionId);
                                                    }
                                                    setState(s => ({ ...s, selectedAlbums: newSet }));
                                                }}
                                                className={`p-4 rounded-xl transition-all border-2 ${state.selectedAlbums.has(album.collectionId)
                                                    ? 'bg-white/20 border-white/50'
                                                    : 'bg-white/5 border-white/10 hover:bg-white/10'
                                                    }`}
                                            >
                                                <img src={album.artworkUrl100} alt={album.collectionName} className="w-full aspect-square rounded-lg mb-3" />
                                                <p className="text-white font-medium text-sm text-center line-clamp-2">{album.collectionName}</p>
                                            </button>
                                        ))}
                                    </div>

                                    <button
                                        onClick={proceedWithSelectedAlbums}
                                        disabled={search.loadingSongs || state.selectedAlbums.size === 0}
                                        className="w-full mt-6 px-8 py-4 bg-white text-black hover:bg-gray-100 disabled:bg-gray-600 rounded-xl font-semibold flex items-center justify-center gap-3"
                                    >
                                        {search.loadingSongs ? (
                                            <>
                                                <Loader2 className="w-6 h-6" />
                                                Loading Songs...
                                            </>
                                        ) : (
                                            <>
                                                Continue with {state.selectedAlbums.size} album{state.selectedAlbums.size !== 1 ? 's' : ''}
                                                <ChevronRight className="w-6 h-6" />
                                            </>
                                        )}
                                    </button>
                                </div>
                            )}

                            {state.stage === 'sorting' && state.songs.length > 0 && sorting.sortedIndices.length > sorting.j + 1 && (
                                <div className="space-y-6 mt-8">
                                    <div className="bg-white/5 backdrop-blur-2xl rounded-2xl p-6 shadow-2xl border border-white/10">
                                        <div className="flex justify-between items-center mb-3">
                                            <span className="text-white font-medium text-lg">
                                                Ranking {state.selectedArtist?.artistName || state.selectedArtist?.collectionName}
                                            </span>
                                            <span className="text-gray-300">
                                                {sorting.comparisons} / {sorting.estimatedRemaining} comparisons
                                            </span>
                                        </div>
                                        <div className="w-full bg-white/20 rounded-full h-3 overflow-hidden">
                                            <div
                                                className="h-3 rounded-full transition-all duration-500 ease-out"
                                                style={{
                                                    width: `${Math.min(100, progress)}%`,
                                                    background: `linear-gradient(to right, ${bgColors[0]}, ${bgColors[1]})`
                                                }}
                                            />
                                        </div>
                                        <p className="text-gray-300 text-sm mt-2">
                                            {activeSongCount} songs â¢ {sorting.autoSkipped} auto-skipped
                                        </p>
                                    </div>

                                    <div className="bg-white/5 backdrop-blur-2xl rounded-3xl p-10 shadow-2xl border border-white/10">
                                        <h2 className="text-3xl font-bold text-white text-center mb-10">
                                            Which song do you prefer?
                                        </h2>

                                        <div className="grid md:grid-cols-2 gap-6 mb-6">
                                            <button
                                                onClick={() => handlePreference('song1')}
                                                onContextMenu={(e) => handleRightClick(e, sorting.j)}
                                                className="w-full bg-white/10 hover:bg-white/20 rounded-2xl p-10 transition-all duration-300 transform hover:scale-105 shadow-xl border border-white/20"
                                            >
                                                <div className="flex flex-col items-center gap-5">
                                                    {state.songData[sorting.sortedIndices[sorting.j]]?.artwork ? (
                                                        <img
                                                            src={state.songData[sorting.sortedIndices[sorting.j]].artwork}
                                                            alt=""
                                                            className="w-32 h-32 rounded-lg"
                                                        />
                                                    ) : (
                                                        <Music className="w-20 h-20 text-white" />
                                                    )}
                                                    <p className="text-white text-2xl font-semibold text-center">
                                                        {state.songs[sorting.sortedIndices[sorting.j]]}
                                                    </p>
                                                    {state.songData[sorting.sortedIndices[sorting.j]]?.previewUrl && (
                                                        <button
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                toggleAudio(sorting.j);
                                                            }}
                                                            className="px-4 py-2 bg-white/20 hover:bg-white/30 text-white rounded-lg flex items-center gap-2 transition-colors"
                                                        >
                                                            {playingAudio.index === sorting.j ? (
                                                                <>
                                                                    <Pause className="w-5 h-5" />
                                                                    Pause
                                                                </>
                                                            ) : (
                                                                <>
                                                                    <Play className="w-5 h-5" />
                                                                    Preview
                                                                </>
                                                            )}
                                                        </button>
                                                    )}
                                                    <ChevronRight className="w-7 h-7 text-white/70 group-hover:text-white" />
                                                </div>
                                            </button>

                                            <button
                                                onClick={() => handlePreference('song2')}
                                                onContextMenu={(e) => handleRightClick(e, sorting.j + 1)}
                                                className="w-full bg-white/10 hover:bg-white/20 rounded-2xl p-10 transition-all duration-300 transform hover:scale-105 shadow-xl border border-white/20"
                                            >
                                                <div className="flex flex-col items-center gap-5">
                                                    {state.songData[sorting.sortedIndices[sorting.j + 1]]?.artwork ? (
                                                        <img
                                                            src={state.songData[sorting.sortedIndices[sorting.j + 1]].artwork}
                                                            alt=""
                                                            className="w-32 h-32 rounded-lg"
                                                        />
                                                    ) : (
                                                        <Music className="w-20 h-20 text-white" />
                                                    )}
                                                    <p className="text-white text-2xl font-semibold text-center">
                                                        {state.songs[sorting.sortedIndices[sorting.j + 1]]}
                                                    </p>
                                                    {state.songData[sorting.sortedIndices[sorting.j + 1]]?.previewUrl && (
                                                        <button
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                toggleAudio(sorting.j + 1);
                                                            }}
                                                            className="px-4 py-2 bg-white/20 hover:bg-white/30 text-white rounded-lg flex items-center gap-2 transition-colors"
                                                        >
                                                            {playingAudio.index === sorting.j + 1 ? (
                                                                <>
                                                                    <Pause className="w-5 h-5" />
                                                                    Pause
                                                                </>
                                                            ) : (
                                                                <>
                                                                    <Play className="w-5 h-5" />
                                                                    Preview
                                                                </>
                                                            )}
                                                        </button>
                                                    )}
                                                    <ChevronRight className="w-7 h-7 text-white/70 group-hover:text-white" />
                                                </div>
                                            </button>
                                        </div>

                                        <div className="flex gap-3">
                                            <button
                                                onClick={handleUndo}
                                                disabled={sorting.history.length === 0}
                                                className="flex-1 px-6 py-3 bg-white/5 hover:bg-white/10 disabled:opacity-30 disabled:cursor-not-allowed text-white rounded-xl font-semibold flex items-center justify-center gap-2 border border-white/20"
                                            >
                                                <Undo className="w-5 h-5" />
                                                Undo
                                            </button>
                                            <button
                                                onClick={handleUnsure}
                                                className="flex-1 px-6 py-3 bg-white/5 hover:bg-white/10 text-white rounded-xl font-semibold flex items-center justify-center gap-2 border border-white/20"
                                            >
                                                <HelpCircle className="w-5 h-5" />
                                                Skip
                                            </button>
                                        </div>

                                        <button
                                            onClick={() => setShowProgress(true)}
                                            className="w-full mt-4 px-6 py-3 bg-white/5 hover:bg-white/10 text-white rounded-xl font-semibold flex items-center justify-center gap-2 border border-white/20"
                                        >
                                            View Current Rankings
                                        </button>
                                    </div>
                                </div>
                            )}

                            {showProgress && state.stage === 'sorting' && (
                                <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                                    <div className="bg-white/10 backdrop-blur-2xl rounded-3xl p-8 max-w-2xl w-full border border-white/20 shadow-2xl max-h-[80vh] overflow-hidden flex flex-col">
                                        <div className="flex items-center justify-between mb-6">
                                            <h3 className="text-2xl font-bold text-white">Current Rankings (In Progress)</h3>
                                            <button onClick={() => setShowProgress(false)} className="p-2 hover:bg-white/10 rounded-lg">
                                                <X className="w-6 h-6 text-white" />
                                            </button>
                                        </div>
                                        <p className="text-gray-300 mb-4">This is a snapshot of your current ranking. Keep comparing to finalize!</p>
                                        <div className="space-y-2 overflow-y-auto pr-2 flex-1">
                                            {sorting.sortedIndices.filter(idx => !state.excludedSongs.has(idx)).map((songIdx, rank) => (
                                                <div
                                                    key={rank}
                                                    className="bg-white/10 rounded-lg p-4 flex items-center gap-4 border border-white/10"
                                                >
                                                    <div className="text-xl font-bold text-white w-12">#{rank + 1}</div>
                                                    <div className="flex-1">
                                                        <p className="text-white font-medium">{state.songs[songIdx]}</p>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                        <button
                                            onClick={() => setShowProgress(false)}
                                            className="mt-6 w-full px-6 py-3 bg-white text-black hover:bg-gray-100 rounded-xl font-semibold"
                                        >
                                            Continue Ranking
                                        </button>
                                    </div>
                                </div>
                            )}

                            {state.stage === 'results' && (
                                <div className="space-y-6 mt-8">
                                    <div className="bg-white/5 backdrop-blur-2xl rounded-3xl p-10 shadow-2xl border border-white/10">
                                        <h2 className="text-4xl font-bold text-white text-center mb-3">Your Ranking</h2>
                                        <p className="text-gray-300 text-center mb-8 text-lg">
                                            {state.selectedArtist?.artistName || state.selectedArtist?.collectionName} â¢ {activeSongCount} songs
                                        </p>

                                        <div className="flex justify-center gap-2 mb-6">
                                            <button
                                                onClick={() => setViewMode('grid')}
                                                className={`px-4 py-2 rounded-lg flex items-center gap-2 transition-colors ${viewMode === 'grid'
                                                    ? 'bg-white text-black'
                                                    : 'bg-white/10 text-white hover:bg-white/20'
                                                    }`}
                                            >
                                                <Grid className="w-5 h-5" />
                                                Grid
                                            </button>
                                            <button
                                                onClick={() => setViewMode('list')}
                                                className={`px-4 py-2 rounded-lg flex items-center gap-2 transition-colors ${viewMode === 'list'
                                                    ? 'bg-white text-black'
                                                    : 'bg-white/10 text-white hover:bg-white/20'
                                                    }`}
                                            >
                                                <List className="w-5 h-5" />
                                                List
                                            </button>
                                        </div>

                                        {viewMode === 'grid' ? (
                                            <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 max-h-[600px] overflow-y-auto pr-2 mb-6">
                                                {sorting.sortedIndices.filter(idx => !state.excludedSongs.has(idx)).map((songIdx, rank) => {
                                                    const song = state.songData[songIdx];
                                                    return (
                                                        <div
                                                            key={rank}
                                                            className="bg-white/10 rounded-xl p-3 hover:bg-white/20 transition-colors border border-white/10 relative"
                                                        >
                                                            <div className="absolute top-2 left-2 bg-black/80 text-white font-bold text-base px-2 py-1 rounded-lg z-10">
                                                                #{rank + 1}
                                                            </div>
                                                            {song?.artwork ? (
                                                                <img
                                                                    src={song.artwork}
                                                                    alt={state.songs[songIdx]}
                                                                    className="w-full aspect-square rounded-lg mb-2"
                                                                />
                                                            ) : (
                                                                <div className="w-full aspect-square rounded-lg mb-2 bg-white/5 flex items-center justify-center">
                                                                    <Music className="w-12 h-12 text-white/50" />
                                                                </div>
                                                            )}
                                                            <p className="text-white text-sm font-medium text-center line-clamp-2">
                                                                {state.songs[songIdx]}
                                                            </p>
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        ) : (
                                            <div className="space-y-3 max-h-[600px] overflow-y-auto pr-2 mb-6">
                                                {sorting.sortedIndices.filter(idx => !state.excludedSongs.has(idx)).map((songIdx, rank) => (
                                                    <div
                                                        key={rank}
                                                        className="bg-white/10 rounded-xl p-5 flex items-center gap-5 hover:bg-white/20 transition-colors border border-white/10"
                                                    >
                                                        <div className="text-3xl font-bold text-white w-16">#{rank + 1}</div>
                                                        {state.songData[songIdx]?.artwork && (
                                                            <img
                                                                src={state.songData[songIdx].artwork}
                                                                alt=""
                                                                className="w-16 h-16 rounded-lg"
                                                            />
                                                        )}
                                                        <div className="flex-1">
                                                            <p className="text-white text-xl font-medium">{state.songs[songIdx]}</p>
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        )}

                                        <div className="flex flex-col gap-3">
                                            <p className="text-gray-400 text-sm text-center">Export your ranking</p>
                                            <div className="grid grid-cols-3 gap-3">
                                                <button
                                                    onClick={exportToPDF}
                                                    className="px-4 py-4 bg-white/10 hover:bg-white/20 text-white rounded-xl font-semibold border border-white/20 flex flex-col items-center justify-center gap-1 transition-all"
                                                >
                                                    <Download className="w-5 h-5" />
                                                    <span className="text-sm">PDF</span>
                                                </button>
                                                <button
                                                    onClick={exportToTXT}
                                                    className="px-4 py-4 bg-white/10 hover:bg-white/20 text-white rounded-xl font-semibold border border-white/20 flex flex-col items-center justify-center gap-1 transition-all"
                                                >
                                                    <Download className="w-5 h-5" />
                                                    <span className="text-sm">TXT</span>
                                                </button>
                                                <button
                                                    onClick={exportToPNG}
                                                    className="px-4 py-4 bg-white/10 hover:bg-white/20 text-white rounded-xl font-semibold border border-white/20 flex flex-col items-center justify-center gap-1 transition-all"
                                                >
                                                    <Download className="w-5 h-5" />
                                                    <span className="text-sm">PNG</span>
                                                </button>
                                            </div>
                                            <button
                                                onClick={() => setShowTierlistExport(true)}
                                                className="w-full px-6 py-4 text-white rounded-xl font-semibold flex items-center justify-center gap-2 transition-all border border-white/30"
                                                style={{ background: 'linear-gradient(135deg, rgba(255,127,127,0.2), rgba(127,191,255,0.2))', backdropFilter: 'blur(10px)' }}
                                            >
                                                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 10h16M4 14h8m-8 4h4" />
                                                </svg>
                                                Send to Tier List
                                            </button>
                                            <button
                                                onClick={handleTryAnother}
                                                className="w-full px-6 py-4 bg-white/5 hover:bg-white/10 text-white rounded-xl font-semibold border border-white/20 flex items-center justify-center gap-2 transition-all"
                                            >
                                                <Music className="w-5 h-5" />
                                                Try Another Artist / Album
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>

                    {showUrlImport && (
                        <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                            <div className="bg-white/10 backdrop-blur-2xl rounded-3xl p-8 max-w-md w-full border border-white/20 shadow-2xl">
                                <div className="flex items-center justify-between mb-6">
                                    <h3 className="text-2xl font-bold text-white">Import from URL</h3>
                                    <button
                                        onClick={() => {
                                            setShowUrlImport(false);
                                            setUrlInput('');
                                            setSearch(s => ({ ...s, error: '' }));
                                        }}
                                        className="p-2 hover:bg-white/10 rounded-lg"
                                    >
                                        <X className="w-6 h-6 text-white" />
                                    </button>
                                </div>

                                <p className="text-gray-300 mb-4">
                                    Paste a URL from Bandcamp (artist or album). Support for Spotify, Apple Music, and Deezer coming soon!
                                </p>

                                <input
                                    type="text"
                                    value={urlInput}
                                    onChange={(e) => setUrlInput(e.target.value)}
                                    onKeyPress={(e) => e.key === 'Enter' && handleUrlImport()}
                                    placeholder="https://artist.bandcamp.com/album/..."
                                    className="w-full px-4 py-3 bg-white/10 border border-white/20 rounded-xl text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50 mb-4"
                                />

                                {search.error && (
                                    <div className="bg-red-500/20 border border-red-500/50 rounded-xl p-4 mb-4">
                                        <p className="text-red-200 text-sm">{search.error}</p>
                                    </div>
                                )}

                                <div className="flex gap-3">
                                    <button
                                        onClick={() => {
                                            setShowUrlImport(false);
                                            setUrlInput('');
                                            setSearch(s => ({ ...s, error: '' }));
                                        }}
                                        className="flex-1 px-6 py-3 bg-white/10 hover:bg-white/20 text-white rounded-xl font-semibold border border-white/20"
                                    >
                                        Cancel
                                    </button>
                                    <button
                                        onClick={handleUrlImport}
                                        className="flex-1 px-6 py-3 bg-white text-black hover:bg-gray-100 rounded-xl font-semibold"
                                    >
                                        Import
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {showTierlistExport && (
                        <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                            <div className="bg-white/10 backdrop-blur-2xl rounded-3xl p-8 max-w-md w-full border border-white/20 shadow-2xl">
                                <h3 className="text-2xl font-bold text-white mb-3">Send to Tier List</h3>
                                <p className="text-gray-300 mb-3">
                                    This will create a new tier list from your ranked results, placing songs into tiers based on their rank percentile.
                                </p>
                                <div className="rounded-xl p-4 mb-6" style={{ background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.1)' }}>
                                    <p className="text-sm text-gray-400 mb-2 font-semibold">Tier assignment:</p>
                                    <div className="grid grid-cols-7 gap-1 text-center text-xs">
                                        {[['S','#ff7f7f'],['A','#ffbf7f'],['B','#ffdf7f'],['C','#ffff7f'],['D','#bfff7f'],['E','#7fff7f'],['F','#7fbfff']].map(([t,c]) => (
                                            <div key={t} className="rounded-lg py-1 font-bold text-black" style={{ background: c }}>{t}</div>
                                        ))}
                                    </div>
                                    <p className="text-xs text-gray-400 mt-2 text-center">Top â Bottom, split evenly across 7 tiers</p>
                                </div>
                                <p className="text-gray-400 text-sm mb-6">
                                    Your existing tier lists will be preserved. The new list will open in a new tab in songs mode.
                                </p>
                                <div className="flex gap-3">
                                    <button
                                        onClick={() => setShowTierlistExport(false)}
                                        className="flex-1 px-6 py-3 bg-white/10 hover:bg-white/20 text-white rounded-xl font-semibold border border-white/20"
                                    >
                                        Cancel
                                    </button>
                                    <button
                                        onClick={exportToTierlist}
                                        className="flex-1 px-6 py-3 text-white rounded-xl font-semibold"
                                        style={{ background: 'linear-gradient(135deg, #ff7f7f, #7fbfff)' }}
                                    >
                                        Open Tier List
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {notification && (
                        <Notification
                            message={notification.message}
                            type={notification.type}
                            songIdx={notification.songIdx}
                            onClose={() => setNotification(null)}
                            onMoveTop={notification.type === 'trending-up' ? () => moveToTop(notification.songIdx) : null}
                            onMoveBottom={notification.type === 'trending-down' ? () => moveToBottom(notification.songIdx) : null}
                        />
                    )}

                    {contextMenu && (
                        <ContextMenu
                            x={contextMenu.x}
                            y={contextMenu.y}
                            onBest={() => markAsBest(sorting.sortedIndices[contextMenu.songIndex])}
                            onWorst={() => markAsWorst(sorting.sortedIndices[contextMenu.songIndex])}
                            onExclude={() => {
                                const songIdx = sorting.sortedIndices[contextMenu.songIndex];
                                setContextMenu(null);
                                excludeSong(songIdx);
                            }}
                            onClose={() => setContextMenu(null)}
                            canMoveBest={contextMenu.canMoveBest}
                            canMoveWorst={contextMenu.canMoveWorst}
                        />
                    )}

                    {modalOpen && modalConfig && (
                        <Modal
                            isOpen={modalOpen}
                            onClose={() => setModalOpen(false)}
                            onSubmit={modalConfig.onSubmit}
                            title={modalConfig.title}
                            fields={modalConfig.fields}
                            message={modalConfig.message}
                        />
                    )}
                </div>
            );
        }

        ReactDOM.render(<RankerMode />, document.getElementById('root'));
    </script>
    <!-- Help Button -->
    <button id="helpBtn"
        onclick="document.getElementById('helpModal').classList.remove('hidden'); document.body.style.overflow='hidden';"
        class="fixed bottom-6 right-6 w-12 h-12 flex items-center justify-center rounded-full z-40 transition-all duration-300 hover:scale-110 active:scale-95"
        style="background: rgba(255,255,255,0.12); border: 1px solid rgba(255,255,255,0.2); backdrop-filter: blur(20px); box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
        <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
    </button>

    <!-- Help Modal -->
    <div id="helpModal" class="hidden fixed inset-0 z-50 flex items-center justify-center p-4"
        style="background: rgba(0,0,0,0.8); backdrop-filter: blur(8px);"
        onclick="if(event.target===this){this.classList.add('hidden');document.body.style.overflow='auto';}">
        <div class="w-full max-w-2xl" onclick="event.stopPropagation()">
            <div class="rounded-3xl p-8 shadow-2xl"
                style="background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); backdrop-filter: blur(40px);">
                <div class="flex items-center justify-between mb-6">
                    <h3 class="text-3xl font-bold text-white">Ranker</h3>
                    <button
                        onclick="document.getElementById('helpModal').classList.add('hidden');document.body.style.overflow='auto';"
                        class="w-10 h-10 flex items-center justify-center rounded-full transition-all"
                        style="background: rgba(255,255,255,0.1);">
                        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <div class="text-gray-200 space-y-4 overflow-y-auto pr-2" style="max-height: 60vh;">
                    <div class="space-y-6">
                        <div>
                            <h4 class="text-xl font-semibold text-white mb-2">What is This?</h4>
                            <p class="text-gray-300">A comparison-based ranker that sorts songs by asking you to pick
                                between two at a time. Easier than staring at a blank list â you just answer one simple
                                question repeatedly until it's done.</p>
                        </div>
                        <div>
                            <h4 class="text-xl font-semibold text-white mb-2">How the Algorithm Works</h4>
                            <p class="text-gray-300 mb-3">Under the hood this uses an optimised sort with transitive
                                inference:</p>
                            <ol class="list-decimal list-inside space-y-2 text-gray-300 ml-4">
                                <li>You compare two songs and pick your favourite</li>
                                <li>Your picks slowly bubble the best songs to the top</li>
                                <li>The algorithm skips obvious comparisons (if A > B and B > C, it already knows A > C)
                                </li>
                                <li>It keeps going until everything is sorted</li>
                            </ol>
                        </div>
                        <div>
                            <h4 class="text-xl font-semibold text-white mb-2">Using It</h4>
                            <ul class="space-y-2 text-gray-300">
                                <li><strong>Rank Artist:</strong> pick an artist, select which albums to include, and
                                    rank their whole catalogue</li>
                                <li><strong>Rank Album:</strong> rank all tracks from one specific album</li>
                                <li><strong>Preview:</strong> hit the play button to hear a 30-second clip (requires
                                    Apple Music availability)</li>
                                <li><strong>Undo:</strong> changed your mind? Undo your last pick</li>
                                <li><strong>Skip:</strong> genuinely can't choose? Skip it â the algorithm will try to
                                    infer the answer from your other choices. If it can't, it'll ask again later</li>
                                <li><strong>Right-click a song card:</strong> instantly move a song to the top or bottom
                                    if you're certain about it</li>
                            </ul>
                        </div>
                        <div>
                            <h4 class="text-xl font-semibold text-white mb-2">Saving & Exporting</h4>
                            <ul class="space-y-2 text-gray-300">
                                <li><strong>Auto-save:</strong> your session saves automatically every 5 comparisons</li>
                                <li><strong>Save Progress:</strong> export mid-ranking as a JSON file for safekeeping</li>
                                <li><strong>Load Save:</strong> resume a previous session from a saved file</li>
                                <li><strong>Export PDF / TXT / PNG:</strong> download your ranked list in your preferred format</li>
                                <li><strong>Try Another:</strong> rank something new â your current results are saved first</li>
                            </ul>
                        </div>
                        <div class="rounded-xl p-4"
                            style="background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);">
                            <p class="text-sm text-gray-400"><strong>Tip:</strong> try to stay consistent â if you
                                contradict yourself too often the algorithm has to make judgment calls and the results
                                can get a bit random</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                document.getElementById('helpModal').classList.add('hidden');
                document.body.style.overflow = 'auto';
            }
        });
    </script>
</body>

</html>
