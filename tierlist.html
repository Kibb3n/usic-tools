<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tier List - μsic tools</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        html,
        body {
            background: #000;
        }

        @keyframes blob1 {

            0%,
            100% {
                transform: translate(0, 0) scale(1)
            }

            33% {
                transform: translate(150px, 100px) scale(1.2)
            }

            66% {
                transform: translate(-100px, 150px) scale(0.9)
            }
        }

        @keyframes blob2 {

            0%,
            100% {
                transform: translate(0, 0) scale(1)
            }

            33% {
                transform: translate(-150px, -100px) scale(0.9)
            }

            66% {
                transform: translate(100px, -150px) scale(1.2)
            }
        }

        .grain {
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='3.5' numOctaves='4' /%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.3'/%3E%3C/svg%3E");
            pointer-events: none;
        }

        .tier-slot {
            border: 2px dashed rgba(255, 255, 255, 0.2);
            transition: border-color 0.2s, background 0.2s;
            min-height: 80px;
            overflow: visible;
        }

        .tier-slot.drag-over {
            border-color: #60a5fa !important;
            background: rgba(96, 165, 250, 0.2);
        }

        /* Improved drag styles */
        .draggable-item {
            cursor: grab;
            user-select: none;
        }

        .draggable-item:hover {
            z-index: 10;
        }

        .draggable-item:active {
            cursor: grabbing;
        }

        .draggable-item.dragging {
            opacity: 0.25;
            transform: scale(0.95);
        }

        /* Insert indicator — a slim glowing spacer between tiles */
        .drop-gap-indicator {
            width: 4px;
            align-self: stretch;
            min-height: 64px;
            background: #60a5fa;
            border-radius: 3px;
            box-shadow: 0 0 8px 2px rgba(96, 165, 250, 0.7);
            flex-shrink: 0;
            pointer-events: none;
        }

        /* DOM-based touch drop indicator (zero-lag, bypasses React re-renders) */
        #touch-drop-indicator {
            width: 4px;
            align-self: stretch;
            min-height: 64px;
            background: #60a5fa;
            border-radius: 3px;
            box-shadow: 0 0 8px 2px rgba(60, 130, 246, 0.85);
            flex-shrink: 0;
            pointer-events: none;
            display: none;
        }

        .song-bg {
            position: absolute;
            inset: 0;
            object-fit: cover;
            filter: blur(8px);
            transform: scale(1.1);
        }

        .song-title {
            position: relative;
            z-index: 1;
            background: rgba(0, 0, 0, 0.7);
            padding: 4px 8px;
            border-radius: 4px;
        }

        .mode-switch {
            position: relative;
            width: 158px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.2);
            flex-shrink: 0;
        }

        .mode-switch-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 76px;
            height: 32px;
            background: white;
            border-radius: 5px;
            transition: transform 0.25s ease;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
        }

        .mode-switch.songs .mode-switch-slider {
            transform: translateX(76px);
        }

        .mode-label {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 13px;
            font-weight: 600;
            transition: color 0.25s ease;
            width: 79px;
            text-align: center;
        }

        .mode-label.left {
            left: 0;
        }

        .mode-label.right {
            right: 0;
        }

        .mode-switch .mode-label.left {
            color: black;
        }

        .mode-switch .mode-label.right {
            color: rgba(255, 255, 255, 0.75);
        }

        .mode-switch.songs .mode-label.left {
            color: rgba(255, 255, 255, 0.75);
        }

        .mode-switch.songs .mode-label.right {
            color: black;
        }

        .editable-title {
            cursor: text;
            transition: all 0.2s;
            display: inline-block;
            min-width: 200px;
            text-align: center;
        }

        .editable-title:hover:not(.editing) {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 4px 12px;
        }

        .undo-toast {
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from {
                transform: translateY(100px);
                opacity: 0
            }

            to {
                transform: translateY(0);
                opacity: 1
            }
        }

        /* Toggle switch (from topsters) */
        .toggle-switch {
            position: relative;
            display: inline-flex;
            align-items: center;
            cursor: pointer;
            gap: 10px;
            user-select: none;
        }

        .toggle-switch input[type="checkbox"] {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-track {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
            flex-shrink: 0;
            transition: background 0.2s, border-color 0.2s;
        }

        .toggle-switch input:checked~.toggle-track {
            background: rgba(255, 255, 255, 0.85);
            border-color: rgba(255, 255, 255, 0.9);
        }

        .toggle-thumb {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transition: transform 0.2s, background 0.2s;
        }

        .toggle-switch input:checked~.toggle-track .toggle-thumb {
            transform: translateX(16px);
            background: #111;
        }

        .toggle-label {
            color: rgba(255, 255, 255, 0.85);
            font-size: 0.875rem;
            line-height: 1.25;
        }

        /* Sidebar */
        .sidebar-panel {
            position: sticky;
            top: 1rem;
            max-height: calc(100vh - 2rem);
            display: flex;
            flex-direction: column;
        }

        .sidebar-scroll {
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }

        .sidebar-scroll::-webkit-scrollbar {
            width: 4px;
        }

        .sidebar-scroll::-webkit-scrollbar-track {
            background: transparent;
        }

        .sidebar-scroll::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
        }

        /* Touch drag ghost */
        #touch-drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.85;
            transform: translate(-50%, -50%) scale(1.08);
            border-radius: 6px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            transition: none;
            overflow: hidden;
        }

        /* Prevent text selection and page scroll during touch drag */
        body.touch-dragging {
            user-select: none !important;
            -webkit-user-select: none !important;
            overflow: hidden;
        }

        /* Stop iOS long-press context menu on draggable items */
        .draggable-item {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* Resize handle */
        .sidebar-resize-handle {
            position: absolute;
            top: 0;
            right: -4px;
            bottom: 0;
            width: 8px;
            cursor: col-resize;
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sidebar-resize-handle::after {
            content: '';
            width: 2px;
            height: 40px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 1px;
            transition: background 0.2s;
        }

        .sidebar-resize-handle:hover::after,
        .sidebar-resize-handle.dragging::after {
            background: rgba(255, 255, 255, 0.5);
        }

        .sidebar-wrapper {
            position: relative;
        }

        /* Main content area scrollable */
        .main-content {
            overflow-y: auto;
            max-height: calc(100vh - 80px);
            min-width: 0;
        }

        .main-content::-webkit-scrollbar {
            width: 6px;
        }

        .main-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .main-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 3px;
        }

        /* Prevent tier rows from clipping tiles */
        .tier-slot {
            overflow: visible !important;
        }

        .tier-row-items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            overflow: visible;
        }
    </style>
</head>

<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // Icons
        const Search = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>;
        const Download = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>;
        const ImageIcon = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg>;
        const Photo = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 13a3 3 0 11-6 0 3 3 0 016 0z" /></svg>;
        const Trash = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>;
        const Pencil = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" /></svg>;
        const Upload = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>;
        const SaveIcon = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 3H7a2 2 0 00-2 2v14a2 2 0 002 2h10a2 2 0 002-2V5a2 2 0 00-2-2z M12 17a2 2 0 110-4 2 2 0 010 4z M15 7H9V5h6v2z" /></svg>;
        const Loader2 = ({ className }) => <svg className={className + " animate-spin"} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" /></svg>;
        const Music = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3" /></svg>;
        const ChevronLeft = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" /></svg>;
        const ChevronRight = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" /></svg>;
        const ChevronDown = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" /></svg>;
        const Settings = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>;
        const Plus = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" /></svg>;
        const Square = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} /></svg>;
        const X = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>;
        const RefreshCw = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>;
        const RotateCcw = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" /></svg>;
        const ArrowLeft = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 19l-7-7m0 0l7-7m-7 7h18" /></svg>;
        const ArrowRight = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14 5l7 7m0 0l-7 7m7-7H3" /></svg>;
        const FileDown = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>;
        const Move = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4" /></svg>;
        const Layers = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5" /></svg>;

        const jsonpRequest = (url) => new Promise((resolve, reject) => {
            const cbName = 'jsonp_' + Math.round(1e6 * Math.random());
            window[cbName] = (data) => { delete window[cbName]; document.body.removeChild(script); resolve(data); };
            const script = document.createElement('script');
            script.src = url + (url.includes('?') ? '&' : '?') + 'callback=' + cbName;
            script.onerror = () => { delete window[cbName]; document.body.removeChild(script); reject(new Error('JSONP failed')); };
            document.body.appendChild(script);
        });

        const normalizeString = (str) => str.toLowerCase().replace(/[^a-z0-9]/g, '');

        const TIER_COLORS = { S: '#ff7f7f', A: '#ffbf7f', B: '#ffdf7f', C: '#ffff7f', D: '#bfff7f', E: '#7fff7f', F: '#7fbfff' };
        const DEFAULT_TIERS = ['S', 'A', 'B', 'C', 'D', 'E', 'F'];

        function AnimatedBackground({ colors, hasItems }) {
            return (
                <div className="fixed inset-0 overflow-hidden pointer-events-none" style={{ transition: 'opacity 1.2s ease' }}>
                    <div className="absolute w-[900px] h-[900px] rounded-full blur-3xl will-change-transform" style={{ background: `radial-gradient(circle, ${colors[0]} 0%, transparent 70%)`, animation: 'blob1 12s ease-in-out infinite', top: '50%', left: '33%', transform: 'translate(-50%,-50%)', opacity: hasItems ? 0.7 : 0, transition: 'opacity 1.5s ease' }} />
                    <div className="absolute w-[900px] h-[900px] rounded-full blur-3xl will-change-transform" style={{ background: `radial-gradient(circle, ${colors[1]} 0%, transparent 70%)`, animation: 'blob2 12s ease-in-out infinite', top: '50%', right: '33%', transform: 'translate(50%,-50%)', opacity: hasItems ? 0.7 : 0, transition: 'opacity 1.5s ease' }} />
                    <div className="absolute inset-0 grain opacity-30" />
                </div>
            );
        }

        function TierListApp() {
            const [tiers, setTiers] = useState({ S: [], A: [], B: [], C: [], D: [], E: [], F: [], unranked: [] });
            const [tierNames, setTierNames] = useState(DEFAULT_TIERS);
            const [tierColors, setTierColors] = useState(TIER_COLORS);
            const [songsMode, setSongsMode] = useState(false);
            const [albumBackup, setAlbumBackup] = useState(null);
            const [title, setTitle] = useState('My Music Tier List');
            const [bgColors, setBgColors] = useState(['#ff0080', '#7928ca']);
            const [bgHasItems, setBgHasItems] = useState(false);
            const [editingTitle, setEditingTitle] = useState(false);
            const [tempTitle, setTempTitle] = useState('My Music Tier List');

            const [searchQuery, setSearchQuery] = useState('');
            const [searchArtistFilter, setSearchArtistFilter] = useState('');
            const [searchYearFilter, setSearchYearFilter] = useState('');
            const [searchResults, setSearchResults] = useState([]);
            const [loading, setLoading] = useState(false);
            const [advancedSearchMode, setAdvancedSearchMode] = useState(false);
            const [artistSearchQuery, setArtistSearchQuery] = useState('');
            const [artistSuggestions, setArtistSuggestions] = useState([]);
            const [selectedArtist, setSelectedArtist] = useState(null);
            const [artistAlbums, setArtistAlbums] = useState([]);
            const [loadingArtist, setLoadingArtist] = useState(false);
            const [selectedAlbum, setSelectedAlbum] = useState(null);
            const [albumSongs, setAlbumSongs] = useState([]);
            const [loadingSongs, setLoadingSongs] = useState(false);

            // Drag state — track precise insert index using a spacer element approach
            const [draggedItem, setDraggedItem] = useState(null);
            const [draggedFrom, setDraggedFrom] = useState(null);
            const [dragOverTier, setDragOverTier] = useState(null);
            const [dropInsertIndex, setDropInsertIndex] = useState(null); // null=append, number=insert before idx
            const draggedItemRef = useRef(null);
            const draggedFromRef = useRef(null);
            const dropInsertIndexRef = useRef(null);
            const droppedRef = useRef(false); // guard against duplicate drop events from bubbling

            const [renameModalOpen, setRenameModalOpen] = useState(false);
            const [renameItem, setRenameItem] = useState(null);
            const [renameTitle, setRenameTitle] = useState('');
            const [createTileModalOpen, setCreateTileModalOpen] = useState(false);
            const [showConfirm, setShowConfirm] = useState(false);
            const [newTileTitle, setNewTileTitle] = useState('');
            const [newTileColor, setNewTileColor] = useState('#8b5cf6');

            // Sidebar modes:
            //  sidebarCollapsed=false, unrankedInSidebar=false → normal search sidebar
            //  sidebarCollapsed=false, unrankedInSidebar=true  → shouldn't happen (unranked IS the sidebar content when collapsed)
            //  sidebarCollapsed=true,  unrankedInSidebar=false → narrow arrow strip
            //  sidebarCollapsed=true,  unrankedInSidebar=true  → left column shows unranked, bottom btn = "Show Search"
            const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
            const [unrankedInSidebar, setUnrankedInSidebar] = useState(false);
            const [sidebarTab, setSidebarTab] = useState('search');
            const [sidebarWidth, setSidebarWidth] = useState(() => {
                const saved = parseInt(localStorage.getItem('tierlist_sidebarWidth'), 10);
                return (!isNaN(saved) && saved >= 200 && saved <= 600) ? saved : 320;
            });
            const sidebarResizingRef = useRef(false);
            const sidebarResizeStartX = useRef(0);
            const sidebarResizeStartW = useRef(0);

            const [editingTierName, setEditingTierName] = useState(null);
            const [tempTierName, setTempTierName] = useState('');

            const [history, setHistory] = useState([]);
            const [historyIndex, setHistoryIndex] = useState(-1);
            const [undoToast, setUndoToast] = useState(null);
            const [bulkMoveFrom, setBulkMoveFrom] = useState('');
            const [bulkMoveTo, setBulkMoveTo] = useState('');
            const [showReorderButtons, setShowReorderButtons] = useState(false);
            const [modeWarningOpen, setModeWarningOpen] = useState(false);
            const [showExportMenu, setShowExportMenu] = useState(false);
            const exportMenuRef = useRef(null);

            // ── MULTI-CHART STATE ──
            const [charts, setCharts] = useState({});
            const [currentChartId, setCurrentChartId] = useState(null);
            const [showChartsMenu, setShowChartsMenu] = useState(false);
            const [renamingChartId, setRenamingChartId] = useState(null);
            const chartsMenuRef = useRef(null);
            const isLoadingChartRef = useRef(false);
            const currentStateRef = useRef({});

            const tierListRef = useRef(null);
            const scrollIntervalRef = useRef(null);
            const titleInputRef = useRef(null);

            // ── Touch drag-and-drop ──────────────────────────────────────────────
            // HTML5 drag events don't fire on iOS/iPadOS. We implement a custom
            // touch-based drag system that reuses the same drag state so the tier
            // logic is identical for both input methods.
            const touchDragRef = useRef({
                item: null, fromTier: null, sourceEl: null, lastTarget: null,
                longPressTimer: null, active: false, startX: 0, startY: 0
            });
            const docTouchMoveRef = useRef(null);

            const createTouchGhost = useCallback((item, x, y, size) => {
                let ghost = document.getElementById('touch-drag-ghost');
                if (!ghost) {
                    ghost = document.createElement('div');
                    ghost.id = 'touch-drag-ghost';
                    document.body.appendChild(ghost);
                }
                ghost.innerHTML = '';
                ghost.style.width = size + 'px';
                ghost.style.height = size + 'px';
                if (item.image) {
                    const img = document.createElement('img');
                    img.src = item.image;
                    img.style.width = size + 'px';
                    img.style.height = size + 'px';
                    img.style.display = 'block';
                    img.style.objectFit = 'cover';
                    ghost.appendChild(img);
                    if (item.trackNumber !== undefined) {
                        // Song overlay
                        const overlay = document.createElement('div');
                        overlay.style.cssText = 'position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);padding:4px;';
                        const span = document.createElement('span');
                        span.style.cssText = 'color:#fff;font-size:10px;font-weight:600;text-align:center;line-height:1.2;word-break:break-word;';
                        span.textContent = item.title;
                        overlay.appendChild(span);
                        ghost.appendChild(overlay);
                    }
                } else if (item.custom) {
                    ghost.style.backgroundColor = item.color || '#8b5cf6';
                    const span = document.createElement('span');
                    span.style.cssText = 'color:#fff;font-size:10px;font-weight:600;text-align:center;word-break:break-word;display:flex;align-items:center;justify-content:center;width:100%;height:100%;padding:4px;box-sizing:border-box;';
                    span.textContent = item.title;
                    ghost.appendChild(span);
                }
                ghost.style.left = x + 'px';
                ghost.style.top = y + 'px';
                ghost.style.display = 'block';
                return ghost;
            }, []);

            const removeTouchGhost = useCallback(() => {
                const ghost = document.getElementById('touch-drag-ghost');
                if (ghost) ghost.style.display = 'none';
            }, []);

            // Find the tier slot element under the touch point
            const getTouchDropTarget = useCallback((x, y) => {
                const el = document.elementFromPoint(x, y);
                if (!el) return null;
                return el.closest('[data-touch-tier]');
            }, []);

            // ── DOM-based drop indicator (zero-lag, no React re-render) ─────────
            const getTouchIndicator = () => {
                let el = document.getElementById('touch-drop-indicator');
                if (!el) {
                    el = document.createElement('div');
                    el.id = 'touch-drop-indicator';
                    document.body.appendChild(el);
                }
                return el;
            };
            const hideTouchIndicator = () => {
                const el = document.getElementById('touch-drop-indicator');
                if (el && el.parentNode) el.parentNode.removeChild(el);
            };
            // Place the indicator before `refChild` inside `container`, or append if refChild is null
            const placeTouchIndicator = (container, refChild) => {
                const ind = getTouchIndicator();
                ind.style.display = 'block';
                if (refChild) {
                    container.insertBefore(ind, refChild);
                } else {
                    container.appendChild(ind);
                }
            };

            // Compute insert index within a tier slot based on touch position.
            // Handles wrapped/multi-row layouts: first find which row the finger is on
            // (by proximity in Y), then do the left/right midpoint check within that row.
            const computeTouchInsertIndex = useCallback((tierEl, x, y) => {
                const children = Array.from(tierEl.querySelectorAll(':scope > .draggable-item'));
                if (!children.length) return null;

                // Group children by their top offset (i.e. their visual row)
                const rows = [];
                children.forEach((child, i) => {
                    const rect = child.getBoundingClientRect();
                    const existing = rows.find(r => Math.abs(r.top - rect.top) < rect.height * 0.5);
                    if (existing) {
                        existing.items.push({ idx: i, rect });
                    } else {
                        rows.push({ top: rect.top, bottom: rect.bottom, items: [{ idx: i, rect }] });
                    }
                });
                rows.sort((a, b) => a.top - b.top);

                // Find the closest row to the touch Y
                let bestRow = rows[0];
                let bestDist = Infinity;
                for (const row of rows) {
                    const mid = (row.top + row.bottom) / 2;
                    const dist = Math.abs(y - mid);
                    if (dist < bestDist) { bestDist = dist; bestRow = row; }
                }

                // Within that row, find insert position by x midpoint
                for (const { idx, rect } of bestRow.items) {
                    if (x < rect.left + rect.width / 2) return idx;
                }
                // After last item in this row
                return bestRow.items[bestRow.items.length - 1].idx + 1;
            }, []);

            const handleTouchStart = useCallback((e, item, fromTier) => {
                if (!item) return;
                const t = touchDragRef.current;
                if (t.longPressTimer) clearTimeout(t.longPressTimer);

                const touch = e.touches[0];
                const el = e.currentTarget;
                const rect = el.getBoundingClientRect();
                const size = Math.round(rect.width);

                t.startX = touch.clientX;
                t.startY = touch.clientY;

                // Register the non-passive scroll-prevention listener immediately so
                // scroll is blocked from the very first touchmove, not just after the
                // long-press timer fires. It blocks scroll while the long-press is
                // pending OR once dragging is active.
                if (docTouchMoveRef.current) {
                    document.removeEventListener('touchmove', docTouchMoveRef.current);
                }
                const preventScroll = (ev) => {
                    if (touchDragRef.current.longPressTimer || touchDragRef.current.active) {
                        ev.preventDefault();
                    }
                };
                docTouchMoveRef.current = preventScroll;
                document.addEventListener('touchmove', preventScroll, { passive: false });

                t.longPressTimer = setTimeout(() => {
                    t.item = item;
                    t.fromTier = fromTier;
                    t.active = true;
                    t.sourceEl = el;

                    draggedItemRef.current = item;
                    draggedFromRef.current = fromTier;
                    droppedRef.current = false;

                    document.body.classList.add('touch-dragging');
                    el.style.opacity = '0.25';
                    el.style.transform = 'scale(0.95)';

                    createTouchGhost(item, touch.clientX, touch.clientY, size);
                    if (navigator.vibrate) navigator.vibrate(30);
                }, 150);
            }, [createTouchGhost]);

            const handleTouchMove = useCallback((e) => {
                const t = touchDragRef.current;
                if (t.longPressTimer && !t.active) {
                    const touch = e.touches[0];
                    const dx = touch.clientX - t.startX;
                    const dy = touch.clientY - t.startY;
                    if (Math.sqrt(dx * dx + dy * dy) > 14) {
                        clearTimeout(t.longPressTimer);
                        t.longPressTimer = null;
                    }
                    return;
                }
                if (!t.active) return;

                const touch = e.touches[0];
                const ghost = document.getElementById('touch-drag-ghost');
                if (ghost) {
                    ghost.style.left = touch.clientX + 'px';
                    ghost.style.top = touch.clientY + 'px';
                }

                const dropEl = getTouchDropTarget(touch.clientX, touch.clientY);
                if (dropEl) {
                    const tierName = dropEl.getAttribute('data-touch-tier');
                    const insertIdx = computeTouchInsertIndex(dropEl, touch.clientX, touch.clientY);
                    dropInsertIndexRef.current = insertIdx;

                    // Move DOM indicator instantly (no React re-render)
                    const children = Array.from(dropEl.querySelectorAll(':scope > .draggable-item'));
                    if (insertIdx === null || insertIdx >= children.length) {
                        placeTouchIndicator(dropEl, null); // append
                    } else {
                        placeTouchIndicator(dropEl, children[insertIdx]);
                    }

                    // Still update React state for dragOverTier (needed for drop logic)
                    if (t.lastTarget !== dropEl) {
                        if (t.lastTarget) t.lastTarget.classList.remove('drag-over');
                        setDragOverTier(tierName);
                        setDropInsertIndex(insertIdx);
                        dropEl.classList.add('drag-over');
                        t.lastTarget = dropEl;
                    }
                } else {
                    hideTouchIndicator();
                    if (t.lastTarget) { t.lastTarget.classList.remove('drag-over'); t.lastTarget = null; }
                    setDragOverTier(null);
                    setDropInsertIndex(null);
                    dropInsertIndexRef.current = null;
                }

                // Edge-scroll
                const y = touch.clientY;
                const threshold = 80, maxSpeed = 14;
                if (y < threshold) window.scrollBy(0, -Math.round(maxSpeed * (1 - y / threshold)));
                else if (y > window.innerHeight - threshold) window.scrollBy(0, Math.round(maxSpeed * (1 - (window.innerHeight - y) / threshold)));
            }, [getTouchDropTarget, computeTouchInsertIndex]);

            const handleTouchEnd = useCallback((e) => {
                const t = touchDragRef.current;
                if (t.longPressTimer) { clearTimeout(t.longPressTimer); t.longPressTimer = null; }
                // Always clean up scroll-prevention listener, even if drag never went active
                if (docTouchMoveRef.current) {
                    document.removeEventListener('touchmove', docTouchMoveRef.current);
                    docTouchMoveRef.current = null;
                }
                hideTouchIndicator();
                if (!t.active) return;

                const touch = e.changedTouches[0];
                removeTouchGhost();
                document.body.classList.remove('touch-dragging');
                if (t.lastTarget) { t.lastTarget.classList.remove('drag-over'); t.lastTarget = null; }
                if (t.sourceEl) { t.sourceEl.style.opacity = ''; t.sourceEl.style.transform = ''; t.sourceEl = null; }

                const dropEl = getTouchDropTarget(touch.clientX, touch.clientY);
                const toTier = dropEl ? dropEl.getAttribute('data-touch-tier') : null;

                setDragOverTier(null);
                setDropInsertIndex(null);

                if (toTier && t.item) {
                    const item = t.item;
                    const fromTier = t.fromTier;
                    const insertAt = dropInsertIndexRef.current;
                    dropInsertIndexRef.current = null;

                    setTiers(prev => {
                        const nt = JSON.parse(JSON.stringify(prev));
                        const oldIdx = fromTier !== null ? (nt[fromTier] || []).findIndex(i => i.id === item.id) : -1;
                        if (fromTier !== null && nt[fromTier]) {
                            nt[fromTier] = nt[fromTier].filter(i => i.id !== item.id);
                        }
                        if (!nt[toTier]) nt[toTier] = [];
                        if (insertAt === null || insertAt === undefined) {
                            nt[toTier].push(item);
                        } else {
                            let adj = insertAt;
                            if (fromTier === toTier && oldIdx !== -1 && oldIdx < insertAt) adj = Math.max(0, adj - 1);
                            adj = Math.min(adj, nt[toTier].length);
                            nt[toTier].splice(adj, 0, item);
                        }
                        saveToHistory(nt);
                        return nt;
                    });
                }

                t.item = null; t.fromTier = null; t.active = false;
                draggedItemRef.current = null;
                draggedFromRef.current = null;
                droppedRef.current = false;
            }, [getTouchDropTarget, removeTouchGhost, saveToHistory]);

            const startSidebarResize = useCallback((e) => {
                sidebarResizingRef.current = true;
                sidebarResizeStartX.current = e.clientX;
                sidebarResizeStartW.current = sidebarWidth;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                const handle = e.currentTarget;
                handle.classList.add('dragging');
                const onMove = (ev) => {
                    if (!sidebarResizingRef.current) return;
                    const delta = ev.clientX - sidebarResizeStartX.current;
                    const newW = Math.max(200, Math.min(600, sidebarResizeStartW.current + delta));
                    setSidebarWidth(newW);
                };
                const onUp = () => {
                    sidebarResizingRef.current = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                    handle.classList.remove('dragging');
                    setSidebarWidth(w => { localStorage.setItem('tierlist_sidebarWidth', w); return w; });
                    window.removeEventListener('mousemove', onMove);
                    window.removeEventListener('mouseup', onUp);
                };
                window.addEventListener('mousemove', onMove);
                window.addEventListener('mouseup', onUp);
            }, [sidebarWidth]);

            const saveToHistory = useCallback((newTiers) => {
                setHistory(prev => {
                    const nh = prev.slice(0, historyIndex + 1);
                    nh.push(JSON.parse(JSON.stringify(newTiers)));
                    if (nh.length > 50) nh.shift();
                    return nh;
                });
                setHistoryIndex(prev => Math.min(prev + 1, 49));
            }, [historyIndex]);

            const undo = useCallback(() => {
                if (historyIndex > 0) {
                    setTiers(history[historyIndex - 1]);
                    setHistoryIndex(p => p - 1);
                    setUndoToast('Undone');
                    setTimeout(() => setUndoToast(null), 2000);
                }
            }, [history, historyIndex]);

            const redo = useCallback(() => {
                if (historyIndex < history.length - 1) {
                    setTiers(history[historyIndex + 1]);
                    setHistoryIndex(p => p + 1);
                    setUndoToast('Redone');
                    setTimeout(() => setUndoToast(null), 2000);
                }
            }, [history, historyIndex]);

            useEffect(() => {
                if (!showExportMenu) return;
                const handler = (e) => {
                    if (exportMenuRef.current && !exportMenuRef.current.contains(e.target)) setShowExportMenu(false);
                };
                document.addEventListener('mousedown', handler);
                return () => document.removeEventListener('mousedown', handler);
            }, [showExportMenu]);

            useEffect(() => {
                if (!showChartsMenu) return;
                const handler = (e) => {
                    if (chartsMenuRef.current && !chartsMenuRef.current.contains(e.target)) setShowChartsMenu(false);
                };
                document.addEventListener('mousedown', handler);
                return () => document.removeEventListener('mousedown', handler);
            }, [showChartsMenu]);

            useEffect(() => {
                const handle = (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) { e.preventDefault(); undo(); }
                    if (((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'z') || ((e.ctrlKey || e.metaKey) && e.key === 'y')) { e.preventDefault(); redo(); }
                    if ((e.ctrlKey || e.metaKey) && e.key === 'h') { e.preventDefault(); setSidebarCollapsed(p => { if (!p) { setUnrankedInSidebar(false); } return !p; }); }
                    if ((e.ctrlKey || e.metaKey) && e.key === 'e') { e.preventDefault(); exportAsImage(); }
                    if ((e.ctrlKey || e.metaKey) && e.key === 's') { e.preventDefault(); exportData(); }
                    if (e.key === 'Escape') { document.getElementById('helpModal')?.classList.add('hidden'); document.body.style.overflow = 'auto'; }
                };
                window.addEventListener('keydown', handle);
                return () => window.removeEventListener('keydown', handle);
            }, [undo, redo]);

            // ── CHART MANAGEMENT FUNCTIONS ──
            const loadChartData = useCallback((chart) => {
                if (!chart) return;
                isLoadingChartRef.current = true;
                const rt = { ...(chart.tiers || { S: [], A: [], B: [], C: [], D: [], E: [], F: [], unranked: [] }) };
                if (chart.tierNames) chart.tierNames.forEach(n => { if (!rt[n]) rt[n] = []; });
                if (!rt.unranked) rt.unranked = [];
                setTiers(rt);
                saveToHistory(rt);
                setTitle(chart.title || 'My Music Tier List');
                setTempTitle(chart.title || 'My Music Tier List');
                if (chart.tierNames) setTierNames(chart.tierNames);
                if (chart.tierColors) setTierColors(chart.tierColors);
                if (chart.showReorderButtons !== undefined) setShowReorderButtons(chart.showReorderButtons);
                if (chart.songsMode !== undefined) setSongsMode(chart.songsMode);
                if (chart.albumBackup) setAlbumBackup(chart.albumBackup);
                setTimeout(() => { isLoadingChartRef.current = false; }, 100);
            }, [saveToHistory]);

            const createNewChart = useCallback(() => {
                const newId = Date.now().toString();
                const defaultTiers = { S: [], A: [], B: [], C: [], D: [], E: [], F: [], unranked: [] };
                const newChart = {
                    id: newId, name: 'New List',
                    tiers: defaultTiers, tierNames: ['S', 'A', 'B', 'C', 'D', 'E', 'F'],
                    tierColors: { S: '#ff7f7f', A: '#ffbf7f', B: '#ffdf7f', C: '#ffff7f', D: '#bfff7f', E: '#7fff7f', F: '#7fbfff' },
                    title: 'My Music Tier List', songsMode: false, albumBackup: null,
                    showReorderButtons: false, lastModified: Date.now()
                };
                setCharts(prev => {
                    const updated = { ...prev, [newId]: newChart };
                    setCurrentChartId(newId);
                    loadChartData(newChart);
                    try { localStorage.setItem('tierListData', JSON.stringify({ currentChartId: newId, charts: updated })); } catch (e) { }
                    return updated;
                });
            }, [loadChartData]);

            const switchChart = useCallback((id) => {
                if (id === currentChartId) return;
                setCharts(prev => {
                    const fresh = currentStateRef.current;
                    const savedCurrent = {
                        ...prev[currentChartId],
                        tiers: fresh.tiers || prev[currentChartId]?.tiers,
                        title: fresh.title || prev[currentChartId]?.title,
                        tierNames: fresh.tierNames || prev[currentChartId]?.tierNames,
                        tierColors: fresh.tierColors || prev[currentChartId]?.tierColors,
                        songsMode: fresh.songsMode !== undefined ? fresh.songsMode : prev[currentChartId]?.songsMode,
                        albumBackup: fresh.albumBackup !== undefined ? fresh.albumBackup : prev[currentChartId]?.albumBackup,
                        showReorderButtons: fresh.showReorderButtons !== undefined ? fresh.showReorderButtons : prev[currentChartId]?.showReorderButtons,
                        lastModified: Date.now()
                    };
                    const updated = { ...prev, [currentChartId]: savedCurrent };
                    setCurrentChartId(id);
                    loadChartData(updated[id]);
                    try { localStorage.setItem('tierListData', JSON.stringify({ currentChartId: id, charts: updated })); } catch (e) { }
                    return updated;
                });
            }, [currentChartId, loadChartData]);

            const deleteChart = useCallback((id) => {
                setCharts(prev => {
                    const newCharts = { ...prev };
                    delete newCharts[id];
                    let nextId = currentChartId;
                    if (id === currentChartId) {
                        const remaining = Object.keys(newCharts);
                        if (remaining.length > 0) {
                            nextId = remaining[0];
                            setCurrentChartId(nextId);
                            loadChartData(newCharts[nextId]);
                        } else {
                            // Will create a new one after
                            nextId = null;
                        }
                    }
                    try { localStorage.setItem('tierListData', JSON.stringify({ currentChartId: nextId, charts: newCharts })); } catch (e) { }
                    if (!nextId) { setTimeout(createNewChart, 0); }
                    return newCharts;
                });
            }, [currentChartId, loadChartData, createNewChart]);

            const updateChartName = useCallback((id, newName) => {
                setCharts(prev => {
                    const updated = { ...prev, [id]: { ...prev[id], name: newName } };
                    try { localStorage.setItem('tierListData', JSON.stringify({ currentChartId, charts: updated })); } catch (e) { }
                    return updated;
                });
            }, [currentChartId]);

            // On mount: load from localStorage (chart-aware with migration)
            useEffect(() => {
                try {
                    const saved = localStorage.getItem('tierListData');
                    if (saved) {
                        const data = JSON.parse(saved);
                        if (data.charts && data.currentChartId) {
                            // New multi-chart format
                            setCharts(data.charts);
                            setCurrentChartId(data.currentChartId);
                            loadChartData(data.charts[data.currentChartId]);
                        } else if (data.tiers) {
                            // Migrate old single-chart format
                            const newId = Date.now().toString();
                            const migratedChart = {
                                id: newId, name: 'My List',
                                tiers: data.tiers, tierNames: data.tierNames || ['S', 'A', 'B', 'C', 'D', 'E', 'F'],
                                tierColors: data.tierColors || { S: '#ff7f7f', A: '#ffbf7f', B: '#ffdf7f', C: '#ffff7f', D: '#bfff7f', E: '#7fff7f', F: '#7fbfff' },
                                title: data.title || 'My Music Tier List', songsMode: data.songsMode || false,
                                albumBackup: data.albumBackup || null, showReorderButtons: data.showReorderButtons !== undefined ? data.showReorderButtons : true,
                                lastModified: Date.now()
                            };
                            const newCharts = { [newId]: migratedChart };
                            setCharts(newCharts);
                            setCurrentChartId(newId);
                            loadChartData(migratedChart);
                            localStorage.setItem('tierListData', JSON.stringify({ currentChartId: newId, charts: newCharts }));
                        } else {
                            createNewChart();
                        }
                    } else {
                        createNewChart();
                    }
                } catch (e) { createNewChart(); }
            }, []);

            // Auto-save current chart state
            useEffect(() => {
                if (!currentChartId || isLoadingChartRef.current) return;
                const currentChartData = { tiers, title, tierNames, tierColors, showReorderButtons, songsMode, albumBackup };
                currentStateRef.current = currentChartData;
                setCharts(prev => {
                    if (!prev[currentChartId]) return prev;
                    const updated = { ...prev, [currentChartId]: { ...prev[currentChartId], ...currentChartData, lastModified: Date.now() } };
                    try { localStorage.setItem('tierListData', JSON.stringify({ currentChartId, charts: updated })); } catch (e) { }
                    return updated;
                });
            }, [tiers, title, tierNames, tierColors, showReorderButtons, songsMode, albumBackup, currentChartId]);

            useEffect(() => {
                if (editingTitle && titleInputRef.current) { titleInputRef.current.focus(); titleInputRef.current.select(); }
            }, [editingTitle]);

            useEffect(() => {
                const allItems = Object.values(tiers).flat().filter(Boolean);
                if (allItems.length === 0) { setBgHasItems(false); return; }
                setBgHasItems(true);
                const extract = async () => {
                    const colors = [];
                    for (const item of allItems.slice(-2)) {
                        try {
                            if (item.custom) { colors.push(item.color); continue; }
                            const img = new Image(); img.crossOrigin = 'Anonymous'; img.src = item.image;
                            await new Promise((res, rej) => { img.onload = res; img.onerror = rej; setTimeout(rej, 3000); });
                            const c = document.createElement('canvas'); c.width = 50; c.height = 50;
                            const ctx = c.getContext('2d'); ctx.drawImage(img, 0, 0, 50, 50);
                            const d = ctx.getImageData(0, 0, 50, 50).data;
                            let r = 0, g = 0, b = 0;
                            for (let i = 0; i < d.length; i += 4) { r += d[i]; g += d[i + 1]; b += d[i + 2]; }
                            const n = d.length / 4;
                            colors.push(`rgb(${Math.floor(r / n)},${Math.floor(g / n)},${Math.floor(b / n)})`);
                        } catch (e) { }
                    }
                    if (colors.length > 0) { if (colors.length === 1) colors.push(colors[0]); setBgColors(colors); }
                };
                extract();
            }, [tiers]);

            const searchAlbums = useCallback(async () => {
                if (!searchQuery.trim()) return;
                setLoading(true); setSearchResults([]);
                // Build search term including optional artist/year
                const term = [searchQuery.trim(), searchArtistFilter.trim()].filter(Boolean).join(' ');
                try {
                    let lastfmCanonical = [];
                    try {
                        const lfRes = await fetch(`https://ws.audioscrobbler.com/2.0/?method=album.search&album=${encodeURIComponent(term)}&api_key=33866e12a02528e0bb9211bd2f351c28&format=json&limit=30`);
                        const lfData = await lfRes.json();
                        if (lfData.results?.albummatches?.album) {
                            const albums = Array.isArray(lfData.results.albummatches.album) ? lfData.results.albummatches.album : [lfData.results.albummatches.album];
                            const enriched = await Promise.all(albums.filter(a => {
                                const img = a.image?.find(i => i.size === 'extralarge')?.['#text'] || '';
                                return img && img.length > 20 && !img.includes('2a96cbd8b46e442fc41c2b86b821562f') && !img.includes('c6f59c1e5e7240a4c0d427abd71f3dbb');
                            }).slice(0, 15).map(async a => {
                                try {
                                    const iRes = await fetch(`https://ws.audioscrobbler.com/2.0/?method=album.getinfo&api_key=33866e12a02528e0bb9211bd2f351c28&artist=${encodeURIComponent(a.artist)}&album=${encodeURIComponent(a.name)}&format=json`);
                                    const iData = await iRes.json();
                                    const pc = parseInt(iData.album?.playcount || '0'), ls = parseInt(iData.album?.listeners || '0');
                                    return { title: a.name, artist: a.artist, image: a.image.find(i => i.size === 'extralarge')?.['#text'] || '', playcount: pc, listeners: ls, popularityScore: pc + (ls * 3) };
                                } catch (e) { return null; }
                            }));
                            lastfmCanonical = enriched.filter(Boolean);
                        }
                    } catch (e) { }

                    // iTunes search — include artist in term for better results
                    const itData = await jsonpRequest(`https://itunes.apple.com/search?term=${encodeURIComponent(term)}&entity=album&limit=200`);
                    let itResults = [];
                    if (itData.results) {
                        itResults = itData.results.filter(i => i.wrapperType === 'collection').map(a => ({
                            id: `itunes-${a.collectionId}`, title: a.collectionName, artist: a.artistName,
                            image: a.artworkUrl100.replace('100x100', '600x600'), year: a.releaseDate ? new Date(a.releaseDate).getFullYear() : '',
                            collectionId: a.collectionId, trackCount: a.trackCount || 0, primaryGenreName: a.primaryGenreName || '', source: 'iTunes'
                        }));
                    }

                    // Filter by year if provided
                    const yearFilter = searchYearFilter.trim();
                    if (yearFilter) {
                        itResults = itResults.filter(a => String(a.year) === yearFilter);
                    }

                    const merged = itResults.map(it => {
                        const lfm = lastfmCanonical.find(l => normalizeString(it.title) === normalizeString(l.title) && normalizeString(it.artist) === normalizeString(l.artist));
                        return { ...it, playcount: lfm?.playcount || 0, listeners: lfm?.listeners || 0, popularityScore: lfm?.popularityScore || 0 };
                    });
                    const lfmOnly = lastfmCanonical.filter(l => !merged.some(m => normalizeString(m.title) === normalizeString(l.title) && normalizeString(m.artist) === normalizeString(l.artist)))
                        .filter(l => !yearFilter || String(l.year) === yearFilter)
                        .map(l => ({ id: `lastfm-${Math.random()}-${l.title}`, ...l, year: '', source: 'Last.fm' }));
                    const all = [...merged, ...lfmOnly];
                    const seen = new Map(); const unique = [];
                    for (const a of all) { const k = `${normalizeString(a.title)}|||${normalizeString(a.artist)}`; if (!seen.has(k)) { seen.set(k, true); unique.push(a); } }
                    const qn = normalizeString(searchQuery);
                    const sorted = unique.sort((a, b) => {
                        const an = normalizeString(a.title), bn = normalizeString(b.title);
                        if (an === qn && bn !== qn) return -1; if (an !== qn && bn === qn) return 1;
                        if (an === qn && bn === qn) return b.popularityScore - a.popularityScore;
                        if (an.startsWith(qn) && !bn.startsWith(qn)) return -1; if (!an.startsWith(qn) && bn.startsWith(qn)) return 1;
                        if (an.includes(qn) && !bn.includes(qn)) return -1; if (!an.includes(qn) && bn.includes(qn)) return 1;
                        if (a.popularityScore !== b.popularityScore) return b.popularityScore - a.popularityScore;
                        return (b.year || 0) - (a.year || 0);
                    });
                    setSearchResults(sorted.slice(0, 40));
                } catch (e) { console.error(e); }
                setLoading(false);
            }, [searchQuery, searchArtistFilter, searchYearFilter]);

            const searchArtistForAlbums = useCallback(async () => {
                if (!artistSearchQuery.trim()) return;
                setLoadingArtist(true); setArtistSuggestions([]);
                try {
                    const data = await jsonpRequest(`https://itunes.apple.com/search?term=${encodeURIComponent(artistSearchQuery)}&entity=musicArtist&limit=20`);
                    if (data.results) {
                        const seen = new Set();
                        setArtistSuggestions(data.results.filter(i => {
                            if (i.wrapperType !== 'artist') return false;
                            const n = i.artistName.toLowerCase(); if (seen.has(n)) return false; seen.add(n); return true;
                        }));
                    }
                } catch (e) { }
                setLoadingArtist(false);
            }, [artistSearchQuery]);

            const selectArtistAndLoadAlbums = useCallback(async (artist) => {
                setLoadingArtist(true); setSelectedArtist(artist); setArtistAlbums([]);
                try {
                    const data = await jsonpRequest(`https://itunes.apple.com/lookup?id=${artist.artistId}&entity=album&limit=200`);
                    if (data.results && data.results.length > 1) {
                        setArtistAlbums(data.results.slice(1).filter(i => i.wrapperType === 'collection').map(a => ({
                            id: `itunes-${a.collectionId}`, title: a.collectionName, artist: a.artistName,
                            image: a.artworkUrl100.replace('100x100', '600x600'), year: a.releaseDate ? new Date(a.releaseDate).getFullYear() : '',
                            collectionId: a.collectionId, source: 'iTunes'
                        })).sort((a, b) => (b.year || 0) - (a.year || 0)));
                    }
                } catch (e) { }
                setLoadingArtist(false);
            }, []);

            const selectAlbumAndLoadSongs = useCallback(async (album) => {
                setLoadingSongs(true); setSelectedAlbum(album); setAlbumSongs([]);
                try {
                    let collectionId = album.collectionId;
                    // If no collectionId (e.g. Last.fm result), look it up via iTunes search
                    if (!collectionId) {
                        const searchTerm = `${album.title} ${album.artist}`;
                        const data = await jsonpRequest(`https://itunes.apple.com/search?term=${encodeURIComponent(searchTerm)}&entity=album&limit=5`);
                        if (data.results && data.results.length > 0) {
                            const match = data.results.find(r => r.wrapperType === 'collection') || data.results[0];
                            if (match) collectionId = match.collectionId;
                        }
                    }
                    if (!collectionId) { setLoadingSongs(false); return; }
                    const data = await jsonpRequest(`https://itunes.apple.com/lookup?id=${collectionId}&entity=song&limit=200`);
                    if (data.results && data.results.length > 1) {
                        setAlbumSongs(data.results.slice(1).filter(i => i.wrapperType === 'track')
                            .sort((a, b) => (a.trackNumber || 0) - (b.trackNumber || 0))
                            .map(t => ({
                                id: `track-${t.trackId}`, title: t.trackName, artist: t.artistName,
                                image: album.image, albumTitle: album.title,
                                trackNumber: t.trackNumber, collectionId: collectionId
                            })));
                    }
                } catch (e) { console.error('Failed to load songs:', e); }
                setLoadingSongs(false);
            }, []);

            const fetchAlbumTracks = useCallback(async (album) => {
                try {
                    let collectionId = album.collectionId;
                    if (!collectionId) {
                        // Try to find via iTunes search
                        const data = await jsonpRequest(`https://itunes.apple.com/search?term=${encodeURIComponent(album.title + ' ' + album.artist)}&entity=album&limit=5`);
                        const match = data.results?.find(r => r.wrapperType === 'collection');
                        if (match) collectionId = match.collectionId;
                    }
                    if (!collectionId) return [];
                    const data = await jsonpRequest(`https://itunes.apple.com/lookup?id=${collectionId}&entity=song&limit=200`);
                    if (data.results && data.results.length > 1) {
                        return data.results.slice(1).filter(i => i.wrapperType === 'track')
                            .sort((a, b) => (a.trackNumber || 0) - (b.trackNumber || 0))
                            .map(t => ({
                                id: `track-${t.trackId}`, title: t.trackName, artist: t.artistName,
                                image: album.image, albumTitle: album.title,
                                trackNumber: t.trackNumber, collectionId: collectionId
                            }));
                    }
                } catch (e) { }
                return [];
            }, []);

            // ── Drag handlers ──────────────────────────────────────────────────────
            const handleDragStart = useCallback((e, item, fromTier) => {
                setDraggedItem(item);
                setDraggedFrom(fromTier);
                draggedItemRef.current = item;
                draggedFromRef.current = fromTier;
                droppedRef.current = false;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', item.id);
                requestAnimationFrame(() => {
                    if (e.target) e.target.classList.add('dragging');
                });
            }, []);

            const handleDragEnd = useCallback((e) => {
                if (e.target) e.target.classList.remove('dragging');
                setDragOverTier(null);
                setDropInsertIndex(null);
                setDraggedItem(null);
                setDraggedFrom(null);
                draggedItemRef.current = null;
                draggedFromRef.current = null;
                if (scrollIntervalRef.current) { clearInterval(scrollIntervalRef.current); scrollIntervalRef.current = null; }
            }, []);

            // Called on the tier container (background) — computes insert index from child positions
            const handleTierDragOver = useCallback((e, tier) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                setDragOverTier(tier);

                // Compute insert position by scanning child draggable-item elements
                const container = e.currentTarget;
                const children = Array.from(container.querySelectorAll(':scope > .draggable-item'));
                let insertIdx = null;
                if (children.length > 0) {
                    let found = false;
                    for (let i = 0; i < children.length; i++) {
                        const rect = children[i].getBoundingClientRect();
                        if (e.clientX < rect.left + rect.width / 2) {
                            insertIdx = i;
                            found = true;
                            break;
                        }
                    }
                    if (!found) insertIdx = children.length; // after last child
                }
                setDropInsertIndex(insertIdx);
                dropInsertIndexRef.current = insertIdx;

                const y = e.clientY;
                if (scrollIntervalRef.current) { clearInterval(scrollIntervalRef.current); scrollIntervalRef.current = null; }
                if (y < 100) scrollIntervalRef.current = setInterval(() => window.scrollBy(0, -10), 16);
                else if (y > window.innerHeight - 100) scrollIntervalRef.current = setInterval(() => window.scrollBy(0, 10), 16);
            }, []);

            // Called on individual item wrappers — computes precise insert index
            const handleItemDragOver = useCallback((e, tier, itemIdx) => {
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'move';
                setDragOverTier(tier);
                const rect = e.currentTarget.getBoundingClientRect();
                const isLeftHalf = e.clientX < rect.left + rect.width / 2;
                // Insert before itemIdx (left half) or after (right half = before itemIdx+1)
                const idx = isLeftHalf ? itemIdx : itemIdx + 1;
                setDropInsertIndex(idx);
                dropInsertIndexRef.current = idx;
            }, []);

            const handleDragLeave = useCallback((e) => {
                if (!e.currentTarget.contains(e.relatedTarget)) {
                    setDragOverTier(null);
                    setDropInsertIndex(null);
                    dropInsertIndexRef.current = null;
                }
                if (scrollIntervalRef.current) { clearInterval(scrollIntervalRef.current); scrollIntervalRef.current = null; }
            }, []);

            const handleDrop = useCallback((e, toTier) => {
                e.preventDefault();
                e.stopPropagation();
                if (droppedRef.current) return; // already handled — ignore bubbled duplicate
                droppedRef.current = true;
                const item = draggedItemRef.current;
                const fromTier = draggedFromRef.current;
                const insertAt = dropInsertIndexRef.current;
                setDragOverTier(null);
                setDropInsertIndex(null);
                dropInsertIndexRef.current = null;
                if (!item) return;

                setTiers(prev => {
                    const nt = JSON.parse(JSON.stringify(prev));
                    const oldIdx = fromTier !== null ? (nt[fromTier] || []).findIndex(i => i.id === item.id) : -1;

                    // Remove from source
                    if (fromTier !== null && nt[fromTier]) {
                        nt[fromTier] = nt[fromTier].filter(i => i.id !== item.id);
                    }
                    if (!nt[toTier]) nt[toTier] = [];

                    if (insertAt === null || insertAt === undefined) {
                        nt[toTier].push(item);
                    } else {
                        let adj = insertAt;
                        if (fromTier === toTier && oldIdx !== -1 && oldIdx < insertAt) {
                            adj = Math.max(0, adj - 1);
                        }
                        adj = Math.min(adj, nt[toTier].length);
                        nt[toTier].splice(adj, 0, item);
                    }
                    saveToHistory(nt);
                    return nt;
                });
            }, [saveToHistory]);

            const removeItem = useCallback((tier, itemId) => {
                setTiers(prev => { const nt = { ...prev, [tier]: prev[tier].filter(i => i.id !== itemId) }; saveToHistory(nt); return nt; });
            }, [saveToHistory]);

            const addItemToUnranked = useCallback((item) => {
                // Don't add duplicates
                setTiers(prev => {
                    const allIds = Object.values(prev).flat().map(i => i.id);
                    if (allIds.includes(item.id)) return prev;
                    const nt = { ...prev, unranked: [...prev.unranked, item] };
                    saveToHistory(nt);
                    return nt;
                });
            }, [saveToHistory]);

            const moveItemLeft = useCallback((tier, itemId) => {
                setTiers(prev => {
                    const nt = { ...prev };
                    const arr = [...(nt[tier] || [])];
                    const idx = arr.findIndex(i => i.id === itemId);
                    if (idx <= 0) return prev;
                    [arr[idx - 1], arr[idx]] = [arr[idx], arr[idx - 1]];
                    nt[tier] = arr;
                    saveToHistory(nt);
                    return nt;
                });
            }, [saveToHistory]);

            const moveItemRight = useCallback((tier, itemId) => {
                setTiers(prev => {
                    const nt = { ...prev };
                    const arr = [...(nt[tier] || [])];
                    const idx = arr.findIndex(i => i.id === itemId);
                    if (idx < 0 || idx >= arr.length - 1) return prev;
                    [arr[idx], arr[idx + 1]] = [arr[idx + 1], arr[idx]];
                    nt[tier] = arr;
                    saveToHistory(nt);
                    return nt;
                });
            }, [saveToHistory]);

            const openRenameModal = useCallback((tier, item) => { setRenameItem({ tier, item }); setRenameTitle(item.title); setRenameModalOpen(true); }, []);
            const confirmRename = useCallback(() => {
                if (!renameItem) return;
                setTiers(prev => ({ ...prev, [renameItem.tier]: prev[renameItem.tier].map(i => i.id === renameItem.item.id ? { ...i, title: renameTitle } : i) }));
                setRenameModalOpen(false); setRenameItem(null); setRenameTitle('');
            }, [renameItem, renameTitle]);

            const createCustomTile = useCallback(() => {
                if (!newTileTitle.trim()) return;
                const tile = { id: `custom-${Date.now()}-${Math.random()}`, title: newTileTitle, image: `data:image/svg+xml,${encodeURIComponent(`<svg width="200" height="200" xmlns="http://www.w3.org/2000/svg"><rect width="200" height="200" fill="${newTileColor}"/></svg>`)}`, artist: 'Custom', custom: true, color: newTileColor };
                setTiers(prev => ({ ...prev, unranked: [...prev.unranked, tile] }));
                setCreateTileModalOpen(false); setNewTileTitle(''); setNewTileColor('#8b5cf6');
            }, [newTileTitle, newTileColor]);

            const toggleSongsMode = useCallback(() => setModeWarningOpen(true), []);
            const confirmModeSwitch = useCallback(async () => {
                setModeWarningOpen(false);
                if (!songsMode) {
                    // Album → Songs: backup current state (including ranked albums), then convert all to tracks
                    const backup = JSON.parse(JSON.stringify(tiers));
                    setAlbumBackup(backup);
                    const nt = {}; tierNames.forEach(n => { nt[n] = []; }); nt.unranked = [];
                    const seen = new Set();
                    // Convert all tiers (not just unranked) — keep tier structure, put tracks in same tier
                    for (const tn of [...tierNames, 'unranked']) {
                        const tierAlbums = tiers[tn] || [];
                        for (const album of tierAlbums) {
                            const tracks = await fetchAlbumTracks(album);
                            for (const t of tracks) {
                                const k = `${normalizeString(t.title)}|||${normalizeString(t.artist)}|||${t.collectionId}`;
                                if (!seen.has(k)) { seen.add(k); nt[tn].push(t); }
                            }
                        }
                    }
                    setTiers(nt);
                    setSongsMode(true);
                } else {
                    // Songs → Albums: restore from backup
                    if (albumBackup) {
                        const nt = {};
                        tierNames.forEach(n => { nt[n] = albumBackup[n] || []; });
                        nt.unranked = albumBackup.unranked || [];
                        setTiers(nt);
                        setAlbumBackup(null);
                    }
                    setSongsMode(false);
                }
            }, [songsMode, tiers, albumBackup, fetchAlbumTracks, tierNames]);

            const bulkMoveTiers = useCallback(() => {
                if (!bulkMoveFrom || !bulkMoveTo || bulkMoveFrom === bulkMoveTo) { alert('Select different source and destination'); return; }
                setTiers(prev => { const nt = { ...prev }; nt[bulkMoveTo] = [...(nt[bulkMoveTo] || []), ...nt[bulkMoveFrom]]; nt[bulkMoveFrom] = []; saveToHistory(nt); return nt; });
                setBulkMoveFrom(''); setBulkMoveTo('');
            }, [bulkMoveFrom, bulkMoveTo, saveToHistory]);

            const exportAsImage = useCallback(async () => {
                // Collect all items currently ranked
                const allItems = [...tierNames.flatMap(tn => tiers[tn] || []), ...(tiers.unranked || [])];
                const uniqueSrcs = [];
                allItems.forEach(a => { if (a.image && !uniqueSrcs.includes(a.image)) uniqueSrcs.push(a.image); });

                // Load all images as blob URLs to sidestep CORS canvas-taint (same approach as topsters)
                const imgMap = {};
                const blobUrls = {};
                await Promise.all(uniqueSrcs.map(src =>
                (src.startsWith('data:')
                    ? new Promise(res => { const img = new window.Image(); img.onload = () => { imgMap[src] = img; res(); }; img.onerror = res; img.src = src; })
                    : fetch(src).then(r => r.blob()).then(blob => {
                        const bUrl = URL.createObjectURL(blob);
                        blobUrls[src] = bUrl;
                        return new Promise(res => { const img = new window.Image(); img.onload = () => { imgMap[src] = img; res(); }; img.onerror = res; img.src = bUrl; });
                    }).catch(() => { })
                )
                ));

                // Draw tier list onto canvas
                const CELL = 80, GAP = 4, PAD = 32, LABEL_W = 60;
                const TITLE_H = title ? 56 : 0;
                const rows = tierNames;
                const rawMaxCols = Math.max(1, ...rows.map(tn => (tiers[tn] || []).length));
                const UNRANKED = tiers.unranked || [];
                const tierH = CELL + GAP;

                // Find smallest colsCap (min 4) that makes canvas taller than wide (portrait-friendly)
                const calcDimensions = (colsCap) => {
                    const w = PAD * 2 + LABEL_W + GAP + colsCap * CELL + (colsCap - 1) * GAP;
                    const wrappedTierRows = rows.reduce((sum, tn) => sum + Math.max(1, Math.ceil((tiers[tn] || []).length / colsCap)), 0);
                    const uCols = Math.max(1, Math.floor((w - PAD * 2) / (CELL + GAP)));
                    const uH = UNRANKED.length > 0 ? (Math.ceil(UNRANKED.length / uCols) * (CELL + GAP) + 28 + GAP * 2) : 0;
                    const h = PAD * 2 + TITLE_H + wrappedTierRows * tierH + (rows.length > 0 ? GAP : 0) + uH;
                    return { w, h, uCols };
                };

                let colsCap = rawMaxCols;
                for (let c = rawMaxCols; c >= 4; c--) {
                    const { w, h } = calcDimensions(c);
                    colsCap = c;
                    if (h >= w) break;
                }
                const { w: canvasW, h: canvasH, uCols: exportUnrankedCols } = calcDimensions(colsCap);

                const SCALE = 2;
                const canvas = document.createElement('canvas');
                canvas.width = canvasW * SCALE; canvas.height = canvasH * SCALE;
                const ctx = canvas.getContext('2d');
                ctx.scale(SCALE, SCALE);

                // Background
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, canvasW, canvasH);

                // Title
                if (title) {
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 24px -apple-system,BlinkMacSystemFont,sans-serif';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(title, canvasW / 2, PAD + TITLE_H / 2);
                }

                if (!ctx.roundRect) ctx.roundRect = function (x, y, w, h, r) { this.beginPath(); this.moveTo(x + r, y); this.lineTo(x + w - r, y); this.quadraticCurveTo(x + w, y, x + w, y + r); this.lineTo(x + w, y + h - r); this.quadraticCurveTo(x + w, y + h, x + w - r, y + h); this.lineTo(x + r, y + h); this.quadraticCurveTo(x, y + h, x, y + h - r); this.lineTo(x, y + r); this.quadraticCurveTo(x, y, x + r, y); this.closePath(); };

                const drawRoundedImage = (img, x, y, w, h, r) => {
                    ctx.save();
                    ctx.beginPath();
                    ctx.roundRect(x, y, w, h, r);
                    ctx.clip();
                    if (img) ctx.drawImage(img, x, y, w, h);
                    else { ctx.fillStyle = '#333'; ctx.fill(); }
                    ctx.restore();
                };

                let y = PAD + TITLE_H;
                rows.forEach(tn => {
                    const color = tierColors[tn] || '#888';
                    const items = tiers[tn] || [];
                    const numSubRows = Math.max(1, Math.ceil(items.length / colsCap));
                    const rowTotalH = numSubRows * CELL + (numSubRows - 1) * GAP;
                    const rowBgW = canvasW - PAD * 2 - LABEL_W - GAP;

                    // Label spans full wrapped height
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.roundRect(PAD, y, LABEL_W, rowTotalH, 6); ctx.fill();
                    ctx.fillStyle = '#000000';
                    ctx.font = 'bold 22px -apple-system,BlinkMacSystemFont,sans-serif';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(tn, PAD + LABEL_W / 2, y + rowTotalH / 2);
                    // Row background
                    ctx.fillStyle = 'rgba(255,255,255,0.05)';
                    ctx.beginPath(); ctx.roundRect(PAD + LABEL_W + GAP, y, rowBgW, rowTotalH, [0, 6, 6, 0]); ctx.fill();
                    // Items (wrapped across colsCap columns)
                    items.forEach((item, idx) => {
                        const col = idx % colsCap;
                        const subRow = Math.floor(idx / colsCap);
                        const x = PAD + LABEL_W + GAP + col * (CELL + GAP);
                        const iy = y + subRow * (CELL + GAP);
                        const img = imgMap[item.image];
                        drawRoundedImage(img, x, iy, CELL, CELL, 4);
                        // Song overlay
                        if (item.trackNumber !== undefined) {
                            ctx.fillStyle = 'rgba(0,0,0,0.6)';
                            ctx.beginPath(); ctx.roundRect(x, iy, CELL, CELL, 4); ctx.fill();
                            ctx.fillStyle = '#fff';
                            ctx.font = 'bold 10px -apple-system,BlinkMacSystemFont,sans-serif';
                            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                            const words = item.title.split(' ');
                            let line = '', lines = [];
                            words.forEach(w => { const t = line ? line + ' ' + w : w; if (ctx.measureText(t).width > CELL - 8) { if (line) lines.push(line); line = w; } else { line = t; } });
                            if (line) lines.push(line);
                            lines.slice(0, 3).forEach((l, li) => { ctx.fillText(l, x + CELL / 2, iy + CELL / 2 + (li - (Math.min(lines.length, 3) - 1) / 2) * 12); });
                        }
                    });
                    y += rowTotalH + GAP;
                });

                // Unranked section
                if (UNRANKED.length > 0) {
                    y += GAP;
                    ctx.fillStyle = 'rgba(255,255,255,0.7)';
                    ctx.font = 'bold 14px -apple-system,BlinkMacSystemFont,sans-serif';
                    ctx.textAlign = 'left'; ctx.textBaseline = 'top';
                    ctx.fillText('Unranked', PAD, y);
                    y += 22;
                    UNRANKED.forEach((item, idx) => {
                        const col = idx % exportUnrankedCols;
                        const row = Math.floor(idx / exportUnrankedCols);
                        const x = PAD + col * (CELL + GAP);
                        const iy = y + row * (CELL + GAP);
                        drawRoundedImage(imgMap[item.image], x, iy, CELL, CELL, 4);
                    });
                }

                // Download
                canvas.toBlob(blob => {
                    Object.values(blobUrls).forEach(URL.revokeObjectURL);
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.download = `tier-list-${Date.now()}.png`;
                    a.href = url; a.click();
                    URL.revokeObjectURL(url);
                }, 'image/png');
            }, [tiers, tierNames, tierColors, title]);

            const exportData = useCallback(() => {
                const data = { tiers: albumBackup || tiers, title, tierNames, tierColors };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `tier-list-${Date.now()}.json`; a.click(); URL.revokeObjectURL(url);
            }, [tiers, albumBackup, title, tierNames, tierColors]);

            const exportToCSV = useCallback(() => {
                let csv = 'Tier,Title,Artist,Year\n';
                tierNames.forEach(n => (tiers[n] || []).forEach(i => { csv += `${n},"${(i.title || '').replace(/"/g, '""')}","${(i.artist || '').replace(/"/g, '""')}",${i.year || ''}\n`; }));
                (tiers.unranked || []).forEach(i => { csv += `Unranked,"${(i.title || '').replace(/"/g, '""')}","${(i.artist || '').replace(/"/g, '""')}",${i.year || ''}\n`; });
                const blob = new Blob([csv], { type: 'text/csv' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `tier-list-${Date.now()}.csv`; a.click(); URL.revokeObjectURL(url);
            }, [tiers, tierNames]);

            const importData = useCallback((event) => {
                const file = event.target.files[0]; if (!file) return;
                const reader = new FileReader();
                reader.onload = e => {
                    try {
                        const data = JSON.parse(e.target.result); if (!data.tiers) { alert('Invalid file'); return; }
                        setSongsMode(false); setAlbumBackup(null);
                        if (data.tierNames) setTierNames(data.tierNames);
                        if (data.tierColors) setTierColors(data.tierColors);
                        const rt = { ...data.tiers };
                        (data.tierNames || DEFAULT_TIERS).forEach(n => { if (!rt[n]) rt[n] = []; });
                        if (!rt.unranked) rt.unranked = [];
                        setTiers(rt); setTitle(data.title || 'My Music Tier List'); setTempTitle(data.title || 'My Music Tier List'); saveToHistory(rt);
                    } catch (err) { alert('Failed to import: ' + err.message); }
                };
                reader.readAsText(file); event.target.value = '';
            }, [saveToHistory]);

            const clearAll = useCallback(() => {
                setShowConfirm(false);
                const nt = {}; tierNames.forEach(n => { nt[n] = []; }); nt.unranked = [];
                setTiers(nt); setAlbumBackup(null); setSongsMode(false); saveToHistory(nt);
            }, [tierNames, saveToHistory]);

            const resetGrid = useCallback(() => {
                if (!confirm('Reset to default S-F tiers? All items move to unranked.')) return;
                const allItems = []; Object.values(tiers).forEach(t => allItems.push(...t));
                setTierNames(DEFAULT_TIERS); setTierColors(TIER_COLORS);
                const nt = { S: [], A: [], B: [], C: [], D: [], E: [], F: [], unranked: allItems };
                setTiers(nt); saveToHistory(nt);
            }, [tiers, saveToHistory]);

            const addNewTier = useCallback(() => {
                if (tierNames.length >= 26) { alert('Max 26 tiers'); return; }
                const n = String.fromCharCode(65 + tierNames.length);
                setTierNames(p => [...p, n]);
                setTierColors(p => ({ ...p, [n]: `#${Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0')}` }));
                setTiers(p => ({ ...p, [n]: [] }));
            }, [tierNames]);

            const removeTier = useCallback((tn) => {
                if (tierNames.length <= 1) { alert('Must have at least one tier'); return; }
                if (!confirm(`Remove tier ${tn}? Items move to unranked.`)) return;
                setTiers(prev => { const nt = { ...prev }; const items = nt[tn] || []; delete nt[tn]; nt.unranked = [...nt.unranked, ...items]; saveToHistory(nt); return nt; });
                setTierNames(p => p.filter(n => n !== tn));
                setTierColors(p => { const nc = { ...p }; delete nc[tn]; return nc; });
            }, [tierNames, saveToHistory]);

            const renameTier = useCallback((oldName, newName) => {
                if (!newName.trim() || oldName === newName) { setEditingTierName(null); return; }
                if (tierNames.includes(newName)) { alert('Name exists'); return; }
                setTierNames(p => p.map(n => n === oldName ? newName : n));
                setTiers(p => { const nt = { ...p }; nt[newName] = nt[oldName]; delete nt[oldName]; return nt; });
                setTierColors(p => { const nc = { ...p }; nc[newName] = nc[oldName]; delete nc[oldName]; return nc; });
                setEditingTierName(null);
            }, [tierNames]);

            const handleTitleSave = useCallback((val) => {
                setEditingTitle(false);
                if (val.trim()) { setTitle(val.trim()); setTempTitle(val.trim()); }
                else setTempTitle(title);
            }, [title]);

            // ── Render tile ─────────────────────────────────────────────────────────
            const renderTierItems = (tierName, items) => {
                const isDragging = !!draggedItemRef.current;
                const result = [];
                items.forEach((item, idx) => {
                    // Show gap indicator BEFORE this item if dropInsertIndex === idx
                    if (isDragging && dragOverTier === tierName && dropInsertIndex === idx) {
                        result.push(<div key={`gap-${idx}`} className="drop-gap-indicator" />);
                    }
                    result.push(renderTile(item, tierName, idx));
                });
                // Gap at the end
                if (isDragging && dragOverTier === tierName && (dropInsertIndex === items.length || (dropInsertIndex === null && items.length > 0))) {
                    result.push(<div key="gap-end" className="drop-gap-indicator" />);
                }
                return result;
            };

            const renderTile = (item, tier, idx) => (
                <div
                    key={item.id}
                    className="group relative draggable-item flex-shrink-0"
                    draggable
                    onDragStart={(e) => handleDragStart(e, item, tier)}
                    onDragEnd={handleDragEnd}
                    onDragOver={(e) => handleItemDragOver(e, tier, idx)}
                    onDrop={(e) => handleDrop(e, tier)}
                    onContextMenu={(e) => { e.preventDefault(); openRenameModal(tier, item); }}
                    onTouchStart={(e) => handleTouchStart(e, item, tier)}
                    onTouchMove={handleTouchMove}
                    onTouchEnd={handleTouchEnd}
                >
                    {item.custom ? (
                        /* Custom colour tile — solid background + title text */
                        <div className="w-16 h-16 md:w-20 md:h-20 rounded overflow-hidden relative flex items-center justify-center" style={{ backgroundColor: item.color || '#8b5cf6' }}>
                            <span className="text-white text-[10px] font-semibold text-center leading-tight px-1 break-words" style={{ wordBreak: 'break-word', maxWidth: '100%' }}>{item.title}</span>
                        </div>
                    ) : item.trackNumber !== undefined ? (
                        /* Song tile — blurred album art + track name overlay */
                        <div className="w-16 h-16 md:w-20 md:h-20 rounded overflow-hidden relative">
                            <img src={item.image} alt={item.title} className="song-bg" />
                            <div className="relative w-full h-full flex items-center justify-center p-1">
                                <span className="song-title text-white text-[10px] text-center leading-tight line-clamp-3">{item.title}</span>
                            </div>
                        </div>
                    ) : (
                        /* Regular album tile */
                        <img src={item.image} alt={item.title} className="w-16 h-16 md:w-20 md:h-20 object-cover rounded block" />
                    )}
                    <div className="absolute top-1 right-1 flex gap-1 opacity-0 group-hover:opacity-100 transition-all z-10">
                        <button onClick={() => openRenameModal(tier, item)} className="bg-blue-500 hover:bg-blue-600 text-white p-1 rounded" title="Rename"><Pencil className="w-3 h-3" /></button>
                        <button onClick={() => removeItem(tier, item.id)} className="bg-red-500 hover:bg-red-600 text-white p-1 rounded" title="Remove"><Trash className="w-3 h-3" /></button>
                    </div>
                    {showReorderButtons && (
                        <div className="absolute bottom-1 right-1 flex gap-1 opacity-0 group-hover:opacity-100 transition-all z-10">
                            <button onClick={() => moveItemLeft(tier, item.id)} className="bg-purple-500 hover:bg-purple-600 text-white p-1 rounded" title="Move left one"><ArrowLeft className="w-3 h-3" /></button>
                            <button onClick={() => moveItemRight(tier, item.id)} className="bg-purple-500 hover:bg-purple-600 text-white p-1 rounded" title="Move right one"><ArrowRight className="w-3 h-3" /></button>
                        </div>
                    )}
                </div>
            );

            const renderUnrankedSection = () => (
                <div
                    onDragOver={(e) => handleTierDragOver(e, 'unranked')}
                    onDragLeave={handleDragLeave}
                    onDrop={(e) => handleDrop(e, 'unranked')}
                    data-touch-tier="unranked"
                    className={`tier-slot rounded-lg bg-white/5 p-3 flex flex-wrap gap-2 items-start ${dragOverTier === 'unranked' && dropInsertIndex === null && !(tiers.unranked?.length > 0) ? 'drag-over' : ''}`}
                    style={{ minHeight: '120px' }}
                >
                    <div onClick={() => setCreateTileModalOpen(true)} className="w-16 h-16 md:w-20 md:h-20 rounded bg-purple-500/20 border-2 border-dashed border-purple-500/50 flex items-center justify-center cursor-pointer hover:bg-purple-500/30 transition-all shrink-0">
                        <Plus className="w-8 h-8 text-purple-400" />
                    </div>
                    {tiers.unranked?.length === 0 && <span className="text-white/30 text-sm ml-2 self-center">Add custom tiles or drag items here</span>}
                    {renderTierItems('unranked', tiers.unranked || [])}
                </div>
            );

            // Sidebar layout logic:
            // sidebarCollapsed=false → full sidebar (320px)
            // sidebarCollapsed=true, unrankedInSidebar=true → left col shows unranked (320px)
            // sidebarCollapsed=true, unrankedInSidebar=false → narrow strip (48px)
            const showFullSidebar = !sidebarCollapsed;
            const showUnrankedLeft = sidebarCollapsed && unrankedInSidebar;
            const showNarrowStrip = sidebarCollapsed && !unrankedInSidebar;

            return (
                <div className="min-h-screen bg-black relative overflow-hidden">
                    <AnimatedBackground colors={bgColors} hasItems={bgHasItems} />

                    {undoToast && (
                        <div className="fixed bottom-4 right-4 z-50 undo-toast">
                            <div className="bg-gray-900 border border-white/20 rounded-lg px-4 py-2 shadow-2xl flex items-center gap-2">
                                <RotateCcw className="w-4 h-4 text-green-400" />
                                <span className="text-white text-sm">{undoToast}</span>
                            </div>
                        </div>
                    )}

                    {/* Mode warning modal */}
                    {modeWarningOpen && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm">
                            <div className="bg-gray-900 border border-white/20 rounded-2xl p-6 max-w-md mx-4 shadow-2xl">
                                <h3 className="text-xl font-bold text-white mb-4">Switch Mode</h3>
                                <p className="text-white mb-6">{songsMode ? "Switching back to Album mode will move all items to unranked." : "Switching to Songs mode will convert albums to tracks and move them to unranked."}</p>
                                <div className="flex gap-3">
                                    <button onClick={() => setModeWarningOpen(false)} className="flex-1 px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg">Cancel</button>
                                    <button onClick={confirmModeSwitch} className="flex-1 px-4 py-2 bg-purple-500 hover:bg-purple-600 text-white rounded-lg font-semibold">Continue</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Create tile modal */}
                    {createTileModalOpen && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm">
                            <div className="bg-gray-900 border border-white/20 rounded-2xl p-6 max-w-md mx-4 shadow-2xl">
                                <h3 className="text-xl font-bold text-white mb-4">Create Custom Tile</h3>
                                <div className="space-y-4 mb-6">
                                    <div>
                                        <label className="block text-white text-sm font-medium mb-2">Title</label>
                                        <input type="text" value={newTileTitle} onChange={e => setNewTileTitle(e.target.value)} onKeyPress={e => e.key === 'Enter' && createCustomTile()} placeholder="Enter title" className="w-full px-4 py-2 bg-white/10 border border-white/20 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50" autoFocus />
                                    </div>
                                    <div>
                                        <label className="block text-white text-sm font-medium mb-2">Color</label>
                                        <div className="flex gap-2">
                                            <input type="color" value={newTileColor} onChange={e => setNewTileColor(e.target.value)} className="w-16 h-10 rounded cursor-pointer" />
                                            <input type="text" value={newTileColor} onChange={e => setNewTileColor(e.target.value)} className="flex-1 px-4 py-2 bg-white/10 border border-white/20 rounded-lg text-white focus:outline-none" />
                                        </div>
                                    </div>
                                </div>
                                <div className="flex gap-3">
                                    <button onClick={() => { setCreateTileModalOpen(false); setNewTileTitle(''); setNewTileColor('#8b5cf6'); }} className="flex-1 px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg">Cancel</button>
                                    <button onClick={createCustomTile} className="flex-1 px-4 py-2 bg-purple-500 hover:bg-purple-600 text-white rounded-lg font-semibold">Create</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Clear confirm modal */}
                    {showConfirm && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm">
                            <div className="bg-gray-900 border border-white/20 rounded-2xl p-6 max-w-sm mx-4 shadow-2xl">
                                <h3 className="text-xl font-bold text-white mb-3">Clear all items?</h3>
                                <p className="text-gray-400 mb-6">This will remove all items from every tier.</p>
                                <div className="flex gap-3">
                                    <button
                                        onClick={() => setShowConfirm(false)}
                                        className="flex-1 px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg transition-colors"
                                    >
                                        Cancel
                                    </button>
                                    <button
                                        onClick={clearAll}
                                        className="flex-1 px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg font-semibold transition-colors"
                                    >
                                        Clear All
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Rename modal */}
                    {renameModalOpen && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm">
                            <div className="bg-gray-900 border border-white/20 rounded-2xl p-6 max-w-md mx-4 shadow-2xl">
                                <h3 className="text-xl font-bold text-white mb-4">Rename {songsMode ? 'Song' : 'Album'}</h3>
                                <div className="mb-6">
                                    <label className="block text-white text-sm font-medium mb-2">Title</label>
                                    <input type="text" value={renameTitle} onChange={e => setRenameTitle(e.target.value)} onKeyPress={e => e.key === 'Enter' && confirmRename()} className="w-full px-4 py-2 bg-white/10 border border-white/20 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50" autoFocus />
                                </div>
                                <div className="flex gap-3">
                                    <button onClick={() => { setRenameModalOpen(false); setRenameItem(null); setRenameTitle(''); }} className="flex-1 px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg">Cancel</button>
                                    <button onClick={confirmRename} className="flex-1 px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg font-semibold">Rename</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Top bar */}
                    <div className="relative z-10">
                        <div className="flex flex-wrap justify-between items-center gap-3 py-4 px-4 md:px-8 sticky top-0 z-20 bg-black/30 backdrop-blur-md border-b border-white/5">
                            <div className="flex items-center gap-4">
                                <a href="µsic.html" className="hover:opacity-80 transition-opacity">
                                    <h1 className="text-2xl md:text-3xl font-bold text-white drop-shadow-lg">µsic tools</h1>
                                </a>
                            </div>
                            <div className="flex flex-wrap items-center gap-2">
                                {/* ── Charts Dropdown ── */}
                                <div className="relative" ref={chartsMenuRef}>
                                    <button
                                        onClick={() => setShowChartsMenu(v => !v)}
                                        className={`px-3 md:px-4 py-2 text-white rounded-lg border flex items-center gap-2 transition-colors ${showChartsMenu ? 'bg-white/20 border-white/30' : 'bg-white/10 hover:bg-white/20 border-white/20'}`}
                                    >
                                        <Layers className="w-4 h-4" />
                                        <span className="hidden sm:inline text-sm font-medium max-w-[120px] truncate">{charts[currentChartId]?.name || 'Lists'}</span>
                                        <ChevronDown className={`w-3 h-3 transition-transform ${showChartsMenu ? 'rotate-180' : ''}`} />
                                    </button>
                                    {showChartsMenu && (
                                        <div className="absolute top-full mt-2 left-0 w-72 bg-gray-950/95 backdrop-blur-xl border border-white/10 rounded-2xl shadow-2xl overflow-hidden z-50">
                                            <div className="px-4 pt-4 pb-3 border-b border-white/10 flex items-center justify-between">
                                                <span className="text-white/60 text-xs font-semibold uppercase tracking-wider">Your Lists</span>
                                                <button onClick={() => { createNewChart(); setShowChartsMenu(false); }} className="px-2.5 py-1 bg-white/10 hover:bg-white/20 text-white rounded-lg text-xs font-medium flex items-center gap-1.5 transition-colors border border-white/10">
                                                    <Plus className="w-3 h-3" /> New
                                                </button>
                                            </div>
                                            <div className="max-h-72 overflow-y-auto p-2 space-y-1">
                                                {Object.entries(charts).sort(([, a], [, b]) => b.lastModified - a.lastModified).map(([id, chart]) => {
                                                    const isActive = currentChartId === id;
                                                    const isRenaming = renamingChartId === id;
                                                    return (
                                                        <div key={id}
                                                            className={`group flex items-center gap-2 px-2.5 py-2 rounded-xl transition-all ${isActive ? 'bg-white/15 border border-white/20' : 'hover:bg-white/8 border border-transparent cursor-pointer'}`}
                                                            onClick={() => { if (!isActive && !isRenaming) { switchChart(id); setShowChartsMenu(false); } }}
                                                        >
                                                            <div className="flex-1 min-w-0">
                                                                {isRenaming ? (
                                                                    <input autoFocus type="text" defaultValue={chart.name}
                                                                        onClick={e => e.stopPropagation()}
                                                                        onBlur={e => { updateChartName(id, e.target.value || chart.name); setRenamingChartId(null); }}
                                                                        onKeyDown={e => { e.stopPropagation(); if (e.key === 'Enter') { updateChartName(id, e.target.value || chart.name); setRenamingChartId(null); } if (e.key === 'Escape') setRenamingChartId(null); }}
                                                                        className="w-full bg-white/10 text-white text-sm font-medium rounded px-2 py-0.5 focus:outline-none focus:ring-1 focus:ring-white/40 border border-white/20"
                                                                    />
                                                                ) : (
                                                                    <div className="text-white text-sm font-medium truncate">{chart.name}</div>
                                                                )}
                                                                <div className="text-white/40 text-xs mt-0.5">{new Date(chart.lastModified).toLocaleDateString()}</div>
                                                            </div>
                                                            <div className="flex items-center gap-0.5 flex-none">
                                                                <button onClick={e => { e.stopPropagation(); setRenamingChartId(isRenaming ? null : id); }} className={`p-1 rounded transition-colors ${isRenaming ? 'text-white bg-white/20' : 'text-white/30 hover:text-white opacity-0 group-hover:opacity-100'}`} title="Rename">
                                                                    <Pencil className="w-3 h-3" />
                                                                </button>
                                                                {Object.keys(charts).length > 1 && (
                                                                    <button onClick={e => { e.stopPropagation(); if (confirm(`Delete "${chart.name}"?`)) deleteChart(id); }} className="p-1 text-white/30 hover:text-red-400 transition-colors opacity-0 group-hover:opacity-100 rounded" title="Delete">
                                                                        <Trash className="w-3 h-3" />
                                                                    </button>
                                                                )}
                                                                {isActive && <span className="w-1.5 h-1.5 rounded-full bg-green-400 ml-1 flex-none"></span>}
                                                            </div>
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    )}
                                </div>

                                <div className="h-6 w-px bg-white/10 mx-1"></div>

                                <button onClick={undo} disabled={historyIndex <= 0} className="px-3 md:px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg border border-white/20 flex items-center gap-2 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" title="Undo (Ctrl+Z)">
                                    <RotateCcw className="w-4 h-4" />
                                </button>
                                <button onClick={redo} disabled={historyIndex >= history.length - 1} className="px-3 md:px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg border border-white/20 flex items-center gap-2 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" title="Redo">
                                    <RotateCcw className="w-4 h-4 transform scale-x-[-1]" />
                                </button>

                                <div className="h-6 w-px bg-white/10 mx-1"></div>

                                <div className={`mode-switch ${songsMode ? 'songs' : ''}`} onClick={toggleSongsMode}>
                                    <div className="mode-switch-slider"></div>
                                    <span className="mode-label left">Albums</span>
                                    <span className="mode-label right">Songs</span>
                                </div>

                                <div className="h-6 w-px bg-white/10 mx-1"></div>

                                <button onClick={exportAsImage} className="px-3 md:px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg border border-white/20 flex items-center gap-2 transition-colors" title="Save as Image">
                                    <Photo className="w-4 h-4" /><span className="hidden sm:inline">Image</span>
                                </button>
                                <button onClick={exportData} className="px-3 md:px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg border border-white/20 flex items-center gap-2 transition-colors" title="Export data">
                                    <Upload className="w-4 h-4" /><span className="hidden sm:inline">Export</span>
                                </button>
                                <label className="px-3 md:px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg border border-white/20 flex items-center gap-2 cursor-pointer transition-colors" title="Import data">
                                    <Download className="w-4 h-4" /><span className="hidden sm:inline">Import</span>
                                    <input type="file" accept=".json" onChange={importData} className="hidden" />
                                </label>
                                <button onClick={() => setShowConfirm(true)} className="px-3 md:px-4 py-2 bg-red-500/20 hover:bg-red-500/30 text-white rounded-lg border border-red-500/50 flex items-center gap-2 transition-colors">
                                    <Trash className="w-4 h-4" /><span className="hidden sm:inline">Clear</span>
                                </button>
                            </div>
                        </div>

                        {/* Main layout */}
                        <div className="px-4 md:px-6 pb-8">
                            <div className="grid gap-4 md:gap-5 transition-none" style={{ gridTemplateColumns: (showFullSidebar || showUnrankedLeft) ? `${sidebarWidth}px 1fr` : '48px 1fr' }}>

                                {/* ── LEFT SIDEBAR ── */}
                                <div className="sidebar-wrapper">
                                    <div className="sidebar-panel space-y-3">
                                        {/* Resize handle — only shown when sidebar is expanded */}
                                        {(showFullSidebar || showUnrankedLeft) && (
                                            <div className="sidebar-resize-handle" onMouseDown={startSidebarResize} title="Drag to resize" />
                                        )}
                                        {/* Narrow strip — just expand button */}
                                        {showNarrowStrip && (
                                            <button
                                                onClick={() => setSidebarCollapsed(false)}
                                                className="w-full p-2.5 bg-white/10 hover:bg-white/20 text-white rounded-xl border border-white/20 transition-colors flex items-center justify-center"
                                                title="Expand Sidebar (Ctrl+H)"
                                            >
                                                <ChevronRight className="w-5 h-5" />
                                            </button>
                                        )}

                                        {/* Unranked in sidebar mode */}
                                        {showUnrankedLeft && (
                                            <>
                                                <div className="bg-white/5 backdrop-blur-2xl rounded-2xl p-4 shadow-2xl border border-white/10 sidebar-scroll flex-1" style={{ maxHeight: 'calc(100vh - 140px)' }}>
                                                    <div className="flex items-center mb-3">
                                                        <p className="text-white/40 text-[10px] font-semibold uppercase tracking-widest">Unranked</p>
                                                        <span className="ml-auto text-white/40 text-xs">{tiers.unranked?.length || 0} items</span>
                                                    </div>
                                                    {renderUnrankedSection()}
                                                </div>
                                                {/* Bottom button: Show Search */}
                                                <button
                                                    onClick={() => { setSidebarCollapsed(false); setUnrankedInSidebar(false); }}
                                                    className="w-full py-2 bg-white/5 hover:bg-white/10 text-white/50 hover:text-white rounded-xl border border-white/10 flex items-center justify-center gap-2 text-sm transition-all"
                                                    title="Show Search"
                                                >
                                                    <Search className="w-4 h-4" />Show Search
                                                </button>
                                            </>
                                        )}

                                        {/* Full expanded sidebar */}
                                        {showFullSidebar && (<>
                                            {/* Tab buttons */}
                                            <div className="flex gap-2">
                                                <button onClick={() => setSidebarTab('search')} className={`flex-1 px-3 py-2 rounded-lg font-medium transition-all text-sm ${sidebarTab === 'search' ? 'bg-white text-black' : 'bg-white/10 text-white hover:bg-white/20'}`}>
                                                    <Search className="w-4 h-4 inline mr-1.5" />Search
                                                </button>
                                                <button onClick={() => setSidebarTab('tiers')} className={`flex-1 px-3 py-2 rounded-lg font-medium transition-all text-sm ${sidebarTab === 'tiers' ? 'bg-white text-black' : 'bg-white/10 text-white hover:bg-white/20'}`}>
                                                    <Move className="w-4 h-4 inline mr-1.5" />Tiers
                                                </button>
                                                <button onClick={() => setSidebarTab('options')} className={`flex-1 px-3 py-2 rounded-lg font-medium transition-all text-sm ${sidebarTab === 'options' ? 'bg-white text-black' : 'bg-white/10 text-white hover:bg-white/20'}`}>
                                                    <Settings className="w-4 h-4 inline mr-1.5" />Options
                                                </button>
                                            </div>

                                            {/* ── SEARCH TAB ── */}
                                            {sidebarTab === 'search' && (
                                                <div className="bg-white/5 backdrop-blur-sm rounded-2xl shadow-2xl border border-white/10 flex flex-col sidebar-scroll" style={{ maxHeight: 'calc(100vh - 180px)' }}>
                                                    <div className="flex-none p-4 pb-3 space-y-3">
                                                        <p className="text-white/40 text-[10px] font-semibold uppercase tracking-widest">{songsMode ? 'Song Search' : 'Search'}</p>

                                                        {/* Albums/Artists toggle — shown in both modes when not in a song list */}
                                                        {!selectedAlbum && (
                                                            <div className="flex gap-2">
                                                                <button onClick={() => { setAdvancedSearchMode(false); setSelectedAlbum(null); setAlbumSongs([]); setSelectedArtist(null); setArtistAlbums([]); setArtistSuggestions([]); }} className={`flex-1 py-1.5 text-sm font-medium rounded-lg transition-colors ${!advancedSearchMode ? 'bg-white text-black' : 'bg-white/5 text-gray-400 hover:bg-white/10'}`}>Albums</button>
                                                                <button onClick={() => { setAdvancedSearchMode(true); setSelectedAlbum(null); setAlbumSongs([]); }} className={`flex-1 py-1.5 text-sm font-medium rounded-lg transition-colors ${advancedSearchMode ? 'bg-white text-black' : 'bg-white/5 text-gray-400 hover:bg-white/10'}`}>Artists</button>
                                                            </div>
                                                        )}

                                                        {/* Back buttons */}
                                                        {selectedAlbum && (
                                                            <button onClick={() => { setSelectedAlbum(null); setAlbumSongs([]); }} className="w-full px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg border border-white/20 text-sm flex items-center gap-2">
                                                                <ChevronLeft className="w-4 h-4" />Back to Albums
                                                            </button>
                                                        )}
                                                        {advancedSearchMode && selectedArtist && !selectedAlbum && (
                                                            <button onClick={() => { setSelectedArtist(null); setArtistAlbums([]); }} className="w-full px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg border border-white/20 text-sm flex items-center gap-2">
                                                                <ChevronLeft className="w-4 h-4" />Back to Artists
                                                            </button>
                                                        )}

                                                        {/* Search inputs — Albums tab */}
                                                        {!selectedAlbum && !advancedSearchMode && (
                                                            <>
                                                                <input type="text" value={searchQuery} onChange={e => setSearchQuery(e.target.value)} onKeyPress={e => e.key === 'Enter' && searchAlbums()} placeholder="Album name..." className="w-full px-4 py-2 bg-white/10 border border-white/20 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50" />
                                                                <div className="flex gap-2">
                                                                    <input type="text" value={searchArtistFilter} onChange={e => setSearchArtistFilter(e.target.value)} onKeyPress={e => e.key === 'Enter' && searchAlbums()} placeholder="Artist (optional)" className="flex-[2] min-w-0 px-3 py-2 bg-white/10 border border-white/20 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50 text-sm" />
                                                                    <input type="text" value={searchYearFilter} onChange={e => setSearchYearFilter(e.target.value)} onKeyPress={e => e.key === 'Enter' && searchAlbums()} placeholder="Year" className="flex-1 min-w-0 px-3 py-2 bg-white/10 border border-white/20 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50 text-sm" maxLength={4} />
                                                                </div>
                                                                <button onClick={searchAlbums} disabled={loading} className="w-full px-4 py-2 bg-white text-black font-bold rounded-lg hover:bg-gray-100 disabled:opacity-50 transition-colors">
                                                                    {loading ? <span className="flex items-center justify-center gap-2"><Loader2 className="w-4 h-4" />Searching...</span> : 'Search'}
                                                                </button>
                                                            </>
                                                        )}

                                                        {/* Search inputs — Artists tab (both modes) */}
                                                        {!selectedAlbum && advancedSearchMode && !selectedArtist && (
                                                            <>
                                                                <input type="text" value={artistSearchQuery} onChange={e => setArtistSearchQuery(e.target.value)} onKeyPress={e => e.key === 'Enter' && searchArtistForAlbums()} placeholder="Artist name..." className="w-full px-4 py-2 bg-white/10 border border-white/20 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50" />
                                                                <button onClick={searchArtistForAlbums} disabled={loadingArtist} className="w-full px-4 py-2 bg-white text-black font-bold rounded-lg hover:bg-gray-100 disabled:opacity-50 transition-colors">
                                                                    {loadingArtist ? <span className="flex items-center justify-center gap-2"><Loader2 className="w-4 h-4" />Searching...</span> : 'Search'}
                                                                </button>
                                                            </>
                                                        )}
                                                    </div>

                                                    {/* Results */}
                                                    <div className="flex-1 overflow-y-auto px-4 pb-4 space-y-2">

                                                        {/* Album results — Albums tab */}
                                                        {!selectedAlbum && !advancedSearchMode && searchResults.map(album => (
                                                            songsMode ? (
                                                                /* Songs mode: click to drill into track list */
                                                                <button key={album.id} onClick={() => selectAlbumAndLoadSongs(album)}
                                                                    className="w-full text-left bg-white/10 rounded-lg p-2 border border-white/10 hover:bg-white/20 transition-all flex items-center gap-3 group">
                                                                    <img src={album.image} alt={album.title} className="w-12 h-12 rounded object-cover shrink-0" />
                                                                    <div className="flex-1 min-w-0">
                                                                        <p className="text-white text-sm font-medium truncate">{album.title}</p>
                                                                        <p className="text-gray-400 text-xs truncate">{album.artist}{album.year && ` (${album.year})`}</p>
                                                                    </div>
                                                                    <ChevronRight className="w-4 h-4 text-white/40 group-hover:text-white/70 shrink-0" />
                                                                </button>
                                                            ) : (
                                                                /* Album mode: drag to place, + to add to unranked */
                                                                <div key={album.id} className="group bg-white/10 rounded-lg p-2 border border-white/10 hover:bg-white/20 transition-all flex items-center gap-3">
                                                                    <div draggable onDragStart={e => handleDragStart(e, album, null)} onDragEnd={handleDragEnd}
                                                                        onTouchStart={e => handleTouchStart(e, album, null)} onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd}
                                                                        className="flex items-center gap-3 flex-1 min-w-0 draggable-item cursor-grab">
                                                                        <img src={album.image} alt={album.title} className="w-12 h-12 rounded object-cover shrink-0" />
                                                                        <div className="flex-1 min-w-0">
                                                                            <p className="text-white text-sm font-medium truncate">{album.title}</p>
                                                                            <p className="text-gray-400 text-xs truncate">{album.artist}{album.year && ` (${album.year})`}</p>
                                                                        </div>
                                                                    </div>
                                                                    <button onClick={() => addItemToUnranked(album)}
                                                                        className="shrink-0 w-8 h-8 rounded-lg flex items-center justify-center transition-all bg-white/10 hover:bg-white text-white/50 hover:text-black"
                                                                        title="Add to unranked">
                                                                        <Plus className="w-4 h-4" />
                                                                    </button>
                                                                </div>
                                                            )
                                                        ))}

                                                        {/* Artist suggestions */}
                                                        {advancedSearchMode && !selectedArtist && artistSuggestions.map(artist => (
                                                            <button key={artist.artistId} onClick={() => selectArtistAndLoadAlbums(artist)}
                                                                className="w-full text-left px-3 py-2 bg-white/10 hover:bg-white/20 rounded-lg text-white text-sm transition-all border border-white/10 flex items-center gap-2">
                                                                <Music className="w-3.5 h-3.5 text-white/40 shrink-0" />
                                                                <span className="truncate">{artist.artistName}</span>
                                                                <ChevronRight className="w-3.5 h-3.5 text-white/30 shrink-0 ml-auto" />
                                                            </button>
                                                        ))}

                                                        {/* Artist albums */}
                                                        {advancedSearchMode && selectedArtist && !loadingArtist && !selectedAlbum && (
                                                            <div className="grid grid-cols-2 gap-2">
                                                                {artistAlbums.map(album => (
                                                                    songsMode ? (
                                                                        /* Songs mode: click to drill into tracks */
                                                                        <button key={album.id} onClick={() => selectAlbumAndLoadSongs(album)}
                                                                            className="bg-white/10 rounded-lg p-2 hover:bg-white/20 transition-all border border-white/10 text-left">
                                                                            <img src={album.image} alt={album.title} className="w-full aspect-square rounded object-cover mb-1" />
                                                                            <p className="text-white text-xs font-medium truncate">{album.title}</p>
                                                                            <p className="text-gray-400 text-[10px] truncate">{album.year}</p>
                                                                        </button>
                                                                    ) : (
                                                                        /* Album mode: drag to place, + visible on hover */
                                                                        <div key={album.id} className="group relative bg-white/10 rounded-lg p-2 hover:bg-white/20 transition-all border border-white/10">
                                                                            <div draggable onDragStart={e => handleDragStart(e, album, null)} onDragEnd={handleDragEnd}
                                                                                onTouchStart={e => handleTouchStart(e, album, null)} onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd}
                                                                                className="draggable-item cursor-grab">
                                                                                <img src={album.image} alt={album.title} className="w-full aspect-square rounded object-cover mb-1" />
                                                                                <p className="text-white text-xs font-medium truncate">{album.title}</p>
                                                                                <p className="text-gray-400 text-[10px] truncate">{album.year}</p>
                                                                            </div>
                                                                            <button onClick={() => addItemToUnranked(album)}
                                                                                className="absolute top-1.5 right-1.5 w-7 h-7 rounded-lg flex items-center justify-center transition-all opacity-0 group-hover:opacity-100 bg-black/60 hover:bg-white text-white hover:text-black"
                                                                                title="Add to unranked">
                                                                                <Plus className="w-3.5 h-3.5" />
                                                                            </button>
                                                                        </div>
                                                                    )
                                                                ))}
                                                            </div>
                                                        )}

                                                        {/* Song list — only reachable in songs mode */}
                                                        {selectedAlbum && (
                                                            <>
                                                                <div className="bg-white/10 rounded-lg p-3 border border-white/20 flex gap-3 items-center">
                                                                    <img src={selectedAlbum.image} alt={selectedAlbum.title} className="w-14 h-14 rounded object-cover shrink-0" />
                                                                    <div className="flex-1 min-w-0">
                                                                        <p className="text-white text-sm font-semibold truncate">{selectedAlbum.title}</p>
                                                                        <p className="text-gray-400 text-xs truncate">{selectedAlbum.artist}</p>
                                                                        {!loadingSongs && albumSongs.length > 0 && (
                                                                            <p className="text-white/30 text-[10px] mt-0.5">{albumSongs.length} tracks</p>
                                                                        )}
                                                                    </div>
                                                                </div>
                                                                {loadingSongs ? (
                                                                    <div className="flex items-center justify-center py-8"><Loader2 className="w-6 h-6 text-white" /></div>
                                                                ) : albumSongs.length === 0 ? (
                                                                    <p className="text-white/40 text-sm text-center py-6">No tracks found</p>
                                                                ) : albumSongs.map(song => (
                                                                    <div key={song.id} className="bg-white/10 rounded-lg p-2 flex items-center gap-3 hover:bg-white/20 transition-all border border-white/10">
                                                                        <span className="text-white/40 text-xs w-5 text-right shrink-0">{song.trackNumber}</span>
                                                                        {/* Only draggable in songs mode */}
                                                                        <div draggable={songsMode} onDragStart={e => songsMode && handleDragStart(e, song, null)} onDragEnd={handleDragEnd}
                                                                            onTouchStart={e => songsMode && handleTouchStart(e, song, null)} onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd}
                                                                            className={`flex-1 min-w-0 ${songsMode ? 'draggable-item cursor-grab' : ''}`}>
                                                                            <p className="text-white text-sm font-medium truncate">{song.title}</p>
                                                                            <p className="text-gray-400 text-xs truncate">{song.artist}</p>
                                                                        </div>
                                                                        {/* + only in songs mode */}
                                                                        {songsMode && (
                                                                            <button onClick={() => addItemToUnranked(song)}
                                                                                className="shrink-0 w-8 h-8 rounded-lg flex items-center justify-center transition-all bg-white/10 hover:bg-white text-white/50 hover:text-black"
                                                                                title="Add to unranked">
                                                                                <Plus className="w-4 h-4" />
                                                                            </button>
                                                                        )}
                                                                    </div>
                                                                ))}
                                                            </>
                                                        )}

                                                        {loadingArtist && <div className="flex items-center justify-center py-8"><Loader2 className="w-6 h-6 text-white" /></div>}
                                                    </div>
                                                </div>
                                            )}

                                            {/* ── TIERS TAB (bulk move + row editor) ── */}
                                            {sidebarTab === 'tiers' && (
                                                <div className="bg-white/5 backdrop-blur-2xl rounded-2xl shadow-2xl border border-white/10 overflow-y-auto sidebar-scroll space-y-5 p-4" style={{ maxHeight: 'calc(100vh - 180px)' }}>

                                                    {/* Bulk Move */}
                                                    <div>
                                                        <p className="text-white/40 text-[10px] font-semibold uppercase tracking-widest mb-3">Bulk Move</p>
                                                        <div className="space-y-3">
                                                            <div className="grid grid-cols-2 gap-2">
                                                                <div>
                                                                    <label className="block text-white text-xs font-medium mb-1">From</label>
                                                                    <select value={bulkMoveFrom} onChange={e => setBulkMoveFrom(e.target.value)} className="w-full px-3 py-2 bg-white/10 border border-white/20 rounded-lg text-white text-sm focus:outline-none">
                                                                        <option value="">Select…</option>
                                                                        {[...tierNames, 'unranked'].map(t => <option key={t} value={t}>{t}</option>)}
                                                                    </select>
                                                                </div>
                                                                <div>
                                                                    <label className="block text-white text-xs font-medium mb-1">To</label>
                                                                    <select value={bulkMoveTo} onChange={e => setBulkMoveTo(e.target.value)} className="w-full px-3 py-2 bg-white/10 border border-white/20 rounded-lg text-white text-sm focus:outline-none">
                                                                        <option value="">Select…</option>
                                                                        {[...tierNames, 'unranked'].map(t => <option key={t} value={t}>{t}</option>)}
                                                                    </select>
                                                                </div>
                                                            </div>
                                                            <button onClick={bulkMoveTiers} disabled={!bulkMoveFrom || !bulkMoveTo} className="w-full px-4 py-2 bg-green-500 hover:bg-green-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white rounded-lg font-semibold transition-colors text-sm">
                                                                Move All Items
                                                            </button>
                                                        </div>
                                                    </div>

                                                    <hr className="border-white/10" />

                                                    {/* Row editor */}
                                                    <div>
                                                        <div className="flex items-center justify-between mb-3">
                                                            <p className="text-white/40 text-[10px] font-semibold uppercase tracking-widest">Manage Rows</p>
                                                            <div className="flex gap-2">
                                                                <button onClick={resetGrid} className="px-2 py-1 bg-orange-500/20 hover:bg-orange-500/30 text-white rounded-lg border border-orange-500/50 text-xs flex items-center gap-1">
                                                                    <RefreshCw className="w-3 h-3" />Reset
                                                                </button>
                                                                <button onClick={addNewTier} className="px-2 py-1 bg-green-500/20 hover:bg-green-500/30 text-white rounded-lg border border-green-500/50 text-xs flex items-center gap-1">
                                                                    <Plus className="w-3 h-3" />Add
                                                                </button>
                                                            </div>
                                                        </div>
                                                        <div className="space-y-2">
                                                            {tierNames.map(tn => (
                                                                <div key={tn} className="flex items-center gap-2 bg-white/5 p-2.5 rounded-lg">
                                                                    {editingTierName === tn ? (
                                                                        <input type="text" value={tempTierName} onChange={e => setTempTierName(e.target.value)} onBlur={() => renameTier(tn, tempTierName)} onKeyDown={e => { if (e.key === 'Enter') renameTier(tn, tempTierName); if (e.key === 'Escape') setEditingTierName(null); }} className="w-14 px-2 py-1 bg-white/10 border border-white/20 rounded text-white text-center text-sm focus:outline-none" autoFocus />
                                                                    ) : (
                                                                        <button onClick={() => { setEditingTierName(tn); setTempTierName(tn); }} className="w-14 px-2 py-1 bg-white/10 hover:bg-white/20 border border-white/20 rounded text-white font-bold text-sm transition-colors">{tn}</button>
                                                                    )}
                                                                    <input type="color" value={tierColors[tn]} onChange={e => setTierColors(p => ({ ...p, [tn]: e.target.value }))} className="w-10 h-8 rounded cursor-pointer shrink-0" />
                                                                    <span className="flex-1 text-white/60 text-xs">{tiers[tn]?.length || 0} items</span>
                                                                    <button onClick={() => removeTier(tn)} className="px-2 py-1 bg-red-500/20 hover:bg-red-500/30 text-white rounded border border-red-500/50 text-xs">✕</button>
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                </div>
                                            )}

                                            {/* ── OPTIONS TAB ── */}
                                            {sidebarTab === 'options' && (
                                                <div className="bg-white/5 backdrop-blur-2xl rounded-2xl shadow-2xl border border-white/10 overflow-y-auto sidebar-scroll space-y-5 p-4" style={{ maxHeight: 'calc(100vh - 180px)' }}>

                                                    {/* Title */}
                                                    <div>
                                                        <p className="text-white/40 text-[10px] font-semibold uppercase tracking-widest mb-2">Tier List Title</p>
                                                        <input
                                                            type="text"
                                                            value={tempTitle}
                                                            onChange={e => setTempTitle(e.target.value)}
                                                            onBlur={() => handleTitleSave(tempTitle)}
                                                            onKeyDown={e => { if (e.key === 'Enter') handleTitleSave(tempTitle); if (e.key === 'Escape') { setTempTitle(title); } }}
                                                            className="w-full px-4 py-2 bg-white/10 border border-white/20 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50"
                                                        />
                                                    </div>

                                                    <hr className="border-white/10" />

                                                    {/* Layout options */}
                                                    <div>
                                                        <p className="text-white/40 text-[10px] font-semibold uppercase tracking-widest mb-3">Layout</p>
                                                        <div className="space-y-3">
                                                            <label className="toggle-switch">
                                                                <input type="checkbox" checked={showReorderButtons} onChange={e => setShowReorderButtons(e.target.checked)} />
                                                                <span className="toggle-track"><span className="toggle-thumb"></span></span>
                                                                <span className="toggle-label">Show reorder buttons</span>
                                                            </label>
                                                        </div>
                                                    </div>

                                                    <hr className="border-white/10" />

                                                    {/* Keyboard shortcuts */}
                                                    <div>
                                                        <p className="text-white/40 text-[10px] font-semibold uppercase tracking-widest mb-3">Keyboard Shortcuts</p>
                                                        <div className="space-y-2 text-sm text-gray-300">
                                                            {[['Undo', 'Ctrl/Cmd Z'], ['Redo', 'Ctrl/Cmd Y'], ['Toggle sidebar', 'Ctrl/Cmd H'], ['Export PNG', 'Ctrl/Cmd E'], ['Save JSON', 'Ctrl/Cmd S'], ['Quick rename', 'Right-click tile']].map(([label, kb]) => (
                                                                <div key={label} className="flex items-center justify-between">
                                                                    <span>{label}</span>
                                                                    <kbd className="px-2 py-0.5 rounded text-xs" style={{ background: 'rgba(255,255,255,0.1)' }}>{kb}</kbd>
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                </div>
                                            )}

                                            {/* Bottom buttons */}
                                            <div className="flex gap-2">
                                                <button
                                                    onClick={() => { setSidebarCollapsed(true); setUnrankedInSidebar(true); }}
                                                    className="flex-1 py-2 bg-white/5 hover:bg-white/10 text-white/50 hover:text-white rounded-xl border border-white/10 flex items-center justify-center gap-2 text-xs transition-all"
                                                    title="Hide search, show unranked here"
                                                >
                                                    <Square className="w-3 h-3" />Move unranked
                                                </button>
                                                <button
                                                    onClick={() => { setSidebarCollapsed(true); setUnrankedInSidebar(false); }}
                                                    className="flex-1 py-2 bg-white/5 hover:bg-white/10 text-white/50 hover:text-white rounded-xl border border-white/10 flex items-center justify-center gap-2 text-xs transition-all"
                                                    title="Collapse Sidebar (Ctrl+H)"
                                                >
                                                    <ChevronLeft className="w-3 h-3" />Hide sidebar
                                                </button>
                                            </div>
                                        </>)}
                                    </div>
                                </div>{/* end sidebar-wrapper */}

                                {/* ── RIGHT: TIER LIST ── */}
                                <div className="main-content" style={{ minWidth: 0 }}>
                                    <div className="bg-white/5 backdrop-blur-2xl rounded-2xl p-4 md:p-6 shadow-2xl border border-white/10" style={{ overflow: 'visible' }}>
                                        <div ref={tierListRef} style={{ backgroundColor: '#1a1a1a', overflow: 'visible' }} className="p-4 md:p-6 rounded-xl">
                                            {/* Title */}
                                            <div className="text-center mb-4">
                                                {editingTitle ? (
                                                    <input ref={titleInputRef} type="text" value={tempTitle} onChange={e => setTempTitle(e.target.value)} onBlur={() => handleTitleSave(tempTitle)} onKeyDown={e => { if (e.key === 'Enter') handleTitleSave(tempTitle); if (e.key === 'Escape') { setEditingTitle(false); setTempTitle(title); } }} className="text-xl md:text-2xl font-bold text-white text-center mb-4 bg-white/10 border border-white/20 rounded-lg px-4 py-2 w-full focus:outline-none focus:ring-2 focus:ring-white/50" />
                                                ) : (
                                                    <h2 onClick={() => { setEditingTitle(true); setTempTitle(title); }} className="editable-title text-xl md:text-2xl font-bold text-white mb-4">{title}</h2>
                                                )}
                                            </div>

                                            {/* Tiers */}
                                            {tierNames.map(tn => (
                                                <div key={tn} className="flex mb-2">
                                                    <div className="w-14 md:w-16 flex items-center justify-center font-bold text-black rounded-l-lg shrink-0 overflow-hidden p-1" style={{ backgroundColor: tierColors[tn], fontSize: tn.length > 4 ? (tn.length > 8 ? '9px' : '11px') : tn.length > 2 ? '13px' : undefined, wordBreak: 'break-word', textAlign: 'center', lineHeight: '1.1', minHeight: '56px' }}>{tn}</div>
                                                    <div
                                                        onDragOver={(e) => handleTierDragOver(e, tn)}
                                                        onDragLeave={handleDragLeave}
                                                        onDrop={(e) => handleDrop(e, tn)}
                                                        data-touch-tier={tn}
                                                        className={`flex-1 tier-slot rounded-r-lg bg-white/5 p-2 flex flex-wrap gap-2 items-center ${dragOverTier === tn && dropInsertIndex === null ? 'drag-over' : ''}`}
                                                    >
                                                        {tiers[tn]?.length === 0 && <span className="text-white/30 text-sm">Drag items here</span>}
                                                        {renderTierItems(tn, tiers[tn] || [])}
                                                    </div>
                                                </div>
                                            ))}

                                            {/* Unranked below tiers — only when not shown in sidebar */}
                                            {!showUnrankedLeft && (
                                                <div className="mt-4">
                                                    <h3 className="text-white text-base font-semibold mb-2">Unranked</h3>
                                                    {renderUnrankedSection()}
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                </div>

                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<TierListApp />, document.getElementById('root'));
    </script>

    <!-- Help Button -->
    <button id="helpBtn"
        onclick="document.getElementById('helpModal').classList.remove('hidden');document.body.style.overflow='hidden';"
        class="fixed bottom-6 right-6 w-12 h-12 flex items-center justify-center rounded-full z-40 transition-all duration-300 hover:scale-110 active:scale-95"
        style="background:rgba(255,255,255,0.12);border:1px solid rgba(255,255,255,0.2);backdrop-filter:blur(20px);box-shadow:0 4px 20px rgba(0,0,0,0.3);">
        <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
    </button>

    <!-- Help Modal -->
    <div id="helpModal" class="hidden fixed inset-0 z-50 flex items-center justify-center p-4"
        style="background:rgba(0,0,0,0.8);backdrop-filter:blur(8px);"
        onclick="if(event.target===this){this.classList.add('hidden');document.body.style.overflow='auto';}">
        <div class="w-full max-w-2xl" onclick="event.stopPropagation()">
            <div class="rounded-3xl p-8 shadow-2xl"
                style="background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);backdrop-filter:blur(40px);">
                <div class="flex items-center justify-between mb-6">
                    <h3 class="text-3xl font-bold text-white">Tier List</h3>
                    <button
                        onclick="document.getElementById('helpModal').classList.add('hidden');document.body.style.overflow='auto';"
                        class="w-10 h-10 flex items-center justify-center rounded-full transition-all"
                        style="background:rgba(255,255,255,0.1);">
                        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <div class="text-gray-200 space-y-4 overflow-y-auto pr-2" style="max-height:60vh;">
                    <div class="space-y-6">
                        <div>
                            <h4 class="text-xl font-semibold text-white mb-2">Getting Started</h4>
                            <p class="text-gray-300">Search for albums or artists in the <strong>Search</strong> tab of
                                the sidebar, then drag results into tier rows. Toggle to Songs mode in the topbar to
                                rank tracks instead of albums.</p>
                        </div>
                        <div>
                            <h4 class="text-xl font-semibold text-white mb-2">Sidebar Tabs</h4>
                            <ul class="space-y-2 text-gray-300">
                                <li><strong>Search</strong> — find and drag albums or songs into tiers</li>
                                <li><strong>Tiers</strong> — bulk move items between tiers, add/remove/rename rows</li>
                                <li><strong>Options</strong> — rename the list, toggle reorder buttons</li>
                            </ul>
                        </div>
                        <div>
                            <h4 class="text-xl font-semibold text-white mb-2">Dragging</h4>
                            <p class="text-gray-300">Drag items between tiers. When dragging within a tier, a blue line
                                appears showing exactly where the item will land — left or right of its neighbours.</p>
                        </div>
                        <div>
                            <h4 class="text-xl font-semibold text-white mb-2">Exporting</h4>
                            <p class="text-gray-300">Use the <strong>PNG</strong> button for a screenshot, or
                                <strong>Export → JSON/CSV</strong> for data. Import a saved JSON to resume later.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>

</html>
