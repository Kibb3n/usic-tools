<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topsters - μsic tools</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes blob1 {

            0%,
            100% {
                transform: translate(0, 0) scale(1);
            }

            33% {
                transform: translate(150px, 100px) scale(1.2);
            }

            66% {
                transform: translate(-100px, 150px) scale(0.9);
            }
        }

        @keyframes blob2 {

            0%,
            100% {
                transform: translate(0, 0) scale(1);
            }

            33% {
                transform: translate(-150px, -100px) scale(0.9);
            }

            66% {
                transform: translate(100px, -150px) scale(1.2);
            }
        }

        html, body {
            background: #000;
        }

        .grain {
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='3.5' numOctaves='4' /%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.3'/%3E%3C/svg%3E");
            pointer-events: none;
        }

        .grid-slot {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            transition: border-color 0.2s, background 0.2s, transform 0.2s;
        }

        .grid-slot.hidden-guides {
            border-color: transparent;
        }

        .grid-slot.drag-over {
            border-color: #60a5fa !important;
            background: rgba(96, 165, 250, 0.2);
            transform: scale(1.05);
        }

        .zero-gap .grid-slot,
        .zero-gap .classic-slot {
            border: none !important;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.12);
        }

        .zero-gap .grid-slot.hidden-guides,
        .zero-gap .classic-slot.hidden-guides {
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.07);
        }

        .zero-gap .grid-slot.drag-over,
        .zero-gap .classic-slot.drag-over {
            box-shadow: inset 0 0 0 2px #60a5fa !important;
            background: rgba(96, 165, 250, 0.2);
            transform: scale(1.02);
        }

        .classic-slot {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            transition: border-color 0.2s, background 0.2s, transform 0.2s;
        }

        .classic-slot.hidden-guides {
            border-color: transparent;
        }

        .classic-slot.drag-over {
            border-color: #60a5fa !important;
            background: rgba(96, 165, 250, 0.2);
            transform: scale(1.05);
        }

        .album-cover {
            cursor: grab;
            user-select: none;
            transition: transform 0.2s;
        }

        .album-cover:active {
            cursor: grabbing;
        }

        .album-cover.dragging {
            opacity: 0.4;
            transform: scale(0.9);
        }

        .about-you-cell {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .editable-label {
            outline: none;
            text-align: center;
            cursor: text;
            transition: all 0.2s;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px dashed transparent;
        }

        .editable-label:hover {
            border-color: rgba(255, 255, 255, 0.3);
        }

        .editable-label:focus {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .empty-state {
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.875rem;
            padding: 8px;
        }

        /* Toggle switch */
        .toggle-switch {
            position: relative;
            display: inline-flex;
            align-items: center;
            cursor: pointer;
            gap: 10px;
            user-select: none;
        }

        .toggle-switch input[type="checkbox"] {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-track {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
            flex-shrink: 0;
            transition: background 0.2s, border-color 0.2s;
        }

        .toggle-switch input:checked~.toggle-track {
            background: rgba(255, 255, 255, 0.85);
            border-color: rgba(255, 255, 255, 0.9);
        }

        .toggle-thumb {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transition: transform 0.2s, background 0.2s;
        }

        .toggle-switch input:checked~.toggle-track .toggle-thumb {
            transform: translateX(16px);
            background: #111;
        }

        .toggle-label {
            color: rgba(255, 255, 255, 0.85);
            font-size: 0.875rem;
            line-height: 1.25;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // Icons
        const Search = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
        );

        const Download = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
            </svg>
        );

        const Trash = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
            </svg>
        );

        const Pencil = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
            </svg>
        );

        const Settings = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
        );

        const Loader = ({ className }) => (
            <svg className={className + " animate-spin"} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
            </svg>
        );

        const Undo = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
            </svg>
        );

        const Redo = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 10h-10a8 8 0 00-8 8v2M21 10l-6 6m6-6l-6-6" />
            </svg>
        );

        const Image = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
            </svg>
        );

        const Photo = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" />
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 13a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
        );

        const Layers = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 5a1 1 0 011-1h4a1 1 0 011 1v7a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM14 5a1 1 0 011-1h4a1 1 0 011 1v7a1 1 0 01-1 1h-4a1 1 0 01-1-1V5zM4 16a1 1 0 011-1h4a1 1 0 011 1v3a1 1 0 01-1 1H5a1 1 0 01-1-1v-3zM14 16a1 1 0 011-1h4a1 1 0 011 1v3a1 1 0 01-1 1h-4a1 1 0 01-1-1v-3z" />
            </svg>
        );

        const Upload = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
            </svg>
        );

        const Plus = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
            </svg>
        );

        const ChevronDown = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
            </svg>
        );

        const ChevronLeft = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
            </svg>
        );

        const ArrowRight = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14 5l7 7m0 0l-7 7m7-7H3" />
            </svg>
        );

        const Save = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 3H7a2 2 0 00-2 2v14a2 2 0 002 2h10a2 2 0 002-2V5a2 2 0 00-2-2z M12 17a2 2 0 110-4 2 2 0 010 4z M15 7H9V5h6v2z" />
            </svg>
        );

        const Clipboard = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
            </svg>
        );

        const Pin = ({ className, filled }) => (
            <svg className={className} fill={filled ? "currentColor" : "none"} stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z" />
            </svg>
        );

        // Helper for iTunes API
        const jsonpRequest = (url) => {
            return new Promise((resolve, reject) => {
                const callbackName = 'jsonp_callback_' + Math.round(100000 * Math.random());
                window[callbackName] = (data) => {
                    delete window[callbackName];
                    document.body.removeChild(script);
                    resolve(data);
                };
                const script = document.createElement('script');
                script.src = url + (url.indexOf('?') >= 0 ? '&' : '?') + 'callback=' + callbackName;
                script.onerror = () => {
                    delete window[callbackName];
                    document.body.removeChild(script);
                    reject(new Error('JSONP request failed'));
                };
                document.body.appendChild(script);
            });
        };

        function AnimatedBackground({ colors }) {
            return (
                <div className="fixed inset-0 overflow-hidden pointer-events-none">
                    <div
                        className="absolute w-[900px] h-[900px] rounded-full opacity-70 blur-3xl will-change-transform"
                        style={{
                            background: `radial-gradient(circle, ${colors[0]} 0%, transparent 70%)`,
                            animation: `blob1 12s ease-in-out infinite`,
                            transition: 'background 3s ease',
                            top: '50%',
                            left: '33.333%',
                            transform: 'translate(-50%, -50%)',
                        }}
                    />
                    <div
                        className="absolute w-[900px] h-[900px] rounded-full opacity-70 blur-3xl will-change-transform"
                        style={{
                            background: `radial-gradient(circle, ${colors[1]} 0%, transparent 70%)`,
                            animation: `blob2 12s ease-in-out infinite`,
                            transition: 'background 3s ease',
                            top: '50%',
                            right: '33.333%',
                            transform: 'translate(50%, -50%)',
                        }}
                    />
                    <div className="absolute inset-0 grain opacity-30" />
                </div>
            );
        }

        const aboutYouLabels = [
            'Favourite Album', 'Best Narrative', 'Favourite Cover', "I'll Listen Someday", 'Personal Impact', 'Bad Day Cure',
            'You enjoy but most don\'t', 'You don\'t enjoy but most do', 'Underrated', 'Overrated', 'Not usually my thing but...', 'Best Instrumental',
            'Best Vocals', 'Simple but fun', 'Best Mixtape', 'Consistent Discography', 'Biggest Letdown', 'Biggest Surprise',
            'Best Soundtrack', 'Most Unique', 'Favourite Band', 'Favourite Solo Artist', 'Best EP', 'Most Depressing'
        ];
        const TOP42_GRID_SIZE = 42;
        // Top 100: 2 rows of 5, 3 rows of 6, 3 rows of 10, 3 rows of 14 = 100
        const TOP100_ROW_CONFIG = [
            { start: 0, end: 10, cols: 5 },   // 2 rows of 5
            { start: 10, end: 28, cols: 6 },  // 3 rows of 6
            { start: 28, end: 58, cols: 10 }, // 3 rows of 10
            { start: 58, end: 100, cols: 14 } // 3 rows of 14
        ];
        const TOP100_GRID_SIZE = 100;

        function TopstersMode() {
            const [charts, setCharts] = useState({});
            const [currentChartId, setCurrentChartId] = useState(null);

            // Grid state (now derived/managed alongside charts)
            const [layout, setLayout] = useState('standard');
            const [gridWidth, setGridWidth] = useState(5);
            const [gridHeight, setGridHeight] = useState(5);
            const [title, setTitle] = useState('My Top Albums');
            const [titleColor, setTitleColor] = useState('#ffffff');
            const [bgColor, setBgColor] = useState('#000000');
            const [showTitles, setShowTitles] = useState(false);
            const [searchMode, setSearchMode] = useState('album'); // 'album' or 'artist'
            const [advSearch, setAdvSearch] = useState({
                artist: '',
                album: '',
                year: ''
            });

            const [searchResults, setSearchResults] = useState([]);
            const [loading, setLoading] = useState(false);
            const [grid, setGrid] = useState([]);
            const [aboutYouGrid, setAboutYouGrid] = useState([]);
            const [draggedItem, setDraggedItem] = useState(null);
            const [draggedFrom, setDraggedFrom] = useState(null);
            const [dragOverIndex, setDragOverIndex] = useState(null);
            const [bgColors, setBgColors] = useState(['#ff0080', '#7928ca']);
            const [history, setHistory] = useState([]);
            const [future, setFuture] = useState([]);
            const [leftPanelCollapsed, setLeftPanelCollapsed] = useState(false);
            const [showChartsMenu, setShowChartsMenu] = useState(false);
            const [showConfirm, setShowConfirm] = useState(false);
            const [uploadedImages, setUploadedImages] = useState([]);
            const [searchPage, setSearchPage] = useState(0);
            // Artist browse: step 1 = artist list, step 2 = catalog view
            const [artistResults, setArtistResults] = useState([]); // list of matching artists
            const [selectedArtist, setSelectedArtist] = useState(null); // { id, name, image }
            const [artistCatalog, setArtistCatalog] = useState([]); // albums for selectedArtist
            const [artistCatalogLoading, setArtistCatalogLoading] = useState(false);
            const [showImageModal, setShowImageModal] = useState(false);
            const [pendingImage, setPendingImage] = useState(null);
            const [customTitle, setCustomTitle] = useState('');
            const [customArtist, setCustomArtist] = useState('');
            // performanceMode removed
            const [renameModalOpen, setRenameModalOpen] = useState(false);
            const [renameIndex, setRenameIndex] = useState(null);
            const [renameTitle, setRenameTitle] = useState('');
            const [renameArtist, setRenameArtist] = useState('');
            const [leftPanelTab, setLeftPanelTab] = useState('search');
            const [showNumbers, setShowNumbers] = useState(true);
            const [replaceOnDrop, setReplaceOnDrop] = useState(false);
            const [gridGap, setGridGap] = useState(2);
            const [renamingChartId, setRenamingChartId] = useState(null);

            const gridRef = useRef(null);
            const fileInputRef = useRef(null);
            const scrollIntervalRef = useRef(null);
            const chartsMenuRef = useRef(null);
            // True until the initial localStorage load is done — prevents resize effect from firing too early
            const hasInitialLoadedRef = useRef(false);
            // True while loadChart is running — prevents the auto-save effect from overwriting fresh-loaded state
            const isLoadingChartRef = useRef(false);
            // Always-fresh snapshot of current chart state for use in switchChart
            const currentStateRef = useRef({});

            // Close charts menu when clicking outside of it
            useEffect(() => {
                if (!showChartsMenu) return;
                const handler = (e) => {
                    if (chartsMenuRef.current && !chartsMenuRef.current.contains(e.target)) {
                        setShowChartsMenu(false);
                    }
                };
                document.addEventListener('mousedown', handler);
                return () => document.removeEventListener('mousedown', handler);
            }, [showChartsMenu]);

            const itemsPerPage = 20;
            const totalPages = Math.ceil(searchResults.length / itemsPerPage);
            const paginatedResults = useMemo(() =>
                searchResults.slice(searchPage * itemsPerPage, (searchPage + 1) * itemsPerPage),
                [searchResults, searchPage]
            );

            // ── Background colour derivation ──────────────────────────────────────
            // iTunes CDN always taints the canvas, so pixel-reading is impossible in practice.
            // Instead we derive rich, album-art-feeling colours from the iTunes artwork URL,
            // which encodes meaningful unique IDs per album.  We use multiple hash passes to
            // build a proper HSL palette that feels genuinely tied to the album.
            useEffect(() => {
                const albums = layout === 'aboutYou'
                    ? aboutYouGrid.filter(cell => cell?.album).map(cell => cell.album)
                    : grid.filter(Boolean);

                if (albums.length === 0) {
                    setBgColors(['#0d0d1a', '#0a1520']);
                    return;
                }

                // FNV-1a hash — deterministic, well-distributed
                const fnv = (str) => {
                    let h = 2166136261 >>> 0;
                    for (let i = 0; i < str.length; i++) {
                        h ^= str.charCodeAt(i);
                        h = Math.imul(h, 16777619) >>> 0;
                    }
                    return h;
                };

                // Extract the most unique part of the iTunes image URL (the long numeric segment)
                // then blend it with artist/title for a richer, more stable colour fingerprint
                const albumFingerprint = (album) => {
                    const urlNum = (album.image || '').match(/\/(\d{7,})\//);
                    const urlSeed = urlNum ? urlNum[1] : '';
                    const artistSeed = album.artist || '';
                    const titleSeed = album.title || '';
                    // Three independent hashes give us hue, saturation-shift, lightness-shift
                    const h1 = fnv(urlSeed + artistSeed);
                    const h2 = fnv(titleSeed + urlSeed);
                    const h3 = fnv(artistSeed + titleSeed + 'lum');
                    return {
                        hue: h1 % 360,
                        sat: 60 + (h2 % 25),   // 60–84 — always vivid
                        lum: 12 + (h3 % 10),   // 12–21 — always dark
                    };
                };

                // Sample up to 8 albums spread across the grid for diversity
                const step = Math.max(1, Math.floor(albums.length / 8));
                const fingerprints = [];
                for (let i = 0; i < albums.length && fingerprints.length < 8; i += step) {
                    fingerprints.push(albumFingerprint(albums[i]));
                }

                // Average the hues with circular mean to avoid wrapping artefacts
                const circMean = (hues) => {
                    let sinSum = 0, cosSum = 0;
                    hues.forEach(h => {
                        sinSum += Math.sin(h * Math.PI / 180);
                        cosSum += Math.cos(h * Math.PI / 180);
                    });
                    return (Math.atan2(sinSum / hues.length, cosSum / hues.length) * 180 / Math.PI + 360) % 360;
                };

                // Split fingerprints into two hue clusters (maximally separated)
                const sortedByHue = [...fingerprints].sort((a, b) => a.hue - b.hue);
                let maxGap = 0, splitAt = 0;
                for (let i = 0; i < sortedByHue.length; i++) {
                    const next = (i + 1) % sortedByHue.length;
                    const gap = ((sortedByHue[next].hue - sortedByHue[i].hue + 360) % 360);
                    if (gap > maxGap) { maxGap = gap; splitAt = i; }
                }

                const cluster1 = sortedByHue.slice(0, splitAt + 1);
                const cluster2 = sortedByHue.slice(splitAt + 1);
                if (cluster2.length === 0) cluster2.push({ hue: (cluster1[0].hue + 160) % 360, sat: cluster1[0].sat, lum: cluster1[0].lum });

                const hue1 = Math.round(circMean(cluster1.map(f => f.hue)));
                const hue2 = Math.round(circMean(cluster2.map(f => f.hue)));
                const sat1 = Math.round(cluster1.reduce((s, f) => s + f.sat, 0) / cluster1.length);
                const sat2 = Math.round(cluster2.reduce((s, f) => s + f.sat, 0) / cluster2.length);
                const lum1 = Math.round(cluster1.reduce((s, f) => s + f.lum, 0) / cluster1.length);
                const lum2 = Math.round(cluster2.reduce((s, f) => s + f.lum, 0) / cluster2.length);

                setBgColors([
                    `hsl(${hue1}, ${sat1}%, ${lum1}%)`,
                    `hsl(${hue2}, ${sat2}%, ${lum2}%)`,
                ]);
            }, [grid, aboutYouGrid, layout]);

            // Load from localStorage on mount
            useEffect(() => {
                try {
                    const savedModel = localStorage.getItem('topstersData');
                    if (savedModel) {
                        const data = JSON.parse(savedModel);

                        // Migration check: if it has 'charts' property, it's new format.
                        // If it has 'grid' property directly, it's old format.
                        if (data.charts && data.currentChartId) {
                            setCharts(data.charts);
                            setCurrentChartId(data.currentChartId);
                            // loadChart will restore __ref: image placeholders via topstersImages
                            loadChart(data.charts[data.currentChartId]);
                        } else {
                            // Migrate old data
                            const newId = Date.now().toString();
                            const newChart = {
                                id: newId,
                                name: data.title || 'My First Chart',
                                layout: data.layout || 'standard',
                                gridWidth: data.gridWidth || 5,
                                gridHeight: data.gridHeight || 5,
                                title: data.title || 'My Top Albums',
                                titleColor: data.titleColor || '#ffffff',
                                bgColor: data.bgColor || '#000000',
                                showTitles: data.showTitles || false,
                                grid: data.grid || [],
                                aboutYouGrid: data.aboutYouGrid || [],
                                showNumbers: data.showNumbers !== undefined ? data.showNumbers : true,
                                lastModified: Date.now()
                            };

                            const newCharts = { [newId]: newChart };
                            setCharts(newCharts);
                            setCurrentChartId(newId);
                            loadChart(newChart);
                        }
                    } else {
                        // Clean slate
                        createNewChart();
                    }
                } catch (err) {
                    console.error('Failed to load saved data:', err);
                    createNewChart();
                } finally {
                    // Signal that initial load is done — the resize effect can now fire safely
                    hasInitialLoadedRef.current = true;
                }
            }, []);

            // ── Image storage helpers ────────────────────────────────────────────
            // Base64 data URLs can be hundreds of KB each; storing them inline in the
            // charts object quickly blows the ~5 MB localStorage quota.
            // Instead we keep images in a separate 'topstersImages' key, addressed by
            // their existing id (e.g. "uploaded-1234567890-0.123").  The chart data
            // stores only the id, and we re-inflate on load.

            const saveImagesToStorage = useCallback((imageMap) => {
                try {
                    localStorage.setItem('topstersImages', JSON.stringify(imageMap));
                } catch (_) { /* quota on images key – silently ignore, images just won't persist */ }
            }, []);

            // Strip base64 data URLs from a grid before saving to LS.
            // Returns { strippedGrid, imageMap } where imageMap is { id: dataUrl }
            const stripDataUrls = useCallback((gridArr, existingMap = {}) => {
                const imageMap = { ...existingMap };
                const strippedGrid = gridArr.map(item => {
                    if (!item) return item;
                    const img = item.image || '';
                    if (img.startsWith('data:')) {
                        imageMap[item.id] = img;
                        return { ...item, image: '__ref:' + item.id };
                    }
                    return item;
                });
                return { strippedGrid, imageMap };
            }, []);

            const stripDataUrlsAboutYou = useCallback((gridArr, existingMap = {}) => {
                const imageMap = { ...existingMap };
                const strippedGrid = gridArr.map(cell => {
                    if (!cell || !cell.album) return cell;
                    const img = cell.album.image || '';
                    if (img.startsWith('data:')) {
                        imageMap[cell.album.id] = img;
                        return { ...cell, album: { ...cell.album, image: '__ref:' + cell.album.id } };
                    }
                    return cell;
                });
                return { strippedGrid, imageMap };
            }, []);

            // Restore __ref: placeholders back to actual data URLs on load
            const restoreDataUrls = useCallback((gridArr, imageMap) => {
                return gridArr.map(item => {
                    if (!item) return item;
                    if (typeof item.image === 'string' && item.image.startsWith('__ref:')) {
                        const id = item.image.slice(6);
                        return { ...item, image: imageMap[id] || '' };
                    }
                    return item;
                });
            }, []);

            const restoreDataUrlsAboutYou = useCallback((gridArr, imageMap) => {
                return gridArr.map(cell => {
                    if (!cell || !cell.album) return cell;
                    if (typeof cell.album.image === 'string' && cell.album.image.startsWith('__ref:')) {
                        const id = cell.album.image.slice(6);
                        return { ...cell, album: { ...cell.album, image: imageMap[id] || '' } };
                    }
                    return cell;
                });
            }, []);

            // Save to localStorage whenever relevant state changes
            useEffect(() => {
                if (!currentChartId) return;
                // Skip saving while loadChart is running — prevents stale state from overwriting a freshly loaded chart
                if (isLoadingChartRef.current) return;

                // Keep the full (with base64) state in the ref for runtime use (switchChart, export etc.)
                const currentChartData = {
                    id: currentChartId,
                    name: charts[currentChartId]?.name || title,
                    layout, gridWidth, gridHeight, title, titleColor, bgColor, showTitles, grid, aboutYouGrid, showNumbers, replaceOnDrop, gridGap,
                    lastModified: Date.now()
                };
                currentStateRef.current = currentChartData;

                // Strip base64 data URLs out of the grid before persisting to localStorage
                // to stay well within the ~5 MB quota.
                let imageMap = {};
                try { imageMap = JSON.parse(localStorage.getItem('topstersImages') || '{}'); } catch (_) { }
                const { strippedGrid: sg, imageMap: im1 } = stripDataUrls(grid, imageMap);
                const { strippedGrid: sag, imageMap: im2 } = stripDataUrlsAboutYou(aboutYouGrid, im1);
                saveImagesToStorage(im2);

                const strippedChartData = { ...currentChartData, grid: sg, aboutYouGrid: sag };
                const newCharts = {
                    ...charts,
                    [currentChartId]: strippedChartData
                };

                try {
                    localStorage.setItem('topstersData', JSON.stringify({ currentChartId, charts: newCharts }));
                } catch (quotaErr) {
                    // If we still exceed quota even after stripping, warn but don't crash
                    console.warn('localStorage quota exceeded even after stripping images:', quotaErr);
                }

            }, [layout, gridWidth, gridHeight, title, titleColor, bgColor, showTitles, grid, aboutYouGrid, showNumbers, replaceOnDrop, gridGap, currentChartId]);

            // Helper to load a chart into state
            const loadChart = (chart) => {
                if (!chart) return;
                isLoadingChartRef.current = true;

                const targetLayout = chart.layout || 'standard';
                const savedGrid = Array.isArray(chart.grid) ? chart.grid : [];

                // ── Recover corrupted gridWidth/gridHeight ──
                // Old versions could save gridWidth=5,gridHeight=5 even for larger grids.
                // Detect this by counting filled slots and inferring the real dimensions.
                let w = Math.max(1, Math.min(12, chart.gridWidth || 5));
                let h = Math.max(1, Math.min(12, chart.gridHeight || 5));
                if (targetLayout === 'standard') {
                    const filledCount = savedGrid.filter(Boolean).length;
                    const savedLen = savedGrid.length;
                    // If saved grid length doesn't match w*h, trust the length
                    if (savedLen > 0 && savedLen !== w * h) {
                        // Try to infer w from saved length — look for a clean square or rectangle
                        const inferredArea = savedLen;
                        // Keep current w if it divides evenly, else find closest
                        if (inferredArea % w !== 0) {
                            // Find best w that divides inferredArea and is between 1..12
                            for (let tw = w; tw >= 1; tw--) {
                                if (inferredArea % tw === 0 && inferredArea / tw <= 12) {
                                    w = tw; h = inferredArea / tw; break;
                                }
                            }
                        } else {
                            h = inferredArea / w;
                        }
                        // Clamp
                        w = Math.max(1, Math.min(12, w));
                        h = Math.max(1, Math.min(12, h));
                    }
                }

                setLayout(targetLayout);
                setGridWidth(w);
                setGridHeight(h);
                setTitle(chart.title || 'My Top Albums');
                setTitleColor(chart.titleColor || '#ffffff');
                setBgColor(chart.bgColor || '#000000');
                setShowTitles(chart.showTitles || false);
                setShowNumbers(chart.showNumbers !== undefined ? chart.showNumbers : true);
                setReplaceOnDrop(chart.replaceOnDrop || false);
                setGridGap(chart.gridGap !== undefined ? chart.gridGap : 2);

                // Build correctly-sized grid array
                const targetSize = targetLayout === 'classic' ? TOP42_GRID_SIZE
                    : targetLayout === 'classic2' ? TOP100_GRID_SIZE
                        : w * h;
                const newGrid = Array(targetSize).fill(null);
                for (let i = 0; i < Math.min(savedGrid.length, targetSize); i++) {
                    newGrid[i] = savedGrid[i] || null;
                }

                // Restore any __ref: placeholders back to actual data URLs
                let imageMap = {};
                try { imageMap = JSON.parse(localStorage.getItem('topstersImages') || '{}'); } catch (_) { }
                const restoredGrid = restoreDataUrls(newGrid, imageMap);
                setGrid(restoredGrid);

                // Always build a full 24-cell aboutYouGrid (never leave it sparse or empty)
                const savedAboutYou = Array.isArray(chart.aboutYouGrid) ? chart.aboutYouGrid : [];
                const newAboutYou = aboutYouLabels.map((label, i) => {
                    const saved = savedAboutYou[i];
                    if (saved && typeof saved === 'object' && 'album' in saved) return saved;
                    return { album: null, label };
                });
                const restoredAboutYou = restoreDataUrlsAboutYou(newAboutYou, imageMap);
                setAboutYouGrid(restoredAboutYou);

                // Allow auto-save and resize effect to resume after React flushes these updates
                setTimeout(() => { isLoadingChartRef.current = false; }, 150);
            };

            const createNewChart = () => {
                const newId = Date.now().toString();
                const newChart = {
                    id: newId,
                    name: 'New Chart',
                    layout: 'standard',
                    gridWidth: 5,
                    gridHeight: 5,
                    title: 'My Top Albums',
                    titleColor: '#ffffff',
                    bgColor: '#000000',
                    showTitles: false,
                    grid: [],
                    aboutYouGrid: [],
                    showNumbers: true,
                    lastModified: Date.now()
                };

                // Update persisted charts immediately
                const updatedCharts = { ...charts, [newId]: newChart };
                setCharts(updatedCharts);
                setCurrentChartId(newId);
                loadChart(newChart);

                // Force save to LS
                localStorage.setItem('topstersData', JSON.stringify({
                    currentChartId: newId,
                    charts: updatedCharts
                }));
            };

            const switchChart = (id) => {
                if (id === currentChartId) return;
                // Use the always-fresh ref to save current chart before switching
                // (avoids stale closure bug where state appears as defaults)
                const freshData = currentStateRef.current;
                const currentChartData = Object.keys(freshData).length > 0 ? {
                    ...freshData,
                    id: currentChartId,
                    name: charts[currentChartId]?.name || freshData.name || title,
                    lastModified: Date.now()
                } : {
                    id: currentChartId,
                    name: charts[currentChartId]?.name || title,
                    layout, gridWidth, gridHeight, title, titleColor, bgColor,
                    showTitles, grid, aboutYouGrid, showNumbers,
                    lastModified: Date.now()
                };

                // Strip base64 before persisting (same as the save effect does)
                let imageMap = {};
                try { imageMap = JSON.parse(localStorage.getItem('topstersImages') || '{}'); } catch (_) { }
                const { strippedGrid: sg, imageMap: im1 } = stripDataUrls(currentChartData.grid || [], imageMap);
                const { strippedGrid: sag, imageMap: im2 } = stripDataUrlsAboutYou(currentChartData.aboutYouGrid || [], im1);
                saveImagesToStorage(im2);
                const strippedChartData = { ...currentChartData, grid: sg, aboutYouGrid: sag };

                const updatedCharts = { ...charts, [currentChartId]: strippedChartData };

                // Persist immediately so the chart we are leaving is saved correctly
                try {
                    localStorage.setItem('topstersData', JSON.stringify({ currentChartId: id, charts: updatedCharts }));
                } catch (e) { console.warn('quota on switchChart save', e); }

                // Keep full (with base64) data in runtime charts state for the current session
                const updatedChartsWithImages = { ...charts, [currentChartId]: currentChartData };
                setCharts(updatedChartsWithImages);
                setCurrentChartId(id);
                // loadChart reads from updatedCharts (stripped), but restoreDataUrls inside will re-inflate
                loadChart(updatedCharts[id]);
            };

            const updateCurrentChart = () => {
                if (!currentChartId) return;
                const currentChartData = {
                    id: currentChartId,
                    name: charts[currentChartId]?.name || title,
                    layout, gridWidth, gridHeight, title, titleColor, bgColor, showTitles, grid, aboutYouGrid, showNumbers, replaceOnDrop, gridGap,
                    lastModified: Date.now()
                };
                const updatedCharts = { ...charts, [currentChartId]: currentChartData };
                setCharts(updatedCharts);
                let imageMap = {};
                try { imageMap = JSON.parse(localStorage.getItem('topstersImages') || '{}'); } catch (_) { }
                const { strippedGrid: sg, imageMap: im1 } = stripDataUrls(grid, imageMap);
                const { strippedGrid: sag, imageMap: im2 } = stripDataUrlsAboutYou(aboutYouGrid, im1);
                saveImagesToStorage(im2);
                try {
                    localStorage.setItem('topstersData', JSON.stringify({
                        currentChartId,
                        charts: { ...updatedCharts, [currentChartId]: { ...currentChartData, grid: sg, aboutYouGrid: sag } }
                    }));
                } catch (e) { console.warn('quota on updateCurrentChart', e); }
            };

            const deleteChart = (id) => {
                const newCharts = { ...charts };
                delete newCharts[id];

                // If deleting current, switch to another
                if (id === currentChartId) {
                    const remainingIds = Object.keys(newCharts);
                    if (remainingIds.length > 0) {
                        const nextId = remainingIds[0];
                        setCurrentChartId(nextId);
                        loadChart(newCharts[nextId]);
                    } else {
                        // No charts left, create new
                        createNewChart();
                        return;
                    }
                }

                setCharts(newCharts);
                // LS update happens in effect or we force it here?
                localStorage.setItem('topstersData', JSON.stringify({
                    currentChartId: id === currentChartId ? Object.keys(newCharts)[0] : currentChartId,
                    charts: newCharts
                }));
            };

            const updateChartName = (id, newName) => {
                const newCharts = { ...charts };
                if (newCharts[id]) {
                    newCharts[id].name = newName;
                    setCharts(newCharts);
                    localStorage.setItem('topstersData', JSON.stringify({ currentChartId, charts: newCharts }));
                }
            };

            const toggleChartPin = (e, id) => {
                e.stopPropagation();
                const newCharts = { ...charts };
                if (newCharts[id]) {
                    newCharts[id] = { ...newCharts[id], pinned: !newCharts[id].pinned };
                    setCharts(newCharts);
                    localStorage.setItem('topstersData', JSON.stringify({ currentChartId, charts: newCharts }));
                }
            };

            // Resize standard grid when dimensions change (user manually changes width/height sliders)
            // Skip during initial load and chart switching — those set the grid directly to the right size
            useEffect(() => {
                if (!hasInitialLoadedRef.current) return; // wait until first localStorage load is done
                if (isLoadingChartRef.current) return;    // skip during chart switch
                if (layout !== 'standard') return;
                setGrid(prevGrid => {
                    const newSize = gridHeight * gridWidth;
                    if (prevGrid.length === newSize) return prevGrid; // no-op if already correct size
                    const newGrid = Array(newSize).fill(null);
                    for (let i = 0; i < Math.min(prevGrid.length, newSize); i++) {
                        newGrid[i] = prevGrid[i];
                    }
                    return newGrid;
                });
            }, [gridWidth, gridHeight]); // intentionally NOT including layout

            // History management
            const saveToHistory = useCallback((newGrid, newAboutYouGrid, newTitle, newBgColor) => {
                const currentState = {
                    grid: JSON.parse(JSON.stringify(newGrid || grid)),
                    aboutYouGrid: JSON.parse(JSON.stringify(newAboutYouGrid || aboutYouGrid)),
                    title: newTitle || title,
                    bgColor: newBgColor || bgColor
                };
                setHistory(prev => [...prev.slice(-49), currentState]);
                setFuture([]); // Clear redo history on new action
            }, [grid, aboutYouGrid, title, bgColor]);

            const undo = useCallback(() => {
                if (history.length > 0) {
                    const previous = history[history.length - 1];
                    const newHistory = history.slice(0, -1);

                    // Save current state to future for redo
                    const currentState = {
                        grid: JSON.parse(JSON.stringify(grid)),
                        aboutYouGrid: JSON.parse(JSON.stringify(aboutYouGrid)),
                        title,
                        bgColor
                    };
                    setFuture(prev => [currentState, ...prev]);

                    setGrid(previous.grid);
                    setAboutYouGrid(previous.aboutYouGrid);
                    setTitle(previous.title);
                    setBgColor(previous.bgColor);
                    setHistory(newHistory);
                }
            }, [history, grid, aboutYouGrid, title, bgColor]);

            const redo = useCallback(() => {
                if (future.length > 0) {
                    const next = future[0];
                    const newFuture = future.slice(1);

                    // Save current state to history for undo
                    const currentState = {
                        grid: JSON.parse(JSON.stringify(grid)),
                        aboutYouGrid: JSON.parse(JSON.stringify(aboutYouGrid)),
                        title,
                        bgColor
                    };
                    setHistory(prev => [...prev, currentState]);

                    setGrid(next.grid);
                    setAboutYouGrid(next.aboutYouGrid);
                    setTitle(next.title);
                    setBgColor(next.bgColor);
                    setFuture(newFuture);
                }
            }, [future, grid, aboutYouGrid, title, bgColor]);

            // Keyboard shortcuts
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
                        e.preventDefault();
                        if (e.shiftKey) {
                            redo();
                        } else {
                            undo();
                        }
                    }
                    if ((e.metaKey || e.ctrlKey) && e.key === 'y') {
                        e.preventDefault();
                        redo();
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [undo, redo]);

            const normalizeString = useCallback((str) => {
                return str.toLowerCase().replace(/[^a-z0-9]/g, '');
            }, []);

            // Load full discography for a chosen artist
            const loadArtistCatalog = useCallback(async (artist) => {
                setSelectedArtist(artist);
                setArtistCatalog([]);
                setArtistCatalogLoading(true);
                try {
                    const safeImg = (url100) => url100
                        ? url100.replace('100x100bb', '600x600bb').replace('100x100', '600x600')
                        : null;
                    const resp = await jsonpRequest(
                        `https://itunes.apple.com/lookup?id=${artist.id}&entity=album&limit=200`
                    );
                    const albums = [];
                    const seen = new Set();
                    for (const item of (resp.results || [])) {
                        if (item.wrapperType !== 'collection') continue;
                        if (!item.artworkUrl100) continue;
                        const key = `${item.collectionId}`;
                        if (seen.has(key)) continue;
                        seen.add(key);
                        albums.push({
                            id: `itunes-${item.collectionId}`,
                            title: item.collectionName || 'Unknown Album',
                            artist: item.artistName || artist.name,
                            image: safeImg(item.artworkUrl100),
                            year: item.releaseDate ? new Date(item.releaseDate).getFullYear() : '',
                        });
                    }
                    albums.sort((a, b) => (b.year || 0) - (a.year || 0));
                    setArtistCatalog(albums);
                } catch (e) {
                    console.error('Catalog load failed:', e);
                } finally {
                    setArtistCatalogLoading(false);
                }
            }, []);

            const LASTFM_API_KEY = '33866e12a02528e0bb9211bd2f351c28';

            // Fetch from Last.fm album.search (returns JSON via CORS-friendly endpoint)
            const searchLastFm = useCallback(async (albumTerm, artistTerm) => {
                try {
                    const query = artistTerm ? `${albumTerm} ${artistTerm}` : albumTerm;
                    const url = `https://ws.audioscrobbler.com/2.0/?method=album.search&album=${encodeURIComponent(query)}&api_key=${LASTFM_API_KEY}&format=json&limit=30`;
                    const resp = await fetch(url);
                    if (!resp.ok) return [];
                    const data = await resp.json();
                    const matches = data?.results?.albummatches?.album || [];
                    return matches;
                } catch (e) {
                    console.error('Last.fm search failed:', e);
                    return [];
                }
            }, []);

            const searchAlbums = useCallback(async () => {
                const query = searchMode === 'album' ? advSearch.album : advSearch.artist;
                if (!query.trim()) return;

                setLoading(true);
                setSearchResults([]);
                setArtistResults([]);
                setSelectedArtist(null);
                setArtistCatalog([]);
                setSearchPage(0);

                try {
                    let results = [];

                    if (searchMode === 'artist') {
                        // Phase 1: return a list of matching artists
                        const artistQuery = advSearch.artist.trim();
                        if (!artistQuery) { setLoading(false); return; }
                        try {
                            const artistData = await jsonpRequest(
                                `https://itunes.apple.com/search?term=${encodeURIComponent(artistQuery)}&entity=musicArtist&attribute=artistTerm&limit=20`
                            );
                            const artists = [];
                            const seen = new Set();
                            for (const a of (artistData.results || [])) {
                                if (!a.artistId || seen.has(a.artistId)) continue;
                                seen.add(a.artistId);
                                artists.push({
                                    id: a.artistId,
                                    name: a.artistName || 'Unknown Artist',
                                    genre: a.primaryGenreName || '',
                                    url: a.artistLinkUrl || '',
                                });
                            }
                            setArtistResults(artists);
                        } catch (e) { console.error('Artist search failed:', e); }
                        setLoading(false);
                        return;
                    } else {
                        // Album search: use albumTerm attribute for precision
                        const albumTerm = advSearch.album.trim();
                        const artistTerm = advSearch.artist.trim();
                        const searchYear = parseInt(advSearch.year);

                        // Build query: combine album + artist for better iTunes relevance
                        const combinedTerm = artistTerm ? `${albumTerm} ${artistTerm}` : albumTerm;

                        // Run iTunes and Last.fm searches in parallel
                        const [byAlbum, byCombined, lastFmResults] = await Promise.allSettled([
                            jsonpRequest(`https://itunes.apple.com/search?term=${encodeURIComponent(albumTerm)}&entity=album&attribute=albumTerm&limit=50`),
                            artistTerm
                                ? jsonpRequest(`https://itunes.apple.com/search?term=${encodeURIComponent(combinedTerm)}&entity=album&limit=50`)
                                : Promise.resolve({ results: [] }),
                            searchLastFm(albumTerm, artistTerm)
                        ]);

                        const itunesItems = [
                            ...((byAlbum.status === 'fulfilled' ? byAlbum.value.results : null) || []),
                            ...((byCombined.status === 'fulfilled' ? byCombined.value.results : null) || [])
                        ].filter(item => item.wrapperType === 'collection');

                        // Helper: normalize for dedup comparison
                        const normKey = (title, artist) =>
                            `${title.toLowerCase().replace(/[^a-z0-9]/g, '')}||${artist.toLowerCase().replace(/[^a-z0-9]/g, '')}`;

                        const seen = new Set();
                        const scored = [];

                        // Process iTunes results first
                        for (const item of itunesItems) {
                            const key = `itunes-${item.collectionId}`;
                            if (seen.has(key)) continue;
                            seen.add(key);

                            const albumName = item.collectionName;
                            const artistName = item.artistName;
                            const year = item.releaseDate ? new Date(item.releaseDate).getFullYear() : 0;

                            const albumLower = albumName.toLowerCase();
                            const artistLower = artistName.toLowerCase();
                            const searchAlbumLower = albumTerm.toLowerCase();
                            const searchArtistLower = artistTerm.toLowerCase();

                            let score = 0;

                            // Album title scoring
                            if (albumLower === searchAlbumLower) score += 200;
                            else if (albumLower.startsWith(searchAlbumLower)) score += 100;
                            else if (albumLower.includes(searchAlbumLower)) score += 50;
                            else {
                                const qWords = searchAlbumLower.split(/\s+/).filter(w => w.length > 1);
                                const aWords = albumLower.split(/\s+/);
                                const matchCount = qWords.filter(w => aWords.some(aw => aw === w || aw.startsWith(w))).length;
                                score += matchCount * 15;
                                if (matchCount === 0) continue;
                            }

                            // Artist scoring
                            if (searchArtistLower) {
                                if (artistLower === searchArtistLower) score += 100;
                                else if (artistLower.includes(searchArtistLower) || searchArtistLower.includes(artistLower)) score += 50;
                                else score -= 20;
                            }

                            if (searchYear && year && year !== searchYear) continue;
                            if (item.collectionType === 'Album') score += 10;

                            const normDedupKey = normKey(albumName, artistName);
                            seen.add(normDedupKey);

                            scored.push({
                                id: key,
                                title: albumName,
                                artist: artistName,
                                image: item.artworkUrl100.replace('100x100', '600x600'),
                                year,
                                score,
                                source: 'itunes'
                            });
                        }

                        // Process Last.fm results, skipping duplicates already found via iTunes
                        const lfmAlbums = lastFmResults.status === 'fulfilled' ? (lastFmResults.value || []) : [];
                        const searchAlbumLower = albumTerm.toLowerCase();
                        const searchArtistLower = artistTerm.toLowerCase();

                        for (const item of lfmAlbums) {
                            const albumName = item.name || '';
                            const artistName = typeof item.artist === 'string' ? item.artist : (item.artist?.name || '');
                            if (!albumName || !artistName) continue;

                            // Skip if we already have a matching iTunes result
                            const normDedupKey = normKey(albumName, artistName);
                            if (seen.has(normDedupKey)) continue;
                            seen.add(normDedupKey);

                            // Get the best available image from Last.fm (extralarge or mega preferred)
                            const images = Array.isArray(item.image) ? item.image : [];
                            const imgEntry = images.find(i => i.size === 'mega') ||
                                             images.find(i => i.size === 'extralarge') ||
                                             images.find(i => i.size === 'large') ||
                                             images[images.length - 1];
                            const imageUrl = imgEntry && imgEntry['#text'] ? imgEntry['#text'] : null;
                            if (!imageUrl) continue; // skip entries with no artwork

                            const albumLower = albumName.toLowerCase();
                            const artistLower = artistName.toLowerCase();

                            let score = 0;

                            // Album title scoring (same logic as iTunes)
                            if (albumLower === searchAlbumLower) score += 200;
                            else if (albumLower.startsWith(searchAlbumLower)) score += 100;
                            else if (albumLower.includes(searchAlbumLower)) score += 50;
                            else {
                                const qWords = searchAlbumLower.split(/\s+/).filter(w => w.length > 1);
                                const aWords = albumLower.split(/\s+/);
                                const matchCount = qWords.filter(w => aWords.some(aw => aw === w || aw.startsWith(w))).length;
                                score += matchCount * 15;
                                if (matchCount === 0) continue;
                            }

                            if (searchArtistLower) {
                                if (artistLower === searchArtistLower) score += 100;
                                else if (artistLower.includes(searchArtistLower) || searchArtistLower.includes(artistLower)) score += 50;
                                else score -= 20;
                            }

                            // Last.fm doesn't provide year in search results so no year filter here
                            // Slightly lower base score vs iTunes since no year/type metadata
                            score -= 5;

                            scored.push({
                                id: `lastfm-${albumName}-${artistName}`.replace(/\s+/g, '_'),
                                title: albumName,
                                artist: artistName,
                                image: imageUrl,
                                year: 0,
                                score,
                                source: 'lastfm'
                            });
                        }

                        results = scored.sort((a, b) => b.score - a.score);
                    }

                    setSearchResults(results);
                } catch (error) {
                    console.error('Search error:', error);
                } finally {
                    setLoading(false);
                }
            }, [searchMode, advSearch, normalizeString, searchLastFm]);

            // Track current drag Y for scroll loop — updated on every dragover
            const dragYRef = useRef(null);
            const isDraggingRef = useRef(false);

            // Single persistent RAF scroll loop — runs for the lifetime of a drag
            const startScrollLoop = useCallback(() => {
                if (scrollIntervalRef.current) return; // already running
                const loop = () => {
                    if (!isDraggingRef.current) {
                        scrollIntervalRef.current = null;
                        return;
                    }
                    const y = dragYRef.current;
                    if (y !== null) {
                        const threshold = 80;
                        const maxSpeed = 18;
                        if (y < threshold) {
                            const speed = Math.round(maxSpeed * (1 - y / threshold));
                            window.scrollBy(0, -speed);
                        } else if (y > window.innerHeight - threshold) {
                            const speed = Math.round(maxSpeed * (1 - (window.innerHeight - y) / threshold));
                            window.scrollBy(0, speed);
                        }
                    }
                    scrollIntervalRef.current = requestAnimationFrame(loop);
                };
                scrollIntervalRef.current = requestAnimationFrame(loop);
            }, []);

            const handleDragStart = useCallback((e, album, fromIndex) => {
                setDraggedItem(album);
                setDraggedFrom(fromIndex);
                isDraggingRef.current = true;
                dragYRef.current = e.clientY;
                e.dataTransfer.effectAllowed = 'move';
                e.currentTarget.classList.add('dragging');
                startScrollLoop();
            }, [startScrollLoop]);

            const handleDragEnd = useCallback((e) => {
                isDraggingRef.current = false;
                dragYRef.current = null;
                scrollIntervalRef.current = null;
                e.currentTarget.classList.remove('dragging');
                setDragOverIndex(null);
            }, []);

            const handleDragOver = useCallback((e, index) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                dragYRef.current = e.clientY;
                setDragOverIndex(index);
            }, []);

            const handleDragLeave = useCallback((e) => {
                // Only clear the highlight — never stop the scroll loop here.
                // The loop only stops in handleDragEnd.
            }, []);

            const handleDrop = useCallback((e, toIndex) => {
                e.preventDefault();
                setDragOverIndex(null);

                if (!draggedItem) return;
                saveToHistory();

                if (layout === 'aboutYou') {
                    // aboutYou: simple swap, no shift mode
                    const newGrid = aboutYouGrid.map((cell, i) =>
                        cell && typeof cell === 'object' ? cell : { album: null, label: aboutYouLabels[i] || '' }
                    );
                    if (draggedFrom !== null && draggedFrom >= 0) {
                        newGrid[draggedFrom] = { ...newGrid[draggedFrom], album: null };
                    }
                    newGrid[toIndex] = { ...newGrid[toIndex], album: draggedItem };
                    setAboutYouGrid(newGrid);
                } else if (replaceOnDrop) {
                    // Replace mode: dropped album replaces the target, source slot becomes empty
                    const newGrid = [...grid];
                    if (draggedFrom !== null && draggedFrom >= 0) {
                        newGrid[draggedFrom] = null;
                    }
                    newGrid[toIndex] = draggedItem;
                    setGrid(newGrid);
                } else {
                    // Normal mode: swap source and destination
                    const newGrid = [...grid];
                    const displaced = newGrid[toIndex];
                    if (draggedFrom !== null && draggedFrom >= 0) {
                        newGrid[draggedFrom] = displaced;
                    }
                    newGrid[toIndex] = draggedItem;
                    setGrid(newGrid);
                }
                setDraggedItem(null);
                setDraggedFrom(null);
            }, [draggedItem, draggedFrom, layout, aboutYouGrid, grid, replaceOnDrop, saveToHistory]);

            const removeFromGrid = useCallback((index) => {
                saveToHistory();
                if (layout === 'aboutYou') {
                    const newGrid = aboutYouGrid.map((cell, i) =>
                        cell && typeof cell === 'object' ? cell : { album: null, label: aboutYouLabels[i] || '' }
                    );
                    newGrid[index] = { ...newGrid[index], album: null };
                    setAboutYouGrid(newGrid);
                } else {
                    const newGrid = [...grid];
                    newGrid[index] = null;
                    setGrid(newGrid);
                }
            }, [layout, aboutYouGrid, grid, saveToHistory]);

            const updateLabel = useCallback((index, newLabel) => {
                const newGrid = [...aboutYouGrid];
                newGrid[index] = { ...newGrid[index], label: newLabel };
                setAboutYouGrid(newGrid);
            }, [aboutYouGrid]);

            const openRenameModal = useCallback((index) => {
                if (layout === 'aboutYou' || index === null || index === undefined) return;

                const album = grid[index];
                if (album) {
                    setRenameIndex(index);
                    setRenameTitle(album.title);
                    setRenameArtist(album.artist);
                    setRenameModalOpen(true);
                }
            }, [layout, grid]);

            const confirmRename = useCallback(() => {
                if (renameIndex !== null) {
                    saveToHistory();
                    const newGrid = [...grid];
                    newGrid[renameIndex] = {
                        ...newGrid[renameIndex],
                        title: renameTitle,
                        artist: renameArtist
                    };
                    setGrid(newGrid);
                }
                setRenameModalOpen(false);
                setRenameIndex(null);
                setRenameTitle('');
                setRenameArtist('');
            }, [renameIndex, renameTitle, renameArtist, grid, saveToHistory]);

            const handleRenameKeyPress = useCallback((e) => {
                if (e.key === 'Enter') {
                    confirmRename();
                }
            }, [confirmRename]);

            const switchLayout = useCallback((newLayout) => {
                // No-op if already on this layout
                if (newLayout === layout) return;

                const getTargetSize = (l) => l === 'classic' ? TOP42_GRID_SIZE : (l === 'classic2' ? TOP100_GRID_SIZE : (gridWidth * gridHeight));
                const isGridLayout = (l) => l === 'standard' || l === 'classic' || l === 'classic2';

                if (newLayout === 'aboutYou' && isGridLayout(layout)) {
                    // Grid → About You: carry over albums as cells, always build a full 24-cell grid
                    const filledAlbums = grid.filter(a => a);
                    // Merge with the existing aboutYouGrid (keep user's existing placements if any)
                    const newAboutYouGrid = aboutYouLabels.map((label, i) => {
                        // Prefer existing aboutYouGrid cell if it has an album
                        const existing = aboutYouGrid[i];
                        if (existing && typeof existing === 'object' && existing.album) return existing;
                        return { album: filledAlbums[i] || null, label };
                    });
                    // Set grid and layout atomically in the same React batch
                    setAboutYouGrid(newAboutYouGrid);
                    setLayout('aboutYou');
                    // Don't change gridWidth/gridHeight here — avoids triggering grid useEffect
                } else if (layout === 'aboutYou' && isGridLayout(newLayout)) {
                    // About You → Grid: extract albums in order
                    const filledAlbums = aboutYouGrid
                        .map(cell => (cell && typeof cell === 'object' ? cell : null))
                        .filter(cell => cell?.album)
                        .map(cell => cell.album);
                    const targetSize = getTargetSize(newLayout);
                    const newGrid = Array(targetSize).fill(null);
                    filledAlbums.forEach((album, i) => { if (i < targetSize) newGrid[i] = album; });
                    setGrid(newGrid);
                    setLayout(newLayout);
                } else if (isGridLayout(layout) && isGridLayout(newLayout)) {
                    // Grid → Grid: resize, preserving as many albums as possible
                    const targetSize = getTargetSize(newLayout);
                    const newGrid = Array(targetSize).fill(null);
                    grid.forEach((album, i) => { if (i < targetSize) newGrid[i] = album; });
                    setGrid(newGrid);
                    setLayout(newLayout);
                } else {
                    setLayout(newLayout);
                }
            }, [layout, grid, aboutYouGrid, gridWidth, gridHeight]);

            const getTimestamp = () => {
                const now = new Date();
                const dd = String(now.getDate()).padStart(2, '0');
                const mm = String(now.getMonth() + 1).padStart(2, '0');
                const yyyy = now.getFullYear();
                const hh = String(now.getHours()).padStart(2, '0');
                const min = String(now.getMinutes()).padStart(2, '0');
                const ss = String(now.getSeconds()).padStart(2, '0');
                return `${dd}-${mm}-${yyyy} ${hh}.${min}.${ss}`;
            };

            const exportAsImage = useCallback(() => {
                const exportBtn = document.getElementById('export-btn');
                if (exportBtn) { exportBtn.disabled = true; exportBtn.textContent = 'Exporting…'; }
                const resetBtn = () => {
                    if (!exportBtn) return;
                    exportBtn.disabled = false;
                    exportBtn.innerHTML = '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z"/></svg><span class="hidden sm:inline">Image</span>';
                };

                // Collect unique image srcs
                const allAlbums = layout === 'aboutYou'
                    ? aboutYouGrid.map(c => c && c.album).filter(Boolean)
                    : grid.filter(Boolean);
                const uniqueSrcs = [];
                allAlbums.forEach(a => { if (a.image && uniqueSrcs.indexOf(a.image) === -1) uniqueSrcs.push(a.image); });

                // Use fetch() to load each image as a blob URL.
                // This sidesteps all CORS canvas-taint issues: we own the blob URL so the canvas stays clean.
                const blobUrls = {}; // original src -> blob URL (for revoking later)
                const imgMap = {}; // original src -> loaded HTMLImageElement

                var pending = uniqueSrcs.length;
                if (pending === 0) { drawAndDownload(); return; }

                // Safety timeout — never stay stuck
                var safetyFired = false;
                var safetyTimer = setTimeout(function () {
                    safetyFired = true;
                    drawAndDownload();
                }, 9000);

                function onOneDone() {
                    if (safetyFired) return;
                    pending--;
                    if (pending <= 0) {
                        clearTimeout(safetyTimer);
                        drawAndDownload();
                    }
                }

                uniqueSrcs.forEach(function (src) {
                    if (src.startsWith('data:')) {
                        // data URLs: load directly into an img element
                        var img = document.createElement('img');
                        img.onload = function () { imgMap[src] = img; onOneDone(); };
                        img.onerror = function () { onOneDone(); };
                        img.src = src;
                        return;
                    }
                    // Remote URL: fetch as blob to get same-origin-equivalent access
                    fetch(src)
                        .then(function (r) { return r.ok ? r.blob() : Promise.reject(r.status); })
                        .then(function (blob) {
                            var blobUrl = URL.createObjectURL(blob);
                            blobUrls[src] = blobUrl;
                            var img = document.createElement('img');
                            img.onload = function () { imgMap[src] = img; onOneDone(); };
                            img.onerror = function () { URL.revokeObjectURL(blobUrl); delete blobUrls[src]; onOneDone(); };
                            img.src = blobUrl;
                        })
                        .catch(function () { onOneDone(); });
                });

                function drawAndDownload() {
                    try {
                        var PAD = 48, GAP = gridGap;
                        var TITLE_H = (layout !== 'aboutYou' && title) ? 64 : 0;

                        var tmp = document.createElement('div');
                        tmp.style.color = bgColor; document.body.appendChild(tmp);
                        var rgb = getComputedStyle(tmp).color; document.body.removeChild(tmp);
                        var m = rgb.match(/\d+/g) || [0, 0, 0];
                        var bgR = +m[0], bgG = +m[1], bgB = +m[2];
                        var emptyFill = 'rgb(' + (bgR < 128 ? Math.min(255, bgR + 40) : Math.max(0, bgR - 30)) + ',' + (bgG < 128 ? Math.min(255, bgG + 40) : Math.max(0, bgG - 30)) + ',' + (bgB < 128 ? Math.min(255, bgB + 40) : Math.max(0, bgB - 30)) + ')';

                        var canvasW, canvasH, cellStd;
                        var LIST_W = (showTitles && grid.some(Boolean)) ? 220 : 0;
                        var LIST_PAD = LIST_W > 0 ? 24 : 0;
                        if (layout === 'standard') {
                            var tW = Math.max(1, gridWidth);
                            var tRows = Math.max(1, Math.ceil(grid.length / tW));
                            cellStd = Math.max(60, Math.round(700 / tW));
                            canvasW = PAD * 2 + cellStd * tW + GAP * (tW - 1) + LIST_PAD + LIST_W;
                            canvasH = PAD * 2 + TITLE_H + cellStd * tRows + GAP * (tRows - 1);
                        } else if (layout === 'classic') {
                            // classic: rows of 5,5,6,6,10,10 = 6 rows. Cell size based on widest row (10)
                            var classicRows = [{ s: 0, e: 5, c: 5 }, { s: 5, e: 10, c: 5 }, { s: 10, e: 16, c: 6 }, { s: 16, e: 22, c: 6 }, { s: 22, e: 32, c: 10 }, { s: 32, e: 42, c: 10 }];
                            var classicBaseW = 700;
                            canvasW = PAD * 2 + classicBaseW + LIST_PAD + LIST_W;
                            // Calculate actual height by summing row heights (each row's cell size = classicBaseW / cols)
                            var classicH = 0;
                            classicRows.forEach(function (row, ri) {
                                var cs = Math.round((classicBaseW - GAP * (row.c - 1)) / row.c);
                                classicH += cs + (ri < classicRows.length - 1 ? GAP : 0);
                            });
                            canvasH = PAD * 2 + TITLE_H + classicH;
                            cellStd = Math.round((classicBaseW - GAP * 9) / 10); // not used directly
                        } else if (layout === 'classic2') {
                            // classic2: TOP100_ROW_CONFIG segments, each with different col counts
                            // Use widest segment (14 cols) to determine base width
                            var c2BaseW = 700;
                            canvasW = PAD * 2 + c2BaseW + LIST_PAD + LIST_W;
                            // Sum total rows across all segments
                            var c2TotalH = 0;
                            var c2SegCount = TOP100_ROW_CONFIG.length;
                            TOP100_ROW_CONFIG.forEach(function (seg, si) {
                                var cs = Math.round((c2BaseW - GAP * (seg.cols - 1)) / seg.cols);
                                var rows = Math.ceil((seg.end - seg.start) / seg.cols);
                                c2TotalH += rows * cs + (rows - 1) * GAP + (si < c2SegCount - 1 ? GAP : 0);
                            });
                            canvasH = PAD * 2 + TITLE_H + c2TotalH;
                            cellStd = Math.round((c2BaseW - GAP * 13) / 14);
                        } else {
                            cellStd = 110;
                            canvasW = PAD * 2 + cellStd * 6 + GAP * 5;
                            canvasH = PAD * 2 + 4 * (cellStd + 30 + GAP);
                        }

                        var SCALE = 2;
                        var canvas = document.createElement('canvas');
                        canvas.width = canvasW * SCALE; canvas.height = canvasH * SCALE;
                        var ctx = canvas.getContext('2d');
                        ctx.scale(SCALE, SCALE);
                        ctx.fillStyle = bgColor; ctx.fillRect(0, 0, canvasW, canvasH);

                        if (TITLE_H > 0) {
                            ctx.fillStyle = titleColor;
                            ctx.font = 'bold 32px -apple-system,BlinkMacSystemFont,sans-serif';
                            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                            ctx.fillText(title, canvasW / 2, PAD + TITLE_H / 2);
                        }

                        if (!ctx.roundRect) ctx.roundRect = function (x, y, w, h, r) { this.beginPath(); this.moveTo(x + r, y); this.lineTo(x + w - r, y); this.quadraticCurveTo(x + w, y, x + w, y + r); this.lineTo(x + w, y + h - r); this.quadraticCurveTo(x + w, y + h, x + w - r, y + h); this.lineTo(x + r, y + h); this.quadraticCurveTo(x, y + h, x, y + h - r); this.lineTo(x, y + r); this.quadraticCurveTo(x, y, x + r, y); this.closePath(); };

                        function drawCell(src, x, y, size, num) {
                            var img = src ? imgMap[src] : null;
                            if (img && img.complete && img.naturalWidth > 0) {
                                try { ctx.drawImage(img, x, y, size, size); } catch (ex) { ctx.fillStyle = emptyFill; ctx.fillRect(x, y, size, size); }
                            } else { ctx.fillStyle = emptyFill; ctx.fillRect(x, y, size, size); }
                            if (showNumbers && num != null) {
                                var ns = String(num);
                                ctx.font = 'bold ' + Math.max(10, Math.round(size * 0.12)) + 'px sans-serif';
                                var tw = ctx.measureText(ns).width, bw = tw + 10, bh = Math.max(14, Math.round(size * 0.15));
                                ctx.fillStyle = 'rgba(0,0,0,0.78)'; ctx.beginPath(); ctx.roundRect(x + 3, y + size - bh - 3, bw, bh, 3); ctx.fill();
                                ctx.fillStyle = '#fff'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
                                ctx.fillText(ns, x + 8, y + size - bh / 2 - 3);
                            }
                        }

                        var yStart = PAD + TITLE_H;
                        if (layout === 'standard') {
                            var tW2 = Math.max(1, gridWidth);
                            var exportCell = Math.max(60, Math.round(700 / tW2));
                            grid.forEach(function (a, idx) { drawCell(a && a.image, PAD + (idx % tW2) * (exportCell + GAP), yStart + Math.floor(idx / tW2) * (exportCell + GAP), exportCell, idx + 1); });
                            if (showTitles && LIST_W > 0) {
                                var lx = PAD + tW2 * exportCell + (tW2 - 1) * GAP + LIST_PAD;
                                ctx.textAlign = 'left'; ctx.textBaseline = 'top';
                                var ly = yStart;
                                var HEADER_H = 11, ENTRY_H = 12, SEG_GAP = 8;
                                for (var r = 0; r < gridHeight; r++) {
                                    var segStart = r * tW2, segEnd = Math.min((r + 1) * tW2, grid.length);
                                    var items = [];
                                    for (var ii = segStart; ii < segEnd; ii++) { if (grid[ii]) items.push({ album: grid[ii], idx: ii }); }
                                    if (items.length === 0) continue;
                                    if (r > 0) { ly += SEG_GAP; }
                                    // Section header
                                    ctx.font = 'bold 8px "Courier New", monospace';
                                    ctx.fillStyle = titleColor;
                                    ctx.globalAlpha = 0.4;
                                    ctx.fillText((segStart + 1) + '\u2013' + segEnd, lx, ly);
                                    ctx.globalAlpha = 1;
                                    ly += HEADER_H;
                                    items.forEach(function (it) {
                                        ctx.font = '9px "Courier New", monospace';
                                        ctx.fillStyle = titleColor;
                                        ctx.globalAlpha = 0.85;
                                        var numPart = showNumbers ? (it.idx + 1) + '. ' : '';
                                        var txt = numPart + it.album.title + ' \u2014 ' + it.album.artist;
                                        // Clip text to LIST_W
                                        while (txt.length > 2 && ctx.measureText(txt).width > LIST_W) txt = txt.slice(0, -1);
                                        ctx.fillText(txt, lx, ly);
                                        ctx.globalAlpha = 1;
                                        ly += ENTRY_H;
                                    });
                                }
                            }
                        } else if (layout === 'classic') {
                            var ry = yStart;
                            var classicBaseW2 = 700;
                            var classicSegs = [{ s: 0, e: 5, c: 5, label: '1\u20135' }, { s: 5, e: 10, c: 5, label: '6\u201310' }, { s: 10, e: 16, c: 6, label: '11\u201316' }, { s: 16, e: 22, c: 6, label: '17\u201322' }, { s: 22, e: 32, c: 10, label: '23\u201332' }, { s: 32, e: 42, c: 10, label: '33\u201342' }];
                            classicSegs.forEach(function (row) {
                                var cs = Math.round((classicBaseW2 - GAP * (row.c - 1)) / row.c);
                                for (var i = row.s; i < row.e; i++) drawCell(grid[i] && grid[i].image, PAD + (i - row.s) * (cs + GAP), ry, cs, i + 1);
                                ry += cs + GAP;
                            });
                            if (showTitles && LIST_W > 0) {
                                var clx = PAD + classicBaseW2 + LIST_PAD;
                                ctx.textAlign = 'left'; ctx.textBaseline = 'top';
                                var cly = yStart;
                                var cHDR = 11, cENT = 12, cSEG = 8;
                                classicSegs.forEach(function (seg, si) {
                                    var items = [];
                                    for (var ii = seg.s; ii < seg.e; ii++) { if (grid[ii]) items.push({ album: grid[ii], idx: ii }); }
                                    if (items.length === 0) return;
                                    if (si > 0) { cly += cSEG; }
                                    ctx.font = 'bold 8px "Courier New",monospace'; ctx.fillStyle = titleColor; ctx.globalAlpha = 0.4;
                                    ctx.fillText(seg.label, clx, cly); ctx.globalAlpha = 1; cly += cHDR;
                                    items.forEach(function (it) {
                                        ctx.font = '9px "Courier New",monospace'; ctx.fillStyle = titleColor; ctx.globalAlpha = 0.85;
                                        var txt = (showNumbers ? (it.idx + 1) + '. ' : '') + it.album.title + ' \u2014 ' + it.album.artist;
                                        while (txt.length > 2 && ctx.measureText(txt).width > LIST_W) txt = txt.slice(0, -1);
                                        ctx.fillText(txt, clx, cly); ctx.globalAlpha = 1; cly += cENT;
                                    });
                                });
                            }
                        } else if (layout === 'classic2') {
                            var ry2 = yStart;
                            var c2BaseW2 = 700;
                            TOP100_ROW_CONFIG.forEach(function (seg) {
                                var cs = Math.round((c2BaseW2 - GAP * (seg.cols - 1)) / seg.cols), rows = Math.ceil((seg.end - seg.start) / seg.cols);
                                for (var r = 0; r < rows; r++) for (var c = 0; c < seg.cols; c++) { var idx = seg.start + r * seg.cols + c; if (idx >= seg.end) break; drawCell(grid[idx] && grid[idx].image, PAD + c * (cs + GAP), ry2 + r * (cs + GAP), cs, idx + 1); }
                                ry2 += rows * (cs + GAP);
                            });
                            if (showTitles && LIST_W > 0) {
                                var c2lx = PAD + c2BaseW2 + LIST_PAD;
                                ctx.textAlign = 'left'; ctx.textBaseline = 'top';
                                var c2ly = yStart;
                                var c2HDR = 11, c2ENT = 12, c2SEG = 8;
                                TOP100_ROW_CONFIG.forEach(function (seg, si) {
                                    var items = [];
                                    for (var ii = seg.start; ii < seg.end; ii++) { if (grid[ii]) items.push({ album: grid[ii], idx: ii }); }
                                    if (items.length === 0) return;
                                    if (si > 0) { c2ly += c2SEG; }
                                    ctx.font = 'bold 8px "Courier New",monospace'; ctx.fillStyle = titleColor; ctx.globalAlpha = 0.4;
                                    ctx.fillText((seg.start + 1) + '\u2013' + seg.end, c2lx, c2ly); ctx.globalAlpha = 1; c2ly += c2HDR;
                                    items.forEach(function (it) {
                                        ctx.font = '9px "Courier New",monospace'; ctx.fillStyle = titleColor; ctx.globalAlpha = 0.85;
                                        var txt = (showNumbers ? (it.idx + 1) + '. ' : '') + it.album.title + ' \u2014 ' + it.album.artist;
                                        while (txt.length > 2 && ctx.measureText(txt).width > LIST_W) txt = txt.slice(0, -1);
                                        ctx.fillText(txt, c2lx, c2ly); ctx.globalAlpha = 1; c2ly += c2ENT;
                                    });
                                });
                            }
                        } else {
                            var cs2 = cellStd, lH = 30;
                            aboutYouGrid.map(function (c) { return c && typeof c === 'object' ? c : { album: null, label: '' }; }).forEach(function (raw, idx) {
                                var col = idx % 6, row = Math.floor(idx / 6), x = PAD + col * (cs2 + GAP), y = PAD + row * (cs2 + lH + GAP);
                                drawCell(raw.album && raw.album.image, x, y, cs2, null);
                                ctx.fillStyle = titleColor; ctx.font = '10px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
                                var words = (raw.label || '').split(' '), line = '', ly = y + cs2 + 5;
                                words.forEach(function (w) { var t = line ? line + ' ' + w : w; if (ctx.measureText(t).width > cs2 - 4 && line) { ctx.fillText(line, x + cs2 / 2, ly); ly += 12; line = w; } else line = t; });
                                if (line) ctx.fillText(line, x + cs2 / 2, ly);
                            });
                        }

                        // Revoke all blob URLs now we're done drawing
                        Object.keys(blobUrls).forEach(function (k) { URL.revokeObjectURL(blobUrls[k]); });

                        var chartName = (charts[currentChartId] && charts[currentChartId].name || '').trim();
                        var dTitle = title && title !== 'My Top Albums' ? title : chartName;
                        var now = new Date(), p = function (n) { return String(n).padStart(2, '0'); };
                        var ts = p(now.getDate()) + '-' + p(now.getMonth() + 1) + '-' + now.getFullYear() + ' ' + p(now.getHours()) + '.' + p(now.getMinutes()) + '.' + p(now.getSeconds());

                        canvas.toBlob(function (blob) {
                            resetBtn();
                            if (!blob) return;
                            var url = URL.createObjectURL(blob);
                            var a = document.createElement('a');
                            a.download = (dTitle || 'topsters') + ' ' + ts + '.png';
                            a.href = url;
                            document.body.appendChild(a); a.click(); document.body.removeChild(a);
                            setTimeout(function () { URL.revokeObjectURL(url); }, 30000);
                        }, 'image/png');

                    } catch (err) {
                        console.error('Export draw error:', err);
                        resetBtn();
                    }
                }
            }, [layout, grid, aboutYouGrid, gridWidth, gridHeight, title, titleColor, bgColor, showNumbers, showTitles, gridGap, charts, currentChartId]);

            const exportData = useCallback(() => {
                const data = { layout, gridWidth, gridHeight, title, titleColor, bgColor, showTitles, grid, aboutYouGrid };
                const dataStr = JSON.stringify(data, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                const chartName = (charts[currentChartId]?.name || '').trim();
                const displayTitle = title && title !== 'My Top Albums' ? title : chartName;
                const baseName = displayTitle || 'topsters';
                link.download = `${baseName} ${getTimestamp()}.json`;
                link.click();
                URL.revokeObjectURL(url);
            }, [layout, gridWidth, gridHeight, title, titleColor, bgColor, showTitles, grid, aboutYouGrid, charts, currentChartId]);

            const importData = useCallback((event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (!data.grid && !data.aboutYouGrid) {
                            alert('Invalid data file');
                            return;
                        }
                        setLayout(data.layout || 'standard');
                        setGridWidth(data.gridWidth || 5);
                        setGridHeight(data.gridHeight || 5);
                        setTitle(data.title || 'My Top Albums');
                        setTitleColor(data.titleColor || '#ffffff');
                        setBgColor(data.bgColor || '#000000');
                        setShowTitles(data.showTitles || false);
                        setGrid(data.grid || []);
                        setAboutYouGrid(data.aboutYouGrid || []);
                    } catch (err) {
                        alert('Failed to import data. Please check the file format.');
                    }
                };
                reader.readAsText(file);
            }, []);

            const clearGrid = useCallback(() => {
                setShowConfirm(false);
                saveToHistory();
                if (layout === 'aboutYou') {
                    setAboutYouGrid(aboutYouLabels.map(label => ({ album: null, label })));
                } else if (layout === 'classic') {
                    setGrid(Array(TOP42_GRID_SIZE).fill(null));
                } else if (layout === 'classic2') {
                    setGrid(Array(TOP100_GRID_SIZE).fill(null));
                } else {
                    setGrid(Array(gridHeight * gridWidth).fill(null));
                }
            }, [layout, gridHeight, gridWidth, saveToHistory]);

            const handleImageUpload = useCallback((e) => {
                const files = Array.from(e.target.files);
                if (files.length > 0 && files[0].type.startsWith('image/')) {
                    const file = files[0];
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        setPendingImage(event.target.result);
                        setCustomTitle(file.name.replace(/\.[^/.]+$/, ""));
                        setCustomArtist('');
                        setShowImageModal(true);
                    };
                    reader.readAsDataURL(file);
                }
                e.target.value = '';
            }, []);

            const confirmImageUpload = useCallback(() => {
                if (pendingImage) {
                    const newImage = {
                        id: `uploaded-${Date.now()}-${Math.random()}`,
                        title: customTitle || 'Untitled',
                        artist: customArtist || 'Unknown Artist',
                        image: pendingImage,
                        year: ''
                    };
                    setUploadedImages(prev => [...prev, newImage]);
                }
                setShowImageModal(false);
                setPendingImage(null);
                setCustomTitle('');
                setCustomArtist('');
            }, [pendingImage, customTitle, customArtist]);

            const handleImageUploadKeyPress = useCallback((e) => {
                if (e.key === 'Enter') {
                    confirmImageUpload();
                }
            }, [confirmImageUpload]);

            const handlePasteImage = useCallback(async () => {
                try {
                    const clipboardItems = await navigator.clipboard.read();
                    for (const item of clipboardItems) {
                        if (item.types.includes('image/png') || item.types.includes('image/jpeg')) {
                            const blob = await item.getType(item.types.find(t => t.startsWith('image/')));
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                setPendingImage(e.target.result);
                                setCustomTitle('Pasted Image');
                                setCustomArtist('');
                                setShowImageModal(true);
                            };
                            reader.readAsDataURL(blob);
                            return;
                        }
                    }
                    alert('No image found in clipboard');
                } catch (err) {
                    console.error('Failed to read clipboard:', err);
                    alert('Failed to paste from clipboard. Make sure you have copied an image.');
                }
            }, []);



            const deleteUploadedImage = useCallback((imageId) => {
                setUploadedImages(prev => prev.filter(img => img.id !== imageId));
            }, []);

            const hasAlbums = useMemo(() =>
                layout === 'aboutYou'
                    ? aboutYouGrid.some(cell => cell?.album)
                    : grid.some(album => album),
                [layout, aboutYouGrid, grid]
            );

            const filledAlbums = useMemo(() =>
                layout === 'aboutYou'
                    ? aboutYouGrid.filter(cell => cell?.album).map(cell => cell.album)
                    : grid.filter(album => album),
                [layout, aboutYouGrid, grid]
            );

            return (
                <div className="min-h-screen bg-black relative overflow-hidden">
                    <AnimatedBackground colors={bgColors} />

                    {renameModalOpen && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm">
                            <div className="bg-gray-900 border border-white/20 rounded-2xl p-6 max-w-md mx-4 shadow-2xl">
                                <h3 className="text-xl font-bold text-white mb-4">Rename Album</h3>
                                <div className="space-y-3 mb-6">
                                    <div>
                                        <label className="block text-white text-sm font-medium mb-2">Album Title</label>
                                        <input
                                            type="text"
                                            value={renameTitle}
                                            onChange={(e) => setRenameTitle(e.target.value)}
                                            placeholder="Enter album title"
                                            className="w-full px-4 py-2 bg-white/10 border border-white/20 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50"
                                            autoFocus
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-white text-sm font-medium mb-2">Artist Name</label>
                                        <input
                                            type="text"
                                            value={renameArtist}
                                            onChange={(e) => setRenameArtist(e.target.value)}
                                            placeholder="Enter artist name"
                                            className="w-full px-4 py-2 bg-white/10 border border-white/20 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50"
                                        />
                                    </div>
                                </div>
                                <div className="flex gap-3">
                                    <button
                                        onClick={() => {
                                            setRenameModalOpen(false);
                                            setRenameIndex(null);
                                            setRenameTitle('');
                                            setRenameArtist('');
                                        }}
                                        className="flex-1 px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg transition-colors"
                                    >
                                        Cancel
                                    </button>
                                    <button
                                        onClick={confirmRename}
                                        className="flex-1 px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg font-semibold transition-colors"
                                    >
                                        Rename
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {showConfirm && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm">
                            <div className="bg-gray-900 border border-white/20 rounded-2xl p-6 max-w-sm mx-4 shadow-2xl">
                                <h3 className="text-xl font-bold text-white mb-3">Clear entire grid?</h3>
                                <p className="text-gray-400 mb-6">This will remove all albums from the grid.</p>
                                <div className="flex gap-3">
                                    <button
                                        onClick={() => setShowConfirm(false)}
                                        className="flex-1 px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg transition-colors"
                                    >
                                        Cancel
                                    </button>
                                    <button
                                        onClick={clearGrid}
                                        className="flex-1 px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg font-semibold transition-colors"
                                    >
                                        Clear Grid
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {showImageModal && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm">
                            <div className="bg-gray-900 border border-white/20 rounded-2xl p-6 max-w-md mx-4 shadow-2xl">
                                <h3 className="text-xl font-bold text-white mb-4">Add Custom Album</h3>
                                {pendingImage && (
                                    <img src={pendingImage} alt="Preview" className="w-32 h-32 rounded-lg mx-auto mb-4 object-cover" />
                                )}
                                <div className="space-y-3 mb-6">
                                    <div>
                                        <label className="block text-white text-sm font-medium mb-2">Album Title</label>
                                        <input
                                            type="text"
                                            value={customTitle}
                                            onChange={(e) => setCustomTitle(e.target.value)}
                                            placeholder="Enter album title"
                                            className="w-full px-4 py-2 bg-white/10 border border-white/20 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50"
                                            autoFocus
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-white text-sm font-medium mb-2">Artist Name</label>
                                        <input
                                            type="text"
                                            value={customArtist}
                                            onChange={(e) => setCustomArtist(e.target.value)}
                                            placeholder="Enter artist name"
                                            className="w-full px-4 py-2 bg-white/10 border border-white/20 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50"
                                        />
                                    </div>
                                </div>
                                <div className="flex gap-3">
                                    <button
                                        onClick={() => {
                                            setShowImageModal(false);
                                            setPendingImage(null);
                                            setCustomTitle('');
                                            setCustomArtist('');
                                        }}
                                        className="flex-1 px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg transition-colors"
                                    >
                                        Cancel
                                    </button>
                                    <button
                                        onClick={confirmImageUpload}
                                        className="flex-1 px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg font-semibold transition-colors"
                                    >
                                        Add to Library
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    <div className="relative z-10">
                        <div className="flex flex-wrap justify-between items-center gap-3 py-4 px-4 md:px-8 sticky top-0 z-20 bg-black/30 backdrop-blur-md border-b border-white/5">
                            <div className="flex items-center gap-4">
                                <a href="µsic.html" className="hover:opacity-80 transition-opacity">
                                    <h1 className="text-2xl md:text-3xl font-bold text-white drop-shadow-lg">µsic tools</h1>
                                </a>
                            </div>

                            <div className="flex flex-wrap gap-2 items-center">
                                {/* Charts Dropdown */}
                                <div className="relative" ref={chartsMenuRef}>
                                    <button
                                        onClick={() => setShowChartsMenu(!showChartsMenu)}
                                        className={`px-3 md:px-4 py-2 text-white rounded-lg border flex items-center gap-2 transition-colors ${showChartsMenu ? 'bg-white/20 border-white/30' : 'bg-white/10 hover:bg-white/20 border-white/20'}`}
                                    >
                                        <Layers className="w-4 h-4" />
                                        <span className="hidden sm:inline text-sm font-medium">{charts[currentChartId]?.name || 'Charts'}</span>
                                        <ChevronDown className={`w-3 h-3 transition-transform ${showChartsMenu ? 'rotate-180' : ''}`} />
                                    </button>

                                    {showChartsMenu && (
                                        <>
                                            <div className="absolute top-full mt-2 right-0 w-72 bg-gray-950/95 backdrop-blur-xl border border-white/10 rounded-2xl shadow-2xl overflow-hidden z-50">
                                                {/* Header */}
                                                <div className="px-4 pt-4 pb-3 border-b border-white/10 flex items-center justify-between">
                                                    <span className="text-white/60 text-xs font-semibold uppercase tracking-wider">Your Charts</span>
                                                    <button
                                                        onClick={() => { createNewChart(); setShowChartsMenu(false); }}
                                                        className="px-2.5 py-1 bg-white/10 hover:bg-white/20 text-white rounded-lg text-xs font-medium flex items-center gap-1.5 transition-colors border border-white/10"
                                                    >
                                                        <Plus className="w-3 h-3" /> New
                                                    </button>
                                                </div>
                                                {/* Chart list */}
                                                <div className="max-h-72 overflow-y-auto p-2 space-y-1">
                                                    {Object.entries(charts)
                                                        .sort(([, a], [, b]) => {
                                                            // Pinned first, then by lastModified
                                                            if (a.pinned && !b.pinned) return -1;
                                                            if (!a.pinned && b.pinned) return 1;
                                                            return b.lastModified - a.lastModified;
                                                        })
                                                        .map(([id, chart]) => {
                                                            const isActive = currentChartId === id;
                                                            const isRenaming = renamingChartId === id;
                                                            return (
                                                                <div
                                                                    key={id}
                                                                    className={`group flex items-center gap-2 px-2.5 py-2 rounded-xl transition-all ${isActive ? 'bg-white/15 border border-white/20' : 'hover:bg-white/8 border border-transparent cursor-pointer'}`}
                                                                    onClick={() => { if (!isActive && !isRenaming) { switchChart(id); setShowChartsMenu(false); } }}
                                                                >
                                                                    {/* Pin button */}
                                                                    <button
                                                                        onClick={(e) => toggleChartPin(e, id)}
                                                                        className={`flex-none p-0.5 rounded transition-colors ${chart.pinned ? 'text-yellow-400' : 'text-white/20 hover:text-white/60'}`}
                                                                        title={chart.pinned ? 'Unpin' : 'Pin to top'}
                                                                    >
                                                                        <Pin className="w-3.5 h-3.5" filled={chart.pinned} />
                                                                    </button>

                                                                    <div className="flex-1 min-w-0">
                                                                        {isRenaming ? (
                                                                            <input
                                                                                autoFocus
                                                                                type="text"
                                                                                defaultValue={chart.name}
                                                                                onClick={(e) => e.stopPropagation()}
                                                                                onBlur={(e) => { updateChartName(id, e.target.value || chart.name); setRenamingChartId(null); }}
                                                                                onKeyDown={(e) => {
                                                                                    e.stopPropagation();
                                                                                    if (e.key === 'Enter') { updateChartName(id, e.target.value || chart.name); setRenamingChartId(null); }
                                                                                    if (e.key === 'Escape') setRenamingChartId(null);
                                                                                }}
                                                                                className="w-full bg-white/10 text-white text-sm font-medium rounded px-2 py-0.5 focus:outline-none focus:ring-1 focus:ring-white/40 border border-white/20"
                                                                            />
                                                                        ) : (
                                                                            <div className="text-white text-sm font-medium truncate">{chart.name}</div>
                                                                        )}
                                                                        <div className="text-white/40 text-xs mt-0.5">
                                                                            {chart.layout === 'standard' ? `${chart.gridWidth}×${chart.gridHeight}` : chart.layout === 'classic' ? 'Top 42' : chart.layout === 'classic2' ? 'Top 100' : 'About You'}
                                                                            {' · '}{new Date(chart.lastModified).toLocaleDateString()}
                                                                        </div>
                                                                    </div>

                                                                    <div className="flex items-center gap-0.5 flex-none">
                                                                        {/* Rename button */}
                                                                        <button
                                                                            onClick={(e) => { e.stopPropagation(); setRenamingChartId(isRenaming ? null : id); }}
                                                                            className={`p-1 rounded transition-colors ${isRenaming ? 'text-white bg-white/20' : 'text-white/30 hover:text-white opacity-0 group-hover:opacity-100'}`}
                                                                            title="Rename"
                                                                        >
                                                                            <Pencil className="w-3 h-3" />
                                                                        </button>
                                                                        {/* Delete button — only if more than 1 chart */}
                                                                        {Object.keys(charts).length > 1 && (
                                                                            <button
                                                                                onClick={(e) => { e.stopPropagation(); if (confirm(`Delete "${chart.name}"?`)) deleteChart(id); }}
                                                                                className="p-1 text-white/30 hover:text-red-400 transition-colors opacity-0 group-hover:opacity-100 rounded"
                                                                                title="Delete"
                                                                            >
                                                                                <Trash className="w-3 h-3" />
                                                                            </button>
                                                                        )}
                                                                        {/* Active indicator */}
                                                                        {isActive && <span className="w-1.5 h-1.5 rounded-full bg-green-400 ml-1 flex-none"></span>}
                                                                    </div>
                                                                </div>
                                                            );
                                                        })}
                                                </div>
                                            </div>
                                        </>
                                    )}
                                </div>

                                <div className="h-6 w-px bg-white/10 mx-1"></div>

                                <button
                                    onClick={undo}
                                    disabled={history.length === 0}
                                    className="px-3 py-2 bg-white/10 hover:bg-white/20 disabled:opacity-50 disabled:cursor-not-allowed text-white rounded-lg border border-white/20 flex items-center gap-2 transition-colors"
                                    title="Undo (Ctrl+Z)"
                                >
                                    <Undo className="w-4 h-4" />
                                </button>
                                <button
                                    onClick={redo}
                                    disabled={future.length === 0}
                                    className="px-3 py-2 bg-white/10 hover:bg-white/20 disabled:opacity-50 disabled:cursor-not-allowed text-white rounded-lg border border-white/20 flex items-center gap-2 transition-colors"
                                    title="Redo (Ctrl+Y)"
                                >
                                    <Redo className="w-4 h-4" />
                                </button>

                                <div className="h-6 w-px bg-white/10 mx-1"></div>

                                <button
                                    id="export-btn"
                                    onClick={exportAsImage}
                                    className="px-3 md:px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg border border-white/20 flex items-center gap-2 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                                    title="Save as Image"
                                >
                                    <Photo className="w-4 h-4" />
                                    <span className="hidden sm:inline">Image</span>
                                </button>
                                <button
                                    onClick={exportData}
                                    className="px-3 md:px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg border border-white/20 flex items-center gap-2 transition-colors"
                                    title="Export chart data"
                                >
                                    <Upload className="w-4 h-4" />
                                    <span className="hidden sm:inline">Export</span>
                                </button>
                                <label className="px-3 md:px-4 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg border border-white/20 flex items-center gap-2 cursor-pointer transition-colors" title="Import chart data">
                                    <Download className="w-4 h-4" />
                                    <span className="hidden sm:inline">Import</span>
                                    <input type="file" accept=".json" onChange={importData} className="hidden" />
                                </label>
                                <button
                                    onClick={() => setShowConfirm(true)}
                                    className="px-3 md:px-4 py-2 bg-red-500/20 hover:bg-red-500/30 text-white rounded-lg border border-red-500/50 flex items-center gap-2 transition-colors"
                                >
                                    <Trash className="w-4 h-4" />
                                    <span className="hidden sm:inline">Clear</span>
                                </button>
                            </div>
                        </div>

                        <div className="p-4 md:p-6 max-w-7xl mx-auto">
                            <div className={`grid gap-4 md:gap-6 transition-all duration-300 ${leftPanelCollapsed ? 'lg:grid-cols-[48px_1fr]' : 'lg:grid-cols-[320px_1fr]'}`}>

                                {/* Left Panel with Tabs */}
                                <div className="space-y-4 transition-all duration-300">
                                    {leftPanelCollapsed && (
                                        <button
                                            onClick={() => setLeftPanelCollapsed(false)}
                                            className="w-full p-2.5 bg-white/10 hover:bg-white/20 text-white rounded-xl border border-white/20 transition-colors flex items-center justify-center"
                                            title="Expand Sidebar"
                                        >
                                            <ArrowRight className="w-5 h-5" />
                                        </button>
                                    )}
                                    {!leftPanelCollapsed && (<>
                                        {/* Tab Buttons */}
                                        <div className="flex gap-2 relative">
                                            <button
                                                onClick={() => setLeftPanelTab('search')}
                                                className={`flex-1 px-3 py-2 rounded-lg font-medium transition-all text-sm ${leftPanelTab === 'search' ? 'bg-white text-black' : 'bg-white/10 text-white hover:bg-white/20'}`}
                                            >
                                                <Search className="w-4 h-4 inline mr-1.5" />
                                                Search
                                            </button>
                                            <button
                                                onClick={() => setLeftPanelTab('options')}
                                                className={`flex-1 px-3 py-2 rounded-lg font-medium transition-all text-sm ${leftPanelTab === 'options' ? 'bg-white text-black' : 'bg-white/10 text-white hover:bg-white/20'}`}
                                            >
                                                <Settings className="w-4 h-4 inline mr-1.5" />
                                                Options
                                            </button>
                                        </div>

                                        {/* Search Panel */}
                                        {leftPanelTab === 'search' && (
                                            <div className="bg-white/5 backdrop-blur-sm rounded-2xl shadow-2xl border border-white/10 flex flex-col" style={{ maxHeight: 'calc(100vh - 180px)' }}>

                                                {/* Search Header & Inputs */}
                                                <div className="flex-none p-4 md:p-6 pb-3 space-y-3">
                                                    <p className="text-white/40 text-[10px] font-semibold uppercase tracking-widest">Search</p>
                                                    {/* Mode Toggles */}
                                                    <div className="flex gap-2">
                                                        <button
                                                            onClick={() => { setSearchMode('album'); setSearchResults([]); setArtistResults([]); setSelectedArtist(null); setArtistCatalog([]); }}
                                                            className={`flex-1 py-1.5 text-sm font-medium rounded-lg transition-colors ${searchMode === 'album' ? 'bg-white text-black' : 'bg-white/5 text-gray-400 hover:bg-white/10'
                                                                }`}
                                                        >
                                                            Albums
                                                        </button>
                                                        <button
                                                            onClick={() => { setSearchMode('artist'); setSearchResults([]); setArtistResults([]); setSelectedArtist(null); setArtistCatalog([]); }}
                                                            className={`flex-1 py-1.5 text-sm font-medium rounded-lg transition-colors ${searchMode === 'artist' ? 'bg-white text-black' : 'bg-white/5 text-gray-400 hover:bg-white/10'
                                                                }`}
                                                        >
                                                            Artists
                                                        </button>
                                                    </div>

                                                    {/* Inputs */}
                                                    {searchMode === 'album' ? (
                                                        <>
                                                            <input
                                                                type="text"
                                                                value={advSearch.album}
                                                                onChange={(e) => {
                                                                    const val = e.target.value;
                                                                    setAdvSearch({ ...advSearch, album: val });
                                                                    if (!val.trim()) setSearchResults([]);
                                                                }}
                                                                onKeyPress={(e) => e.key === 'Enter' && searchAlbums()}
                                                                placeholder="Album Name"
                                                                className="w-full px-4 py-2 bg-white/10 border border-white/20 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50"
                                                            />
                                                            <div className="flex gap-2">
                                                                <input
                                                                    type="text"
                                                                    value={advSearch.artist}
                                                                    onChange={(e) => setAdvSearch({ ...advSearch, artist: e.target.value })}
                                                                    onKeyPress={(e) => e.key === 'Enter' && searchAlbums()}
                                                                    placeholder="Artist (Optional)"
                                                                    className="flex-[2] min-w-0 px-4 py-2 bg-white/10 border border-white/20 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50 text-sm"
                                                                />
                                                                <input
                                                                    type="text"
                                                                    value={advSearch.year}
                                                                    onChange={(e) => setAdvSearch({ ...advSearch, year: e.target.value })}
                                                                    onKeyPress={(e) => e.key === 'Enter' && searchAlbums()}
                                                                    placeholder="Year"
                                                                    className="flex-1 min-w-0 px-4 py-2 bg-white/10 border border-white/20 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50 text-sm"
                                                                />
                                                            </div>
                                                        </>
                                                    ) : (
                                                        <input
                                                            type="text"
                                                            value={advSearch.artist}
                                                            onChange={(e) => {
                                                                const val = e.target.value;
                                                                setAdvSearch({ ...advSearch, artist: val });
                                                                if (!val.trim()) { setArtistResults([]); setSelectedArtist(null); setArtistCatalog([]); }
                                                            }}
                                                            onKeyPress={(e) => e.key === 'Enter' && searchAlbums()}
                                                            placeholder="Artist Name"
                                                            className="w-full px-4 py-2 bg-white/10 border border-white/20 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50"
                                                        />
                                                    )}

                                                    <button
                                                        onClick={searchAlbums}
                                                        disabled={loading}
                                                        className="w-full px-4 py-2 bg-white text-black font-bold rounded-lg hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                                                    >
                                                        {loading ? (
                                                            <span className="flex items-center justify-center gap-2">
                                                                <Loader className="w-4 h-4 animate-spin" />
                                                                Searching...
                                                            </span>
                                                        ) : 'Search'}
                                                    </button>

                                                    {/* Action Buttons */}
                                                    <div className="grid grid-cols-2 gap-2">
                                                        <button
                                                            onClick={handlePasteImage}
                                                            className="px-3 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg border border-white/20 flex items-center justify-center gap-2 cursor-pointer text-sm transition-colors"
                                                        >
                                                            <Clipboard className="w-4 h-4" />
                                                            Paste
                                                        </button>
                                                        <label className="px-3 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg border border-white/20 flex items-center justify-center gap-2 cursor-pointer text-sm transition-colors">
                                                            <Upload className="w-4 h-4" />
                                                            Upload
                                                            <input
                                                                type="file"
                                                                accept="image/*"
                                                                onChange={(e) => {
                                                                    const file = e.target.files[0];
                                                                    if (file) {
                                                                        const reader = new FileReader();
                                                                        reader.onload = (e) => {
                                                                            setPendingImage(e.target.result);
                                                                            setShowImageModal(true);
                                                                        };
                                                                        reader.readAsDataURL(file);
                                                                    }
                                                                }}
                                                                className="hidden"
                                                            />
                                                        </label>
                                                    </div>
                                                </div>

                                                {/* Results / Uploads — scrollable area */}
                                                <div className="flex-1 overflow-y-auto space-y-4 min-h-0 px-4 md:px-6 pb-3">
                                                    {uploadedImages.length > 0 && (
                                                        <div>
                                                            <h4 className="text-white font-semibold mb-2 text-xs uppercase tracking-wider sticky top-0 bg-black/50 backdrop-blur-sm py-1">Recent Uploads</h4>
                                                            <div className="space-y-2">
                                                                {uploadedImages.slice(-5).reverse().map((album) => (
                                                                    <div
                                                                        key={album.id}
                                                                        className="bg-white/10 rounded-lg p-2 flex items-center gap-3 border border-white/10 group"
                                                                    >
                                                                        <img
                                                                            src={album.image}
                                                                            alt={album.title}
                                                                            className="w-12 h-12 rounded object-cover cursor-grab"
                                                                            draggable
                                                                            onDragStart={(e) => handleDragStart(e, album, null)}
                                                                            onDragEnd={handleDragEnd}
                                                                        />
                                                                        <div className="flex-1 min-w-0">
                                                                            <p className="text-white text-sm font-medium truncate">{album.title}</p>
                                                                            <p className="text-gray-400 text-xs truncate">{album.artist}</p>
                                                                        </div>
                                                                        <button
                                                                            onClick={() => {
                                                                                const newImages = uploadedImages.filter(img => img.id !== album.id);
                                                                                setUploadedImages(newImages);
                                                                            }}
                                                                            className="opacity-0 group-hover:opacity-100 p-1 hover:bg-red-500/20 rounded transition-all"
                                                                        >
                                                                            <Trash className="w-4 h-4 text-red-400" />
                                                                        </button>
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        </div>
                                                    )}

                                                    {/* Artist browse: step 1 — artist list */}
                                                    {searchMode === 'artist' && !selectedArtist && artistResults.length > 0 && (
                                                        <div>
                                                            <div className="space-y-1.5">
                                                                {artistResults.map((artist) => (
                                                                    <button
                                                                        key={artist.id}
                                                                        onClick={() => loadArtistCatalog(artist)}
                                                                        className="w-full bg-white/10 hover:bg-white/20 rounded-lg px-3 py-2.5 flex items-center gap-3 border border-white/10 transition-all text-left"
                                                                    >
                                                                        <div className="w-8 h-8 rounded-full bg-white/20 flex items-center justify-center flex-none text-white font-bold text-sm">
                                                                            {artist.name.charAt(0).toUpperCase()}
                                                                        </div>
                                                                        <div className="flex-1 min-w-0">
                                                                            <p className="text-white text-sm font-medium truncate">{artist.name}</p>
                                                                            {artist.genre && <p className="text-gray-400 text-xs truncate">{artist.genre}</p>}
                                                                        </div>
                                                                        <ArrowRight className="w-4 h-4 text-white/40 flex-none" />
                                                                    </button>
                                                                ))}
                                                            </div>
                                                        </div>
                                                    )}

                                                    {/* Artist browse: step 2 — catalog */}
                                                    {searchMode === 'artist' && selectedArtist && (
                                                        <div>
                                                            <div className="sticky top-0 bg-black/60 backdrop-blur-sm py-1.5 mb-2 flex items-center gap-2">
                                                                <button
                                                                    onClick={() => { setSelectedArtist(null); setArtistCatalog([]); }}
                                                                    className="text-white/60 hover:text-white text-xs flex items-center gap-1 transition-colors"
                                                                >
                                                                    <ChevronLeft className="w-3 h-3" /> Back
                                                                </button>
                                                                <span className="text-white text-xs font-semibold truncate flex-1">{selectedArtist.name}</span>
                                                                {artistCatalogLoading && <Loader className="w-3 h-3 text-white/60" />}
                                                            </div>
                                                            {artistCatalogLoading && artistCatalog.length === 0 && (
                                                                <div className="text-white/40 text-sm text-center py-8">Loading discography…</div>
                                                            )}
                                                            <div className="space-y-2">
                                                                {artistCatalog.map((album) => (
                                                                    <div
                                                                        key={album.id}
                                                                        draggable
                                                                        onDragStart={(e) => handleDragStart(e, album, null)}
                                                                        onDragEnd={handleDragEnd}
                                                                        className="album-cover bg-white/10 rounded-lg p-2 flex items-center gap-3 hover:bg-white/20 transition-all border border-white/10 cursor-grab"
                                                                    >
                                                                        <img src={album.image} alt={album.title} className="w-12 h-12 rounded object-cover flex-none" loading="lazy" />
                                                                        <div className="flex-1 min-w-0">
                                                                            <p className="text-white text-sm font-medium truncate">{album.title}</p>
                                                                            <p className="text-gray-400 text-xs truncate">{album.year || ''}</p>
                                                                        </div>
                                                                    </div>
                                                                ))}
                                                            </div>
                                                            {!artistCatalogLoading && artistCatalog.length === 0 && (
                                                                <div className="text-white/40 text-sm text-center py-8">No albums found</div>
                                                            )}
                                                        </div>
                                                    )}

                                                    {/* Album search results */}
                                                    {searchMode === 'album' && (
                                                        <div className="space-y-2">
                                                            {paginatedResults.map((album) => (
                                                                <div
                                                                    key={album.id}
                                                                    draggable
                                                                    onDragStart={(e) => handleDragStart(e, album, null)}
                                                                    onDragEnd={handleDragEnd}
                                                                    className="album-cover bg-white/10 rounded-lg p-2 flex items-center gap-3 hover:bg-white/20 transition-all border border-white/10 cursor-grab"
                                                                >
                                                                    <img src={album.image} alt={album.title} className="w-12 h-12 rounded object-cover" loading="lazy" />
                                                                    <div className="flex-1 min-w-0">
                                                                        <p className="text-white text-sm font-medium truncate">{album.title}</p>
                                                                        <p className="text-gray-400 text-xs truncate">
                                                                            {album.artist} {album.year ? `(${album.year})` : ''}
                                                                        </p>
                                                                    </div>
                                                                </div>
                                                            ))}
                                                        </div>
                                                    )}
                                                </div>

                                                {/* Pagination — fixed at bottom, never overlaps results */}
                                                {searchMode === 'album' && searchResults.length > itemsPerPage && (
                                                    <div className="flex-none border-t border-white/10 px-4 py-3">
                                                        <div className="flex items-center gap-2">
                                                            <button
                                                                onClick={() => setSearchPage(p => Math.max(0, p - 1))}
                                                                disabled={searchPage === 0}
                                                                className="flex-1 py-2 bg-white/10 hover:bg-white/20 disabled:opacity-30 disabled:cursor-not-allowed text-white text-sm rounded-lg transition-colors font-medium"
                                                            >
                                                                ← Prev
                                                            </button>
                                                            <span className="text-white/50 text-xs font-medium px-2 whitespace-nowrap">
                                                                {searchPage + 1} / {totalPages}
                                                            </span>
                                                            <button
                                                                onClick={() => setSearchPage(p => Math.min(totalPages - 1, p + 1))}
                                                                disabled={searchPage >= totalPages - 1}
                                                                className="flex-1 py-2 bg-white/10 hover:bg-white/20 disabled:opacity-30 disabled:cursor-not-allowed text-white text-sm rounded-lg transition-colors font-medium"
                                                            >
                                                                Next →
                                                            </button>
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                        )}

                                        {/* Options Panel */}
                                        {leftPanelTab === 'options' && (
                                            <div className="bg-white/5 backdrop-blur-2xl rounded-2xl p-4 md:p-6 shadow-2xl border border-white/10 overflow-y-auto" style={{ maxHeight: 'calc(100vh - 180px)' }}>

                                                <div className="space-y-4">
                                                    {/* LAYOUT section */}
                                                    <div>
                                                        <p className="text-white/40 text-[10px] font-semibold uppercase tracking-widest mb-2">Layout</p>
                                                        <div className="space-y-2">
                                                            <button
                                                                onClick={() => switchLayout('standard')}
                                                                className={`w-full px-4 py-2 rounded-lg font-medium transition-all text-sm ${layout === 'standard' ? 'bg-white text-black' : 'bg-white/10 text-white hover:bg-white/20'
                                                                    }`}
                                                            >
                                                                Standard Grid
                                                            </button>
                                                            <button
                                                                onClick={() => switchLayout('classic')}
                                                                className={`w-full px-4 py-2 rounded-lg font-medium transition-all text-sm ${layout === 'classic' ? 'bg-white text-black' : 'bg-white/10 text-white hover:bg-white/20'
                                                                    }`}
                                                            >
                                                                Top 42
                                                            </button>
                                                            <button
                                                                onClick={() => switchLayout('classic2')}
                                                                className={`w-full px-4 py-2 rounded-lg font-medium transition-all text-sm ${layout === 'classic2' ? 'bg-white text-black' : 'bg-white/10 text-white hover:bg-white/20'
                                                                    }`}
                                                            >
                                                                Top 100
                                                            </button>
                                                            <button
                                                                onClick={() => switchLayout('aboutYou')}
                                                                className={`w-full px-4 py-2 rounded-lg font-medium transition-all text-sm ${layout === 'aboutYou' ? 'bg-white text-black' : 'bg-white/10 text-white hover:bg-white/20'
                                                                    }`}
                                                            >
                                                                About You
                                                            </button>
                                                        </div>
                                                    </div>

                                                    <hr className="border-white/10" />

                                                    {/* CHART SETTINGS section */}
                                                    <div className="space-y-4">
                                                        <p className="text-white/40 text-[10px] font-semibold uppercase tracking-widest">Chart Settings</p>

                                                        {layout === 'standard' && (
                                                            <>
                                                                <div>
                                                                    <label className="block text-white text-sm font-medium mb-2">Title</label>
                                                                    <input
                                                                        type="text"
                                                                        value={title}
                                                                        onChange={(e) => setTitle(e.target.value)}
                                                                        className="w-full px-4 py-2 bg-white/10 border border-white/20 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50"
                                                                    />
                                                                </div>

                                                                <div className="grid grid-cols-2 gap-3">
                                                                    <div>
                                                                        <label className="block text-white text-sm font-medium mb-2">Width</label>
                                                                        <input
                                                                            type="number"
                                                                            min="1"
                                                                            max="12"
                                                                            value={gridWidth}
                                                                            onChange={(e) => setGridWidth(Math.min(12, Math.max(1, parseInt(e.target.value) || 1)))}
                                                                            className="w-full px-4 py-2 bg-white/10 border border-white/20 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-white/50"
                                                                        />
                                                                    </div>
                                                                    <div>
                                                                        <label className="block text-white text-sm font-medium mb-2">Height</label>
                                                                        <input
                                                                            type="number"
                                                                            min="1"
                                                                            max="12"
                                                                            value={gridHeight}
                                                                            onChange={(e) => setGridHeight(Math.min(12, Math.max(1, parseInt(e.target.value) || 1)))}
                                                                            className="w-full px-4 py-2 bg-white/10 border border-white/20 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-white/50"
                                                                        />
                                                                    </div>
                                                                </div>
                                                            </>
                                                        )}

                                                        {(layout === 'classic' || layout === 'classic2') && (
                                                            <div>
                                                                <label className="block text-white text-sm font-medium mb-2">Title</label>
                                                                <input
                                                                    type="text"
                                                                    value={title}
                                                                    onChange={(e) => setTitle(e.target.value)}
                                                                    className="w-full px-4 py-2 bg-white/10 border border-white/20 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-white/50"
                                                                />
                                                            </div>
                                                        )}

                                                        {(layout === 'standard' || layout === 'classic' || layout === 'classic2') && (
                                                            <div>
                                                                <label className="block text-white text-sm font-medium mb-2">Tile Gap: {gridGap}px</label>
                                                                <input
                                                                    type="range"
                                                                    min="0"
                                                                    max="16"
                                                                    value={gridGap}
                                                                    onChange={(e) => setGridGap(parseInt(e.target.value))}
                                                                    className="w-full accent-white"
                                                                />
                                                            </div>
                                                        )}

                                                        <div className="grid grid-cols-2 gap-3">
                                                            <div>
                                                                <label className="block text-white text-sm font-medium mb-2">Text Colour</label>
                                                                <input
                                                                    type="color"
                                                                    value={titleColor}
                                                                    onChange={(e) => setTitleColor(e.target.value)}
                                                                    className="w-full h-10 rounded-lg cursor-pointer border border-white/20 bg-white/10 p-1"
                                                                />
                                                            </div>
                                                            <div>
                                                                <label className="block text-white text-sm font-medium mb-2">BG Colour</label>
                                                                <input
                                                                    type="color"
                                                                    value={bgColor}
                                                                    onChange={(e) => setBgColor(e.target.value)}
                                                                    className="w-full h-10 rounded-lg cursor-pointer border border-white/20 bg-white/10 p-1"
                                                                />
                                                            </div>
                                                        </div>
                                                    </div>

                                                    {(layout === 'standard' || layout === 'classic' || layout === 'classic2') && (
                                                        <>
                                                            <hr className="border-white/10" />
                                                            {/* MORE OPTIONS section */}
                                                            <div className="space-y-3">
                                                                <p className="text-white/40 text-[10px] font-semibold uppercase tracking-widest">More Options</p>
                                                                <label className="toggle-switch">
                                                                    <input type="checkbox" checked={showTitles} onChange={(e) => setShowTitles(e.target.checked)} />
                                                                    <span className="toggle-track"><span className="toggle-thumb"></span></span>
                                                                    <span className="toggle-label">Show album list</span>
                                                                </label>
                                                                <label className="toggle-switch">
                                                                    <input type="checkbox" checked={showNumbers} onChange={(e) => setShowNumbers(e.target.checked)} />
                                                                    <span className="toggle-track"><span className="toggle-thumb"></span></span>
                                                                    <span className="toggle-label">Show numbers</span>
                                                                </label>
                                                                <label className="toggle-switch">
                                                                    <input type="checkbox" checked={replaceOnDrop} onChange={(e) => setReplaceOnDrop(e.target.checked)} />
                                                                    <span className="toggle-track"><span className="toggle-thumb"></span></span>
                                                                    <span className="toggle-label">Replace album on drop</span>
                                                                </label>
                                                            </div>
                                                        </>
                                                    )}
                                                </div>
                                            </div>
                                        )}
                                    </>)}
                                    {/* Collapse sidebar button */}
                                    {!leftPanelCollapsed && (
                                        <button
                                            onClick={() => setLeftPanelCollapsed(true)}
                                            className="w-full py-2 bg-white/5 hover:bg-white/10 text-white/50 hover:text-white rounded-xl border border-white/10 flex items-center justify-center gap-2 text-sm transition-all"
                                            title="Collapse Sidebar"
                                        >
                                            <ChevronLeft className="w-4 h-4" />
                                            Hide sidebar
                                        </button>
                                    )}
                                </div>

                                {/* Right Panel - Grid */}
                                <div className="bg-white/5 backdrop-blur-2xl rounded-2xl p-4 md:p-6 shadow-2xl border border-white/10">
                                    <div ref={gridRef} style={{ backgroundColor: bgColor }} className="p-6 md:p-8 rounded-xl min-h-[400px]">
                                        {layout === 'standard' && (
                                            <>
                                                {title && (
                                                    <h2 style={{ color: titleColor }} className="text-2xl md:text-3xl font-bold text-center mb-6">
                                                        {title}
                                                    </h2>
                                                )}
                                                <div className="flex gap-6">
                                                    <div className={`flex-1${gridGap === 0 ? ' zero-gap' : ''}`} style={{ display: 'grid', gridTemplateColumns: `repeat(${gridWidth}, minmax(0, 1fr))`, gap: `${gridGap}px` }}>
                                                        {grid.map((album, index) => {
                                                            return (
                                                                <div
                                                                    key={index}
                                                                    draggable={!!album}
                                                                    className={`aspect-square relative group ${album ? 'grid-slot hidden-guides' : 'grid-slot'} ${dragOverIndex === index ? 'drag-over' : ''} ${album ? 'cursor-grab active:cursor-grabbing' : ''}`}
                                                                    onDragStart={(e) => { if (album) handleDragStart(e, album, index); else e.preventDefault(); }}
                                                                    onDragEnd={handleDragEnd}
                                                                    onDragOver={(e) => handleDragOver(e, index)}
                                                                    onDrop={(e) => handleDrop(e, index)}
                                                                    onDragEnter={() => setDragOverIndex(index)}
                                                                    onDragLeave={() => setDragOverIndex(null)}
                                                                >
                                                                    {album ? (
                                                                        <>
                                                                            <img
                                                                                src={album.image}
                                                                                alt={album.title}
                                                                                draggable={false}
                                                                                onContextMenu={(e) => {
                                                                                    e.preventDefault();
                                                                                    openRenameModal(index);
                                                                                }}
                                                                                className="album-cover w-full h-full object-cover pointer-events-none"
                                                                            />
                                                                            <div className="absolute top-1 right-1 flex gap-1 opacity-0 group-hover:opacity-100 transition-all z-10">
                                                                                <button onMouseDown={(e) => e.stopPropagation()} onClick={(e) => { e.stopPropagation(); openRenameModal(index); }} className="bg-blue-500 hover:bg-blue-600 text-white p-1 rounded">
                                                                                    <Pencil className="w-3 h-3" />
                                                                                </button>
                                                                                <button onMouseDown={(e) => e.stopPropagation()} onClick={(e) => { e.stopPropagation(); removeFromGrid(index); }} className="bg-red-500 hover:bg-red-600 text-white p-1 rounded">
                                                                                    <Trash className="w-3 h-3" />
                                                                                </button>
                                                                            </div>
                                                                            {showNumbers && (
                                                                                <div className="absolute bottom-1 left-1 bg-black/70 text-white px-1.5 py-0.5 rounded text-xs font-bold pointer-events-none">
                                                                                    {index + 1}
                                                                                </div>
                                                                            )}
                                                                        </>
                                                                    ) : (
                                                                        <div className="absolute inset-0 text-white/50 text-xs flex items-center justify-center font-bold">{showNumbers ? index + 1 : ''}</div>
                                                                    )}
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                    {showTitles && (
                                                        <div className="w-48 hidden lg:block flex-shrink-0 self-start" style={{ fontFamily: "'Courier New', Courier, monospace" }}>
                                                            {(() => {
                                                                const filledGrid = grid.map((a, i) => ({ album: a, idx: i })).filter(x => x.album);
                                                                if (filledGrid.length === 0) return null;
                                                                const rows = [];
                                                                for (let r = 0; r < gridHeight; r++) {
                                                                    const rowItems = filledGrid.filter(x => Math.floor(x.idx / gridWidth) === r);
                                                                    if (rowItems.length > 0) rows.push(rowItems);
                                                                }
                                                                return rows.map((rowItems, gi) => (
                                                                    <div key={gi} className={gi > 0 ? 'mt-2' : ''}>
                                                                        {rowItems.map(({ album, idx }) => (
                                                                            <div key={idx} style={{ color: titleColor, fontSize: '9px', lineHeight: '1.35', marginBottom: '1px', cursor: 'pointer', opacity: 0.85 }} onClick={() => openRenameModal(idx)} className="hover:opacity-100 transition-opacity truncate">
                                                                                {showNumbers && <span style={{ opacity: 0.55, marginRight: '3px' }}>{idx + 1}.</span>}{album.title} — {album.artist}
                                                                            </div>
                                                                        ))}
                                                                    </div>
                                                                ));
                                                            })()}
                                                        </div>
                                                    )}
                                                </div>
                                            </>
                                        )}

                                        {layout === 'aboutYou' && (
                                            <div className="max-w-[800px] mx-auto">
                                                <div className="grid grid-cols-6 gap-x-2 gap-y-3 w-full">
                                                    {aboutYouGrid.map((rawCell, index) => {
                                                        const cell = rawCell && typeof rawCell === 'object'
                                                            ? rawCell
                                                            : { album: null, label: aboutYouLabels[index] || '' };
                                                        return (
                                                            <div
                                                                key={index}
                                                                onDragOver={(e) => handleDragOver(e, index)}
                                                                onDragLeave={handleDragLeave}
                                                                onDrop={(e) => handleDrop(e, index)}
                                                                className={`relative group transition-all flex flex-col ${dragOverIndex === index ? 'drag-over' : ''}`}
                                                            >
                                                                {/* Square image slot */}
                                                                <div className={`relative w-full aspect-square grid-slot ${cell.album ? 'hidden-guides' : ''}`}>
                                                                    {cell.album ? (
                                                                        <>
                                                                            <img
                                                                                src={cell.album.image}
                                                                                alt={cell.album.title}
                                                                                draggable
                                                                                onDragStart={(e) => handleDragStart(e, cell.album, index)}
                                                                                onDragEnd={handleDragEnd}
                                                                                className="album-cover w-full h-full object-cover"
                                                                            />
                                                                            <button
                                                                                onClick={() => removeFromGrid(index)}
                                                                                className="absolute top-1 right-1 bg-red-500 hover:bg-red-600 text-white p-1 rounded opacity-0 group-hover:opacity-100 transition-all z-10"
                                                                            >
                                                                                <Trash className="w-3 h-3" />
                                                                            </button>
                                                                        </>
                                                                    ) : (
                                                                        <div className="w-full h-full"></div>
                                                                    )}
                                                                </div>
                                                                {/* Label — wraps freely, never clipped */}
                                                                <div
                                                                    contentEditable
                                                                    suppressContentEditableWarning
                                                                    onBlur={(e) => updateLabel(index, e.currentTarget.textContent)}
                                                                    className="editable-label text-[10px] leading-tight font-medium w-full mt-1 px-0.5 outline-none text-center min-h-[2em]"
                                                                    style={{ color: titleColor, wordBreak: 'break-word', whiteSpace: 'normal' }}
                                                                >
                                                                    {cell.label || ''}
                                                                </div>
                                                            </div>
                                                        );
                                                    })}
                                                </div>
                                            </div>
                                        )}

                                        {layout === 'classic' && (
                                            <>
                                                {title && (
                                                    <h2 style={{ color: titleColor }} className="text-2xl md:text-3xl font-bold text-center mb-4">
                                                        {title}
                                                    </h2>
                                                )}
                                                <div className="flex gap-6">
                                                    <div className={`flex-1 max-w-[600px] mx-auto${gridGap === 0 ? ' zero-gap' : ''}`}>
                                                        {/* Row 1: 5 albums */}
                                                        <div className="grid grid-cols-5" style={{ gap: `${gridGap}px` }}>
                                                            {grid.slice(0, 5).map((album, i) => (
                                                                <div
                                                                    key={i}
                                                                    draggable={!!album}
                                                                    onDragStart={(e) => { if (album) handleDragStart(e, album, i); else e.preventDefault(); }}
                                                                    onDragEnd={handleDragEnd}
                                                                    onDragOver={(e) => handleDragOver(e, i)}
                                                                    onDragLeave={handleDragLeave}
                                                                    onDrop={(e) => handleDrop(e, i)}
                                                                    className={`aspect-square relative group ${album ? 'grid-slot hidden-guides' : 'grid-slot'} ${dragOverIndex === i ? 'drag-over' : ''} ${album ? 'cursor-grab active:cursor-grabbing' : ''}`}
                                                                >
                                                                    {album ? (
                                                                        <>
                                                                            <img
                                                                                src={album.image}
                                                                                alt={album.title}
                                                                                draggable={false}
                                                                                onContextMenu={(e) => { e.preventDefault(); openRenameModal(i); }}
                                                                                className="w-full h-full object-cover pointer-events-none"
                                                                            />
                                                                            <div className="absolute top-1 right-1 flex gap-1 opacity-0 group-hover:opacity-100 z-10">
                                                                                <button onMouseDown={(e) => e.stopPropagation()} onClick={(e) => { e.stopPropagation(); openRenameModal(i); }} className="bg-blue-500 hover:bg-blue-600 text-white p-1 rounded">
                                                                                    <Pencil className="w-3 h-3" />
                                                                                </button>
                                                                                <button onMouseDown={(e) => e.stopPropagation()} onClick={(e) => { e.stopPropagation(); removeFromGrid(i); }} className="bg-red-500 hover:bg-red-600 text-white p-1 rounded">
                                                                                    <Trash className="w-3 h-3" />
                                                                                </button>
                                                                            </div>
                                                                            {showNumbers && (
                                                                                <div className="absolute bottom-1 left-1 bg-black/70 text-white px-1.5 py-0.5 rounded text-xs font-bold pointer-events-none">
                                                                                    {i + 1}
                                                                                </div>
                                                                            )}
                                                                        </>
                                                                    ) : <div className="text-white text-center text-xs flex items-center justify-center h-full">{showNumbers ? i + 1 : ''}</div>}
                                                                </div>
                                                            ))}
                                                        </div>
                                                        {/* Rows 2-6 */}
                                                        {[
                                                            { start: 5, end: 10, cols: 5 },
                                                            { start: 10, end: 16, cols: 6 },
                                                            { start: 16, end: 22, cols: 6 },
                                                            { start: 22, end: 32, cols: 10 },
                                                            { start: 32, end: 42, cols: 10 }
                                                        ].map(({ start, end, cols }) => (
                                                            <div key={start} className={`grid`} style={{ gridTemplateColumns: `repeat(${cols}, minmax(0, 1fr))`, gap: `${gridGap}px`, marginTop: `${gridGap}px` }}>
                                                                {grid.slice(start, end).map((album, i) => {
                                                                    const idx = start + i;
                                                                    return (
                                                                        <div
                                                                            key={idx}
                                                                            draggable={!!album}
                                                                            onDragStart={(e) => { if (album) handleDragStart(e, album, idx); else e.preventDefault(); }}
                                                                            onDragEnd={handleDragEnd}
                                                                            onDragOver={(e) => handleDragOver(e, idx)}
                                                                            onDragLeave={handleDragLeave}
                                                                            onDrop={(e) => handleDrop(e, idx)}
                                                                            className={`aspect-square relative group ${album ? 'classic-slot hidden-guides' : 'classic-slot'} ${dragOverIndex === idx ? 'drag-over' : ''} ${album ? 'cursor-grab active:cursor-grabbing' : ''}`}
                                                                        >
                                                                            {album ? (
                                                                                <>
                                                                                    <img
                                                                                        src={album.image}
                                                                                        alt={album.title}
                                                                                        draggable={false}
                                                                                        onContextMenu={(e) => { e.preventDefault(); openRenameModal(idx); }}
                                                                                        className="w-full h-full object-cover pointer-events-none"
                                                                                    />
                                                                                    <div className="absolute top-0.5 right-0.5 flex gap-0.5 opacity-0 group-hover:opacity-100 z-10">
                                                                                        <button onMouseDown={(e) => e.stopPropagation()} onClick={(e) => { e.stopPropagation(); openRenameModal(idx); }} className="bg-blue-500 text-white p-0.5 rounded">
                                                                                            <Pencil className="w-2 h-2" />
                                                                                        </button>
                                                                                        <button onMouseDown={(e) => e.stopPropagation()} onClick={(e) => { e.stopPropagation(); removeFromGrid(idx); }} className="bg-red-500 text-white p-0.5 rounded">
                                                                                            <Trash className="w-2 h-2" />
                                                                                        </button>
                                                                                    </div>
                                                                                    {showNumbers && (
                                                                                        <div className="absolute bottom-0.5 left-0.5 bg-black/70 text-white px-1 py-0.5 rounded text-[10px] font-bold pointer-events-none">
                                                                                            {idx + 1}
                                                                                        </div>
                                                                                    )}
                                                                                </>
                                                                            ) : <div className="text-white text-center text-[8px] flex items-center justify-center h-full">{showNumbers ? idx + 1 : ''}</div>}
                                                                        </div>
                                                                    );
                                                                })}
                                                            </div>
                                                        ))}
                                                    </div>
                                                    {showTitles && filledAlbums.length > 0 && (
                                                        <div className="w-48 hidden lg:block flex-shrink-0 self-start" style={{ fontFamily: "'Courier New', Courier, monospace" }}>
                                                            {[{ s: 0, e: 5 }, { s: 5, e: 10 }, { s: 10, e: 16 }, { s: 16, e: 22 }, { s: 22, e: 32 }, { s: 32, e: 42 }].map((seg, gi) => {
                                                                const items = grid.slice(seg.s, seg.e).map((a, i) => ({ album: a, idx: seg.s + i })).filter(x => x.album);
                                                                if (items.length === 0) return null;
                                                                return (
                                                                    <div key={gi} className={gi > 0 ? 'mt-2' : ''}>
                                                                        {items.map(({ album, idx }) => (
                                                                            <div key={idx} style={{ color: titleColor, fontSize: '9px', lineHeight: '1.35', marginBottom: '1px', cursor: 'pointer', opacity: 0.85 }} onClick={() => openRenameModal(idx)} className="hover:opacity-100 transition-opacity truncate">
                                                                                {showNumbers && <span style={{ opacity: 0.55, marginRight: '3px' }}>{idx + 1}.</span>}{album.title} — {album.artist}
                                                                            </div>
                                                                        ))}
                                                                    </div>
                                                                );
                                                            })}
                                                        </div>
                                                    )}
                                                </div>
                                            </>
                                        )}

                                        {layout === 'classic2' && (
                                            <>
                                                {title && (
                                                    <h2 style={{ color: titleColor }} className="text-2xl md:text-3xl font-bold text-center mb-4">
                                                        {title}
                                                    </h2>
                                                )}
                                                <div className="flex gap-6">
                                                    <div className={`flex-1 max-w-[600px] mx-auto${gridGap === 0 ? ' zero-gap' : ''}`}>
                                                        {TOP100_ROW_CONFIG.map(({ start, end, cols }, rowIdx) => (
                                                            <div key={start} className={`grid`} style={{ gridTemplateColumns: `repeat(${cols}, minmax(0, 1fr))`, gap: `${gridGap}px`, marginTop: rowIdx > 0 ? `${gridGap}px` : '0' }}>
                                                                {grid.slice(start, end).map((album, i) => {
                                                                    const idx = start + i;
                                                                    return (
                                                                        <div
                                                                            key={idx}
                                                                            draggable={!!album}
                                                                            onDragStart={(e) => { if (album) handleDragStart(e, album, idx); else e.preventDefault(); }}
                                                                            onDragEnd={handleDragEnd}
                                                                            onDragOver={(e) => handleDragOver(e, idx)}
                                                                            onDragLeave={handleDragLeave}
                                                                            onDrop={(e) => handleDrop(e, idx)}
                                                                            className={`aspect-square relative group ${album ? 'grid-slot hidden-guides' : 'grid-slot'} ${dragOverIndex === idx ? 'drag-over' : ''} ${album ? 'cursor-grab active:cursor-grabbing' : ''}`}
                                                                        >
                                                                            {album ? (
                                                                                <>
                                                                                    <img
                                                                                        src={album.image}
                                                                                        alt={album.title}
                                                                                        draggable={false}
                                                                                        onContextMenu={(e) => { e.preventDefault(); openRenameModal(idx); }}
                                                                                        className="w-full h-full object-cover pointer-events-none"
                                                                                    />
                                                                                    <div className="absolute top-0.5 right-0.5 flex gap-0.5 opacity-0 group-hover:opacity-100 z-10">
                                                                                        <button onMouseDown={(e) => e.stopPropagation()} onClick={(e) => { e.stopPropagation(); openRenameModal(idx); }} className="bg-blue-500 text-white p-0.5 rounded">
                                                                                            <Pencil className="w-2 h-2" />
                                                                                        </button>
                                                                                        <button onMouseDown={(e) => e.stopPropagation()} onClick={(e) => { e.stopPropagation(); removeFromGrid(idx); }} className="bg-red-500 text-white p-0.5 rounded">
                                                                                            <Trash className="w-2 h-2" />
                                                                                        </button>
                                                                                    </div>
                                                                                    {showNumbers && (
                                                                                        <div className="absolute bottom-0.5 left-0.5 bg-black/70 text-white px-1 py-0.5 rounded text-[8px] font-bold pointer-events-none">
                                                                                            {idx + 1}
                                                                                        </div>
                                                                                    )}
                                                                                </>
                                                                            ) : <div className="text-white text-center text-[8px] flex items-center justify-center h-full">{showNumbers ? idx + 1 : ''}</div>}
                                                                        </div>
                                                                    );
                                                                })}
                                                            </div>
                                                        ))}
                                                    </div>
                                                    {showTitles && filledAlbums.length > 0 && (
                                                        <div className="w-48 hidden lg:block flex-shrink-0 self-start" style={{ fontFamily: "'Courier New', Courier, monospace" }}>
                                                            {TOP100_ROW_CONFIG.map((seg, gi) => {
                                                                const items = grid.slice(seg.start, seg.end).map((a, i) => ({ album: a, idx: seg.start + i })).filter(x => x.album);
                                                                if (items.length === 0) return null;
                                                                return (
                                                                    <div key={gi} className={gi > 0 ? 'mt-2' : ''}>
                                                                        {items.map(({ album, idx }) => (
                                                                            <div key={idx} style={{ color: titleColor, fontSize: '9px', lineHeight: '1.35', marginBottom: '1px', cursor: 'pointer', opacity: 0.85 }} onClick={() => openRenameModal(idx)} className="hover:opacity-100 transition-opacity truncate">
                                                                                {showNumbers && <span style={{ opacity: 0.55, marginRight: '3px' }}>{idx + 1}.</span>}{album.title} — {album.artist}
                                                                            </div>
                                                                        ))}
                                                                    </div>
                                                                );
                                                            })}
                                                        </div>
                                                    )}
                                                </div>
                                            </>
                                        )}
                                    </div>
                                </div>
                            </div>
                        </div >
                    </div >
                </div >
            );
        }

        ReactDOM.render(<TopstersMode />, document.getElementById('root'));
    </script>
    <!-- Help Button -->
    <button id="helpBtn"
        onclick="document.getElementById('helpModal').classList.remove('hidden'); document.body.style.overflow='hidden';"
        class="fixed bottom-6 right-6 w-12 h-12 flex items-center justify-center rounded-full z-40 transition-all duration-300 hover:scale-110 active:scale-95"
        style="background: rgba(255,255,255,0.12); border: 1px solid rgba(255,255,255,0.2); backdrop-filter: blur(20px); box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
        <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
    </button>

    <!-- Help Modal -->
    <div id="helpModal" class="hidden fixed inset-0 z-50 flex items-center justify-center p-4"
        style="background: rgba(0,0,0,0.8); backdrop-filter: blur(8px);"
        onclick="if(event.target===this){this.classList.add('hidden');document.body.style.overflow='auto';}">
        <div class="w-full max-w-2xl" onclick="event.stopPropagation()">
            <div class="rounded-3xl p-8 shadow-2xl"
                style="background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); backdrop-filter: blur(40px);">
                <div class="flex items-center justify-between mb-6">
                    <h3 class="text-3xl font-bold text-white">Topsters</h3>
                    <button
                        onclick="document.getElementById('helpModal').classList.add('hidden');document.body.style.overflow='auto';"
                        class="w-10 h-10 flex items-center justify-center rounded-full transition-all"
                        style="background: rgba(255,255,255,0.1);">
                        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <div class="text-gray-200 space-y-4 overflow-y-auto pr-2" style="max-height: 60vh;">
                    <div class="space-y-6">
                        <div>
                            <h4 class="text-xl font-semibold text-white mb-2">What are Topsters?</h4>
                            <p class="text-gray-300">Grids of album covers showing your favourites — you've definitely
                                seen these on social media. They originated on music forums like RateYourMusic and
                                4chan's /mu/ as a quick way to show off your taste.</p>
                        </div>
                        <div>
                            <h4 class="text-xl font-semibold text-white mb-2">Layout Modes</h4>
                            <ul class="space-y-2 text-gray-300">
                                <li><strong>Standard:</strong> custom grid — set any width and height you want (up to
                                    12×12)</li>
                                <li><strong>Top 42:</strong> the classic 6×7 /mu/ format</li>
                                <li><strong>Top 100:</strong> a 10×10 grid. Requires commitment</li>
                                <li><strong>About You:</strong> labelled slots for albums that represent different
                                    things — your most played, comfort listen, the one that got you into music, etc.
                                </li>
                            </ul>
                        </div>
                        <div>
                            <h4 class="text-xl font-semibold text-white mb-2">Using This Tool</h4>
                            <ul class="space-y-2 text-gray-300">
                                <li><strong>Search albums:</strong> search by album name or browse by artist. Pulls from iTunes and Last.fm, with duplicate results automatically merged</li>
                                <li><strong>Drag & drop:</strong> arrange albums however you like. Drag one onto another
                                    to swap them</li>
                                <li><strong>Right-click an album:</strong> rename or remove it from the grid</li>
                                <li><strong>Multiple charts:</strong> create and switch between multiple saved charts
                                </li>
                                <li><strong>Customise:</strong> toggle album titles, numbers, change background colour,
                                    adjust grid gap</li>
                                <li><strong>Export:</strong> download as a PNG image, ready to post</li>
                            </ul>
                        </div>
                        <div class="rounded-xl p-4"
                            style="background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);">
                            <h4 class="text-base font-semibold text-white mb-3 flex items-center gap-2">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M9 3v2m6-2v2M9 19v2m6-2v2M5 9H3m2 6H3m18-6h-2m2 6h-2M7 19h10a2 2 0 002-2V7a2 2 0 00-2-2H7a2 2 0 00-2 2v10a2 2 0 002 2zM9 9h6v6H9V9z" />
                                </svg>
                                Keyboard Shortcuts
                            </h4>
                            <div class="space-y-2 text-sm text-gray-300">
                                <div class="flex items-center justify-between"><span>Undo last action</span><kbd
                                        class="px-2 py-0.5 rounded text-xs"
                                        style="background:rgba(255,255,255,0.1);">⌘/Ctrl Z</kbd></div>
                                <div class="flex items-center justify-between"><span>Redo</span><span
                                        class="flex gap-1"><kbd class="px-2 py-0.5 rounded text-xs"
                                            style="background:rgba(255,255,255,0.1);">⌘/Ctrl ⇧ Z</kbd><span
                                            class="text-gray-500 text-xs mx-1">or</span><kbd
                                            class="px-2 py-0.5 rounded text-xs"
                                            style="background:rgba(255,255,255,0.1);">⌘/Ctrl Y</kbd></span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                document.getElementById('helpModal').classList.add('hidden');
                document.body.style.overflow = 'auto';
            }
        });
    </script>
</body>

</html>
